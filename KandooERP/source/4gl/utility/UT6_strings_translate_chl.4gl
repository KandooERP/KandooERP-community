# module generated by Kandoo Ffg(c) 
# Generated on 2021-03-01 08:41:35
# template H:\Eclipse\git\KandooERP\KandooERP\Resources\Utilities\Perl\Ffg/templates/module/Kandoo-child-standard.mtplt 
GLOBALS "../common/glob_GLOBALS.4gl"
GLOBALS
	DEFINE glob_rec_formonly RECORD
		translate_similar_strings BOOLEAN
	END RECORD
	DEFINE glob_enu_msg LIKE application_strings.string_contents
	DEFINE type_frm_rec_U807_strings_translation TYPE AS RECORD # This is the TYPE for form image record		
		string_id LIKE application_strings.string_id, #  integer	
		program_name LIKE fgltarget.program_name, # varchar(28)	
		container LIKE application_strings.container, #  varchar(24)		
		string_type LIKE application_strings.string_type, #  char(10)		
		string_contents LIKE application_strings.string_contents, #  lvarchar(256)		
		xnumber INTEGER , # ,		
		trsltd_messages INTEGER, # ,		
		tobe_trsltd_messages INTEGER # 				
	END RECORD	
	DEFINE glob_fgltarget_clause STRING	
END GLOBALS

# Define types to be reused in functions
DEFINE type_prykey_strings_translation TYPE AS RECORD # Define Primary Key Type of Child Table
	string_id LIKE strings_translation.string_id, # integer
	language_code LIKE strings_translation.language_code, # char(3)
	country_code LIKE strings_translation.country_code # char(3)
END RECORD

DEFINE type_fgnkey_strings_translation TYPE AS RECORD # Define Foreign Key type -> application_strings
	string_id LIKE strings_translation.string_id # integer
END RECORD

DEFINE type_ArrElem_U807_strings_translation TYPE AS RECORD # Define Screen Record Array Type
	language_code LIKE strings_translation.language_code, #  char(3)
	country_code LIKE strings_translation.country_code, # char(3)
	translation LIKE strings_translation.translation, #  lvarchar(256)
	last_modification_ts LIKE strings_translation.last_modification_ts,  # DATETIME YEAR TO SECOND, # ,
	text_length INTEGER , # ,
	identical_count INTEGER # 
END RECORD

DEFINE type_act_array_strings_translation TYPE AS CHAR(1)    # Define Action Array Type

DEFINE type_FullRec_strings_translation TYPE AS RECORD # Define full record of child table
	string_id LIKE strings_translation.string_id, # integer
	language_code LIKE strings_translation.language_code, # char(3)
	country_code LIKE strings_translation.country_code, # char(3)
	translation LIKE strings_translation.translation, # lvarchar(256)
	last_modification_ts LIKE strings_translation.last_modification_ts  # DATETIME YEAR TO SECOND, # ,

END RECORD

# Define module scope variables and arrays
# Cursors
DEFINE crs_array_fgnkey_child_strings_translation CURSOR	# cursor or child table based on foreign key
DEFINE crs_array_qbe_child_strings_translation CURSOR		# cursor on child table based on qbe

#Prepared statements
DEFINE prp_insert_strings_translation PREPARED
DEFINE prp_update_strings_translation PREPARED
DEFINE prp_delete_strings_translation PREPARED


FUNCTION sql_prepare_queries_child_UT6_strings_translate ()
# this function initializes all cursors and prepared statements for the strings_translation and lookups

DEFINE l_query_stmt STRING 
	# Prepare the cursor to display the strings_translation array
	# using foreign key pointing to application_strings

	LET l_query_stmt = "SELECT '=',	strings_translation.string_id,strings_translation.language_code	,strings_translation.country_code,",
	"strings_translation.language_code,",
	"strings_translation.country_code, ",
	"strings_translation.translation,",
	"strings_translation.last_modification_ts,",
	"NULL::SMALLINT,",
	"NULL::SMALLINT",
	"  FROM strings_translation, ",
	"application_strings ",
	"WHERE strings_translation.string_id = application_strings.string_id ",
	" AND  strings_translation.string_id = ?	",
	" ORDER BY 	strings_translation.string_id,strings_translation.language_code	"
	CALL crs_array_fgnkey_child_strings_translation.Declare(l_query_stmt)

	# PREPARE INSERT statement
	LET l_query_stmt =
	"INSERT INTO strings_translation (	string_id,language_code,country_code,translation,last_modification_ts	)",
	" VALUES ( 	?,?,?,?,?	)" 
	CALL prp_insert_strings_translation.Prepare(l_query_stmt)

	# PREPARE UPDATE statement
	let l_query_stmt =
	"UPDATE strings_translation ",
	"SET ( 	translation,last_modification_ts	)",
	" = ( 	?,?	)",
	" WHERE  string_id = ?
    AND language_code = ?	AND country_code = ? " 
	CALL prp_update_strings_translation.Prepare(l_query_stmt)

	# PREPARE DELETE statement
	let l_query_stmt = "DELETE FROM strings_translation ",
	" WHERE  string_id = ?
    AND language_code = ? AND country_code = ?" 
	CALL prp_delete_strings_translation.Prepare(l_query_stmt)

END FUNCTION # sql_prepare_queries_UT6_strings_translate_strings_translation

FUNCTION sql_open_array_crs_scr_array_strings_translation(fky)
## This function opens the main cursor for the table strings_translation
	DEFINE lsql_ok integer
	DEFINE fky type_fgnkey_strings_translation

	WHENEVER SQLERROR CONTINUE
	CALL crs_array_fgnkey_child_strings_translation.Open(fky.*)

	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
	CASE 
		WHEN sqlca.sqlcode = 100 
			LET lsql_ok = 0
		WHEN sqlca.sqlcode < 0 
			LET lsql_ok = -1
		OTHERWISE
			LET lsql_ok = 1
	END CASE
	RETURN lsql_ok
END FUNCTION #  sql_open_array_crs_scr_array_strings_translation

FUNCTION sql_insert_strings_translation(p_rec_strings_translation)
## INSERT in table strings_translation 
	DEFINE p_rec_strings_translation type_FullRec_strings_translation
	DEFINE lsql_stmt_status INTEGER
	DEFINE lookup_status INTEGER
	DEFINE nb_deleted_rows INTEGER

	WHENEVER SQLERROR CONTINUE
	CALL prp_insert_strings_translation.Execute(
	p_rec_strings_translation.string_id,
	p_rec_strings_translation.language_code,
	p_rec_strings_translation.country_code,
	p_rec_strings_translation.translation,
	p_rec_strings_translation.last_modification_ts	)
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler

	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status = 0
		WHEN sqlca.sqlcode < 0
			ERROR "sql_insert strings_translation:failed "
			LET lsql_stmt_status = -1
	END CASE
	RETURN lsql_stmt_status
END FUNCTION # sql_insert_strings_translation

FUNCTION sql_update_strings_translation(p_prykey,p_rec_strings_translation)
## sql_update_strings_translation :update current strings_translation record
	DEFINE p_prykey type_prykey_strings_translation
	DEFINE p_rec_strings_translation type_FullRec_strings_translation
	DEFINE lsql_stmt_status INTEGER
	DEFINE nb_modified_rows INTEGER

	WHENEVER SQLERROR CONTINUE
	CALL prp_update_strings_translation.Execute(p_rec_strings_translation.translation,p_rec_strings_translation.last_modification_ts,p_prykey.*)

	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status = 0
			LET nb_modified_rows = sqlca.sqlerrd[3]
		WHEN sqlca.sqlcode < 0
			ERROR "sql_update strings_translation:failed "
			LET lsql_stmt_status = -1
			LET nb_modified_rows = 0
	END CASE
	RETURN lsql_stmt_status,nb_modified_rows
END FUNCTION # sql_update_strings_translation

FUNCTION sql_delete_strings_translation(p_prykey)
## delete_strings_translation :delete Selected row in table strings_translation 
	DEFINE p_prykey type_prykey_strings_translation
	DEFINE lsql_stmt_status smallint
	DEFINE nb_deleted_rows INTEGER

	WHENEVER SQLERROR CONTINUE
	CALL prp_delete_strings_translation.Execute(p_prykey.*)
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status=0
			LET nb_deleted_rows = sqlca.sqlerrd[3]
		WHEN sqlca.sqlcode < 0 
			ERROR "sql_delete strings_translation:failed "
			LET lsql_stmt_status = -1
	END CASE
	RETURN lsql_stmt_status,nb_deleted_rows
END FUNCTION # sql_delete_strings_translation

################################################################################
FUNCTION sql_pky_exists_strings_translation(p_prykey)  
#"# This function Checks if primary key exists
## inbound parameter : record of primary key
## outbound parameter:  status > 0 if exists, 0 if no record, < 0 if error
################################################################################
	DEFINE p_prykey type_prykey_strings_translation
	DEFINE pk_status INTEGER

	WHENEVER SQLERROR CONTINUE
	OPEN crs_prykey__crs_ USING p_prykey.*
	FETCH crs_prykey__crs_ 
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler

	CASE sqlca.sqlcode
		WHEN 0 
			LET pk_status = 1
		WHEN 100
			LET pk_status = 0
		WHEN sqlca.sqlerrd[2] = 104
			LET pk_status = -1 # record locked
		WHEN sqlca.sqlcode < 0
			LET pk_status = sqlca.sqlcode
	END CASE
	RETURN pk_status
END FUNCTION #  sql_pky_exists_strings_translation

######################################################################################################################################################
FUNCTION sql_fill_child_array_from_fgnkey_strings_translation (p_fgnkey,p_mode)
# This function opens the array cursor , fetches the data to populate the 3 arrays
# inbound params: foreign key,
#                 read mode: VIEW -> default isolation, EDIT -> REPEATABLE READ
# outbound params: the 3 arrays
	DEFINE p_fgnkey type_fgnkey_strings_translation
	define p_mode CHAR(5)
	DEFINE l_scr_array_strings_translation DYNAMIC ARRAY OF type_ArrElem_U807_strings_translation
	DEFINE l_pky_array_strings_translation DYNAMIC ARRAY OF type_prykey_strings_translation
	DEFINE l_act_array_strings_translation DYNAMIC ARRAY OF type_act_array_strings_translation
	DEFINE elem_num INTEGER
	DEFINE sql_ok INTEGER

	# initializes arrays
	CALL l_scr_array_strings_translation.clear()
	CALL l_pky_array_strings_translation.clear()
    CALL l_act_array_strings_translation.clear()
	IF p_mode = "EDIT" THEN
		SET ISOLATION TO REPEATABLE READ
		# If we plan to edit records, all records will received a RR lock to protect the data set from being modified
	END IF

	CALL crs_array_fgnkey_child_strings_translation.Open(p_fgnkey.*)

	LET elem_num = 1
	WHILE crs_array_fgnkey_child_strings_translation.FetchNext (l_act_array_strings_translation[elem_num],l_pky_array_strings_translation[elem_num].*,l_scr_array_strings_translation[elem_num].*) = 0
		LET elem_num = elem_num + 1
		IF elem_num > 500 THEN	
			EXIT WHILE
		END IF
	END WHILE

	CASE
		WHEN sqlca.sqlcode = 100 # we have passed the last element, this element must be deleted
			# elem_num is 1 beyond real number of element, must delete last element
			CALL l_scr_array_strings_translation.deleteElement(elem_num)
			CALL l_pky_array_strings_translation.deleteElement(elem_num)
			CALL l_act_array_strings_translation.deleteElement(elem_num)

			LET elem_num = elem_num - 1
		WHEN sqlca.sqlcode < 0
			LET elem_num = 0
	END CASE

	RETURN sqlca.sqlcode,elem_num,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation
END FUNCTION # sql_fill_child_array_from_fgnkey_strings_translation 

######################################################################################################################################################
FUNCTION sql_declare_cursor_qbe_child_strings_translation (p_where_clause,p_mode)
# This function opens the array cursor , fetches the data to populate the 3 arrays
# inbound params: where clause from qbe on chid table,
#                 read mode: VIEW -> default isolation, EDIT -> REPEATABLE READ
# outbound params: the 3 arrays
	DEFINE p_where_clause STRING
	define p_mode CHAR(5)
	DEFINE l_fgnkey type_fgnkey_strings_translation
	DEFINE qbe_stmt,qbe_predicate STRING
	DEFINE elem_num,l_idx INTEGER
	DEFINE sql_ok INTEGER
	DEFINE l_arr_tables_list DYNAMIC ARRAY OF STRING
	DEFINE l_arr_joins_list DYNAMIC ARRAY OF STRING
	DEFINE applications_strings_in_predicate BOOLEAN


	CALL l_arr_tables_list.append("strings_translation")  
	LET applications_strings_in_predicate = false
	IF util.REGEX.search(p_where_clause,/\bapplication_strings\./) THEN
		CALL l_arr_tables_list.append("application_strings")
		CALL l_arr_joins_list.append("application_strings.string_id = strings_translation.string_id")
		LET applications_strings_in_predicate = TRUE
	END IF

	IF util.REGEX.search(p_where_clause,/\bfgltarget\./) THEN	# application_strings + fgltarget
		CALL l_arr_tables_list.append("fgltarget") 
		CALL l_arr_joins_list.append("application_strings.container = fgltarget.container")
		IF applications_strings_in_predicate = false THEN
			# if criteria on fgltarget, we need relationship with application_strings
			CALL l_arr_tables_list.append("application_strings")
			CALL l_arr_joins_list.append("application_strings.string_id = strings_translation.string_id")
		END IF

	END IF

	# build the tables list
	FOR l_idx = 1 TO l_arr_tables_list.GetSize()
		LET qbe_predicate = qbe_predicate,l_arr_tables_list[l_idx],","
	END FOR
	CALL util.REGEX.replace(qbe_predicate,/,$/," ") returning qbe_predicate
	LET qbe_predicate = qbe_predicate," WHERE "
	
	# build the joins list
	FOR l_idx = 1 TO l_arr_joins_list.GetSize()
		LET qbe_predicate = qbe_predicate,l_arr_joins_list[l_idx]," AND "
	END FOR
	CALL util.REGEX.replace(qbe_predicate,/ AND $/," ") returning qbe_predicate
--	LET qbe_statement = "SELECT count(*) FROM ",qbe_predicate," AND ",p_where_clause
	LET qbe_stmt = "SELECT '=',	strings_translation.string_id,strings_translation.language_code	,strings_translation.country_code,",
	"strings_translation.language_code,",
	"strings_translation.country_code,",
	"strings_translation.translation,",
	"strings_translation.last_modification_ts,",
	"NULL::SMALLINT,",
	"NULL::SMALLINT,",
	"strings_translation.string_id ", 	# foreign key
	"  FROM ",qbe_predicate
	IF util.REGEX.search(qbe_predicate,/WHERE\s*$/) THEN
		# if we have NO join in the statement
	ELSE
		LET qbe_stmt = qbe_stmt," AND "
	END IF
	LET qbe_stmt = qbe_stmt,p_where_clause," ORDER BY 	strings_translation.string_id,strings_translation.language_code	"
	CALL crs_array_qbe_child_strings_translation.Declare(qbe_stmt)
	RETURN sqlca.sqlcode
END FUNCTION		#  sql_declare_cursor_qbe_child_strings_translation

######################################################################################################################################################
FUNCTION sql_fill_child_array_from_qbe_strings_translation (p_mode)
# This function opens the array cursor , fetches the data to populate the 3 arrays
# inbound params: where clause from qbe on chid table,
#                 read mode: VIEW -> default isolation, EDIT -> REPEATABLE READ
# outbound params: the 3 arrays
	define p_mode CHAR(5)
	DEFINE l_fgnkey type_fgnkey_strings_translation
	DEFINE l_scr_array_strings_translation DYNAMIC ARRAY OF type_ArrElem_U807_strings_translation
	DEFINE l_pky_array_strings_translation DYNAMIC ARRAY OF type_prykey_strings_translation
	DEFINE l_act_array_strings_translation DYNAMIC ARRAY OF type_act_array_strings_translation
	DEFINE l_fky_array_strings_translation DYNAMIC ARRAY OF type_fgnkey_strings_translation
	DEFINE qbe_stmt,qbe_predicate STRING
	DEFINE elem_num,l_idx INTEGER
	DEFINE sql_ok INTEGER

	# initializes arrays
	CALL l_scr_array_strings_translation.clear()
	CALL l_pky_array_strings_translation.clear()
    CALL l_act_array_strings_translation.clear()
    CALL l_fky_array_strings_translation.clear()
	IF p_mode = "EDIT" THEN
		SET ISOLATION TO REPEATABLE READ
		# If we plan to edit records, all records will received a RR lock to protect the data set from being modified
	END IF

	CALL crs_array_qbe_child_strings_translation.Open()

	LET elem_num = 1
	WHILE crs_array_qbe_child_strings_translation.FetchNext (l_act_array_strings_translation[elem_num],l_pky_array_strings_translation[elem_num].*,l_scr_array_strings_translation[elem_num].*,l_fky_array_strings_translation[elem_num].*) = 0
		LET elem_num = elem_num + 1
	END WHILE

	CASE
		WHEN sqlca.sqlcode = 100 # we have passed the last element, this element must be deleted
			# elem_num is 1 beyond real number of element, must delete last element
			CALL l_scr_array_strings_translation.deleteElement(elem_num)
			CALL l_pky_array_strings_translation.deleteElement(elem_num)
			CALL l_act_array_strings_translation.deleteElement(elem_num)
			CALL l_fky_array_strings_translation.deleteElement(elem_num)
			LET elem_num = elem_num - 1
		WHEN sqlca.sqlcode < 0
			LET elem_num = 0
	END CASE
	RETURN elem_num,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation,l_fky_array_strings_translation
END FUNCTION # sql_fill_child_array_from_fgnkey_strings_translation 

FUNCTION query_child_data()
	DEFINE l_where_clause STRING
	DEFINE l_scr_array_strings_translation DYNAMIC ARRAY OF type_ArrElem_U807_strings_translation
	DEFINE l_pky_array_strings_translation DYNAMIC ARRAY OF type_prykey_strings_translation
	DEFINE l_act_array_strings_translation DYNAMIC ARRAY OF type_act_array_strings_translation
	DEFINE l_fky_array_strings_translation DYNAMIC ARRAY OF type_fgnkey_strings_translation
	DEFINE l_prykey_application_strings type_fgnkey_strings_translation
	DEFINE l_fgnkey type_fgnkey_strings_translation
	DEFINE nbr_edited_rows,sql_action INTEGER
	# Build the QBE where clause
	INITIALIZE l_prykey_application_strings.* TO NULL
	CALL frm_construct_dataset_UT6_strings_translate_child() RETURNING l_where_clause 
	IF l_where_clause IS NOT NULL THEN
		CALL edit_array_srec_translation (l_prykey_application_strings.*,l_where_clause)
	END IF
	RETURN l_where_clause

END FUNCTION  # query_child_data
#######################################################################
FUNCTION frm_construct_dataset_UT6_strings_translate_child()
## frm_construct_dataset_UT6_strings_translate_U807_strings_translation : Query By Example on table application_strings
## Input selection criteria,
## prepare the query,
## open the data set
	DEFINE qbe_statement,where_clause STRING
	DEFINE xnumber,sql_stmt_status INTEGER
--	DEFINE l_prykey type_prykey_application_strings 

--	DEFINE l_frm_rec_U807_strings_translation type_frm_rec_U807_strings_translation # Form image record

	DEFINE reply CHAR(5)
	LET xnumber = 0
	MESSAGE "Please input query criteria"
	# initialize record and display blank
	CLEAR application_strings.*
	CLEAR srec_translation.*

	CONSTRUCT BY NAME where_clause ON 
		fgltarget.program_name,
		application_strings.container,
		application_strings.string_type,		
		application_strings.string_contents,
		strings_translation.language_code,
		strings_translation.country_code,
		strings_translation.translation,	
		strings_translation.last_modification_ts

	## Check whether criteria have been entered
	AFTER CONSTRUCT 
		IF NOT field_touched(srec_translation.*) AND NOT int_flag THEN
			LET reply = fgl_winbutton("","Select all rows, are you sure?","Yes","Yes|No","question",0)
			CASE 
			WHEN reply MATCHES "Yes"
				EXIT CONSTRUCT 
			OTHERWISE # Saisie d'un critere de selection
				ERROR "Please input a least one criteria"
				CONTINUE CONSTRUCT
			END CASE
		END IF
	END CONSTRUCT

	IF int_flag = TRUE THEN
		LET where_clause = NULL
		MESSAGE "Quit with quit key"
		LET int_flag=0
	END IF
	RETURN where_clause
END FUNCTION ## frm_construct_dataset_UT6_strings_translate_child


######################################################################################################################################################
FUNCTION frm_display_array_child_UT6_strings_translate (p_fgnkey,p_browse)
# This function displays the array data (scr_array_strings_translation) based on the foreign key 
# browse: False means that the array is displayed without possibility of browsing inside (just show array and skip to next parent row)
######################################################################################################################################################
	DEFINE p_fgnkey type_fgnkey_strings_translation
	DEFINE p_browse BOOLEAN
	DEFINE l_scr_array_strings_translation DYNAMIC ARRAY OF type_ArrElem_U807_strings_translation
	DEFINE l_pky_array_strings_translation DYNAMIC ARRAY OF type_prykey_strings_translation
	DEFINE l_act_array_strings_translation DYNAMIC ARRAY OF type_act_array_strings_translation
	DEFINE elem_num,choice INTEGER
	DEFINE arrcurr,srcline INTEGER
	DEFINE sql_ok INTEGER
	DEFINE qbe_statement STRING
	DEFINE browse BOOLEAN
	DEFINE sql_stmt_status INTEGER

	CALL sql_fill_child_array_from_fgnkey_strings_translation (p_fgnkey,"VIEW") 
	RETURNING sql_ok,elem_num,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation

	DISPLAY ARRAY l_scr_array_strings_translation
	TO srec_translation.*
		BEFORE DISPLAY
			IF browse = FALSE THEN
				# just display in the array without entering it
				EXIT DISPLAY
			END IF
	END DISPLAY

	RETURN elem_num
END FUNCTION # frm_display_array_child_UT6_strings_translate

###########################################################################################################
FUNCTION edit_array_srec_translation (p_fgnkey,p_where_clause)
# This function calls the INPUT array function (frm_input_array_srec_translation) to edit the array data
# then, accordingly, the SQL statement functions (array_bulk_update_)
# it is generally called from another module
###########################################################################################################
	DEFINE p_fgnkey type_fgnkey_strings_translation
	DEFINE p_where_clause STRING
	DEFINE l_scr_array_strings_translation DYNAMIC ARRAY OF type_ArrElem_U807_strings_translation
	DEFINE l_pky_array_strings_translation DYNAMIC ARRAY OF type_prykey_strings_translation
	DEFINE l_act_array_strings_translation DYNAMIC ARRAY OF type_act_array_strings_translation
	DEFINE l_fky_array_strings_translation DYNAMIC ARRAY OF type_fgnkey_strings_translation
	DEFINE srcline INTEGER
	DEFINE arrcurr INTEGER
	DEFINE bulk_update_status SMALLINT
	DEFINE nbr_edited_rows INTEGER
	DEFINE sql_action SMALLINT
	DEFINE i smallint

	BEGIN WORK
	WHILE TRUE
		CALL frm_input_array_srec_translation (p_fgnkey.*,p_where_clause) 
		RETURNING nbr_edited_rows,sql_action,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation,l_fky_array_strings_translation
		IF nbr_edited_rows > 0 THEN
			CASE 
				WHEN sql_action = 2
					CALL array_bulk_update_strings_translation (p_fgnkey,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation,l_fky_array_strings_translation)
					RETURNING bulk_update_status
					IF bulk_update_status > 0 THEN
							ROLLBACK WORK
						ERROR "frm_input_array_ failed"
					ELSE
						ERROR "frm_input_array_ Successful operation"
						COMMIT WORK
						EXIT WHILE
					END IF
				WHEN sql_action = 1
					# No
					ERROR "Please INPUT ARRAY AGAIN"
				WHEN sql_action = 0
					# Cancel
					MESSAGE "Cancelled, exit INPUT ARRAY"
					EXIT WHILE
			END CASE
		ELSE
			# Nothing
			MESSAGE "Nothing has been changed"
			EXIT WHILE
		END IF
	END WHILE

END FUNCTION # edit_array_srec_translation

####################################################################################################################
FUNCTION frm_input_array_srec_translation (p_fgnkey,p_where_clause)
## this function operates:
# 1) Fill the arrays based on the criteria input in CONSTRUCT
# 2)  INPUT ARRAY for the table strings_translation
# it handles 3 arrays:
# 1) the Input Data Array (scr_array_strings_translation) will contain the data input by the user
# 2) the primary key array (prykey__application_strings) contains the status for each element: 
#    NULL=>no data, 0=>elements not touched, 1=>element to INSERT, 2=>element to UPDATE, -1=>element to DELETE
#    and also contains the primary key values of each element
# 3) the action array that manages the 'todo' with each element
###################################################################################################################
	DEFINE p_fgnkey type_fgnkey_strings_translation
	DEFINE p_where_clause STRING
	DEFINE l_scr_array_strings_translation DYNAMIC ARRAY OF type_ArrElem_U807_strings_translation
	DEFINE l_pky_array_strings_translation DYNAMIC ARRAY OF type_prykey_strings_translation
	DEFINE l_act_array_strings_translation DYNAMIC ARRAY OF type_act_array_strings_translation
	DEFINE l_fky_array_strings_translation DYNAMIC ARRAY OF type_fgnkey_strings_translation
	DEFINE l_frm_rec_U807_strings_translation type_frm_rec_U807_strings_translation # Form parent image record 
	DEFINE elem_num INTEGER
	DEFINE arrcnt INTEGER
	DEFINE srcline INTEGER
	DEFINE arrcurr INTEGER
	DEFINE last_element INTEGER
	DEFINE lookup_status INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE nbr_edited_rows INTEGER
	DEFINE sql_action smallint
	DEFINE ins_key smallint
	DEFINE sav_scr_array_strings_translation type_ArrElem_U807_strings_translation # used to save the current element
	DEFINE sql_ok,record_found SMALLINT
	DEFINE l_translated_msg,l_empty_msg INTEGER
	DEFINE l_match util.match_results 	

	LET nbr_edited_rows = 0
	LET int_flag = FALSE
	LET ins_key = FALSE

	CASE 
		--IF p_where_clause IS NULL THEN
		WHEN p_fgnkey.* IS NOT NULL
			CALL sql_fill_child_array_from_fgnkey_strings_translation (p_fgnkey,"EDIT")   # build the query based on foreign key
			RETURNING sql_ok,elem_num,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation
		WHEN p_where_clause IS NOT NULL
			CALL sql_declare_cursor_qbe_child_strings_translation (p_where_clause,"EDIT")  # build and declare query based on qbe
			RETURNING sql_stmt_status 
			CALL sql_fill_child_array_from_qbe_strings_translation ("EDIT")  # build query based on qbe
			RETURNING elem_num,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation,l_fky_array_strings_translation
		WHEN p_fgnkey.* IS NULL AND p_where_clause IS NULL	# replay child query
			CALL sql_fill_child_array_from_qbe_strings_translation ("EDIT")  # build query based on qbe
			RETURNING elem_num,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation,l_fky_array_strings_translation
	END CASE
	DISPLAY elem_num TO total_messages
	INPUT ARRAY l_scr_array_strings_translation WITHOUT DEFAULTS
	FROM srec_translation.*
		BEFORE INPUT
			IF p_where_clause IS NOT NULL THEN		# when CONSTRUCT ON DETAIL, we forbid insert, append, delete
				CALL dialog.setActionHidden("INSERT",true)
				CALL dialog.setActionHidden("DELETE",true)
				CALL dialog.setActionHidden("APPEND",true)
			ELSE
				CALL dialog.setActionHidden("INSERT",false)
				CALL dialog.setActionHidden("DELETE",false)
				CALL dialog.setActionHidden("APPEND",false)
			END IF
			CALL count_translations(l_scr_array_strings_translation) RETURNING l_translated_msg
			LET l_empty_msg = elem_num - l_translated_msg
			DISPLAY l_translated_msg,l_empty_msg TO trsltd_messages,tobe_trsltd_messages

		ON ACTION "SHOW FORM"
			CALL show_form(l_frm_rec_U807_strings_translation.container)

		ON ACTION "CANCEL"
			# Cancel from input
			--LET int_flag=false
			LET arrcurr = arr_curr()
			LET srcline = scr_line ()
			LET l_scr_array_strings_translation[arrcurr].* = sav_scr_array_strings_translation.*
			DISPLAY l_scr_array_strings_translation[arrcurr].* TO srec_translation[srcline].*
			MESSAGE "Quit with quit key Control-C"
			EXIT INPUT

		BEFORE DELETE
			# save the element
			LET sav_scr_array_strings_translation.* = l_scr_array_strings_translation[arrcurr].*

		BEFORE INSERT
			# insert a row in l_pky_array_strings_translation and l_act_array_strings_translation
			LET arrcurr = arr_curr()
			LET srcline = scr_line ()
			CALL l_pky_array_strings_translation.insert(arrcurr)
			CALL l_act_array_strings_translation.insert(arrcurr)
			CALL dialog.SetFieldActive("language_code",true)
			INITIALIZE l_pky_array_strings_translation[arrcurr].* TO NULL
			LET l_act_array_strings_translation[arrcurr] = "+" 

		BEFORE ROW
			LET srcline = scr_line()
			LET arrcurr = arr_curr()
			# disable primary key input if not inserting or appending
			IF l_act_array_strings_translation[arrcurr] = "+" THEN
				CALL dialog.SetFieldActive("language",true)
				CALL dialog.SetFieldActive("country",true)
			ELSE
				CALL dialog.SetFieldActive("language",false)
				CALL dialog.SetFieldActive("country",false)
			END IF
			LET sav_scr_array_strings_translation.* = l_scr_array_strings_translation[arrcurr].*		# save the current row
			IF p_where_clause IS NOT NULL THEN
				# The parent may change at every element, so fetch and dispaly the parent
				# very special trick to catch the clause on program_name, because a string can belong to many containers that belong to many programs
				LET l_match = util.regex.search(p_where_clause,/(fgltarget\.program_name \w+ '[\w%]+')/) # 
				LET glob_fgltarget_clause = l_match.str(1)
				IF glob_fgltarget_clause IS NULL THEN
					LET glob_fgltarget_clause = "fgltarget.program_name LIKE '%'"
				END IF

				CALL sql_fetch_full_row_parent_UT6_strings_translate (l_fky_array_strings_translation[arrcurr].*)
				RETURNING record_found,l_frm_rec_U807_strings_translation.*
				IF 	l_frm_rec_U807_strings_translation.container MATCHES "*.fm2" THEN
					SHOW OPTION "SHOW FORM"
				ELSE
					HIDE OPTION "SHOW FORM"
				END IF

				CALL frm_display_parent_UT6_strings_translate(l_frm_rec_U807_strings_translation.*)
				LET glob_enu_msg = l_frm_rec_U807_strings_translation.string_contents
			END IF

		AFTER FIELD language_code
			IF l_scr_array_strings_translation[arrcurr].language_code IS NULL THEN # AND elem_num > 0 THEN
				NEXT FIELD language_code
			END IF
			LET l_pky_array_strings_translation[arrcurr].language_code =  l_scr_array_strings_translation[arrcurr].language_code

		AFTER FIELD country_code
			IF l_scr_array_strings_translation[arrcurr].country_code IS NULL THEN # AND elem_num > 0 THEN
				LET l_scr_array_strings_translation[arrcurr].country_code = "*"
				--NEXT FIELD country_code
				--DISPLAY l_scr_array_strings_translation[arrcurr].country_code TO 
			END IF
			IF sql_pky_exists_strings_translation(p_fgnkey.string_id,l_scr_array_strings_translation[arrcurr].language_code,l_scr_array_strings_translation[arrcurr].country_code) THEN # AND elem_num > 0 THEN
				ERROR "strings_translation: already exists"
				NEXT FIELD country_code
			END IF
			LET l_pky_array_strings_translation[arrcurr].country_code =  l_scr_array_strings_translation[arrcurr].country_code

		ON CHANGE translation
			LET l_scr_array_strings_translation[arrcurr].last_modification_ts = current YEAR TO SECOND
			DISPLAY l_scr_array_strings_translation[arrcurr].last_modification_ts TO srec_translation[srcline].last_modification_ts
			LET l_scr_array_strings_translation[srcline].text_length = length(l_scr_array_strings_translation[arrcurr].translation) - length(glob_enu_msg)
			DISPLAY l_scr_array_strings_translation[arrcurr].text_length TO srec_translation[srcline].text_length 
			IF l_translated_msg IS NOT NULL THEN
				LET l_translated_msg = l_translated_msg + 1
				LET l_empty_msg = elem_num - l_translated_msg
			END IF
			DISPLAY l_translated_msg,l_empty_msg TO trsltd_messages,tobe_trsltd_messages

		AFTER ROW
			IF field_touched (srec_translation[srcline].*) THEN
				LET nbr_edited_rows = nbr_edited_rows + 1
				IF l_act_array_strings_translation[arrcurr] = "=" THEN # existing row that has been modified
					LET l_act_array_strings_translation[arrcurr] = "#"	# to be modified
					IF l_pky_array_strings_translation[arrcurr].string_id IS NULL AND p_fgnkey.string_id IS NOT NULL THEN
						LET l_pky_array_strings_translation[arrcurr].string_id = p_fgnkey.string_id 
					END IF

				END IF
			END IF

		AFTER INSERT
			IF field_touched (srec_translation[srcline].*) THEN
				LET l_act_array_strings_translation[arrcurr] = "+"	# to be inserted
				LET l_pky_array_strings_translation[arrcurr].string_id = p_fgnkey.string_id 

			END IF

		AFTER DELETE 
			IF l_act_array_strings_translation[arrcurr] IS NOT NULL THEN
				#  General idea: the l_act_array_strings_translation current element is deleted by the DELETE action,
				# then the l_pky_array_strings_translation and l_act_array_strings_translation current elements are moved 
				# to the bottom of the array so that the element can be deleted without impacting the order of other elements
				# 1) proceed for l_pky_array_strings_translation
				CALL l_pky_array_strings_translation.AppendElement()   			# append one element at the end that will contain deleted element data
				LET last_element = l_pky_array_strings_translation.getsize()		# check the new array size
				LET l_pky_array_strings_translation[last_element].* = l_pky_array_strings_translation[arrcurr].*
				CALL l_pky_array_strings_translation.DeleteElement(arrcurr)	# finally delete the current element
				# 2) then same action for action array
				CALL l_act_array_strings_translation.AppendElement()
				LET l_act_array_strings_translation[last_element] = "-" 			  # to be Deleted
				CALL l_act_array_strings_translation.DeleteElement(arrcurr)
				LET nbr_edited_rows = nbr_edited_rows + 1
			END IF

		AFTER INPUT
			IF int_flag THEN
				LET int_flag = FALSE
				ERROR " Cancel strings_translation"
				LET nbr_edited_rows = 0
				LET sql_action = 0		# Input array cancelled
			ELSE
				--LET sql_action = confirm_operation(5,10,"frm_input_array_ ")
				LET sql_action = 2 
				--IF sql_action = 1 THEN
				--	CONTINUE INPUT
				--END IF
			END IF
	END INPUT
	RETURN nbr_edited_rows,sql_action,l_act_array_strings_translation,l_pky_array_strings_translation,l_scr_array_strings_translation,l_fky_array_strings_translation
END FUNCTION # frm_input_array_srec_translation

######################################################################################################
FUNCTION set_table_record_srec_translation_strings_translation(p_sql_stmt_type,p_fgnkey,p_prykey,p_element_contents)
# This function assigns the values from the array element(p_element_contents) to the table record (l_table_contents)
# It distinguishes the primary key (p_prykey) of the table strings_translationand the foreign key (p_fgnkey) point to the parent table (application_strings)
######################################################################################################
	DEFINE p_sql_stmt_type CHAR(1)			-- "+" => INSERT "#" => UPDATE
	DEFINE p_fgnkey type_fgnkey_strings_translation
	DEFINE p_prykey type_prykey_strings_translation
	DEFINE p_element_contents type_ArrElem_U807_strings_translation # One element of the Screen Record Array
	DEFINE fgl_status SMALLINT
	DEFINE l_table_contents type_FullRec_strings_translation

	INITIALIZE l_table_contents.* TO NULL
	CASE p_sql_stmt_type
	WHEN "+"		-- set table record to insert row
		LET l_table_contents.string_id = p_fgnkey.string_id
		LET l_table_contents.language_code = p_element_contents.language_code
		LET l_table_contents.country_code = p_element_contents.country_code
		LET l_table_contents.translation = p_element_contents.translation
		LET l_table_contents.last_modification_ts = p_element_contents.last_modification_ts

	WHEN "#"		-- set table record to update row
		LET l_table_contents.translation = p_element_contents.translation
		LET l_table_contents.last_modification_ts = p_element_contents.last_modification_ts

	END CASE

	CASE
        WHEN status = 0
            LET fgl_status = 1
        WHEN status < 0
            LET fgl_status = status
    	OTHERWISE
	    	LET fgl_status = status
	END CASE
	RETURN fgl_status,l_table_contents.*
END FUNCTION # set_table_record_srec_translation_strings_translation

#############################################################################################################
FUNCTION array_bulk_update_strings_translation (p_fgnkey,p_act_array_strings_translation,p_pky_array_strings_translation,p_scr_array_strings_translation,p_fky_array_strings_translation)
## This functions browses the action array p_act_array_strings_translation},
# copies the element values to table values (strings_translation)
# and executes the request SQL operation requested for each element
#############################################################################################################
	DEFINE p_fgnkey type_fgnkey_strings_translation
	DEFINE p_scr_array_strings_translation DYNAMIC ARRAY OF type_ArrElem_U807_strings_translation
	DEFINE p_pky_array_strings_translation DYNAMIC ARRAY OF type_prykey_strings_translation
	DEFINE p_act_array_strings_translation DYNAMIC ARRAY OF type_act_array_strings_translation
	DEFINE p_fky_array_strings_translation DYNAMIC ARRAY OF type_fgnkey_strings_translation
	DEFINE idx,arr_size,similar_msg_num INTEGER
	DEFINE updarr_status,fgl_status,global_status INTEGER
	DEFINE parent_fky type_fgnkey_strings_translation # foreign key pointing to parent table
	DEFINE elements_contents type_ArrElem_U807_strings_translation # One element of the Screen Record Array
	DEFINE l_strings_translation type_FullRec_strings_translation

	LET global_status = 0
	LET arr_size = p_pky_array_strings_translation.getsize()
	FOR idx = 1 TO arr_size
		CASE
            WHEN p_act_array_strings_translation[idx] = "="
                CONTINUE FOR
            WHEN p_act_array_strings_translation[idx] MATCHES "[+#]"		# Insert,delete or update
                CALL set_table_record_srec_translation_strings_translation (p_act_array_strings_translation[idx],p_fgnkey.*,p_pky_array_strings_translation[idx].*,p_scr_array_strings_translation[idx].*)
                RETURNING fgl_status,l_strings_translation.*
		END CASE
		IF p_fky_array_strings_translation.GetSize() > 0 THEN	# update coming from edit in Child QBE
			LET p_fgnkey.* = p_fky_array_strings_translation[idx].*
		END IF
		IF glob_rec_formonly.translate_similar_strings = TRUE THEN
			# get the original ENG string to global translation
			SELECT string_contents INTO glob_enu_msg
			FROM application_strings
			WHERE string_id = p_fgnkey.string_id
		END IF

		CALL sql_update_one_element_strings_translation(p_fgnkey.*,p_act_array_strings_translation[idx],p_pky_array_strings_translation[idx].*,l_strings_translation.*) 
		RETURNING updarr_status 
		IF updarr_status < 0 THEN
			ERROR "Error on element # ",idx
			LET global_status = global_status + 1
		END IF
		IF glob_rec_formonly.translate_similar_strings = TRUE THEN
			CALL sql_translate_similar_messages (glob_enu_msg,l_strings_translation.translation,p_pky_array_strings_translation[idx].language_code,p_pky_array_strings_translation[idx].country_code)
			RETURNING similar_msg_num
			DISPLAY similar_msg_num TO srec_translation[idx].identical_count
		END IF  

	END FOR
	CALL ui.interface.refresh() 
	RETURN global_status
END FUNCTION  # array_bulk_update_strings_translation

###############################################################################
FUNCTION sql_update_one_element_strings_translation (p_fgnkey,p_Action,p_prykey,p_rec_strings_translation)
## This function executes the SQL statement for each element
## accord the to status array value of this element
###############################################################################
	DEFINE p_fgnkey type_fgnkey_strings_translation
	DEFINE p_prykey type_prykey_strings_translation
	DEFINE p_Action CHAR(1)
	DEFINE p_rec_strings_translation type_FullRec_strings_translation
	DEFINE st SMALLINT
	DEFINE arrcnt SMALLINT
	DEFINE idx SMALLINT 
	DEFINE statut SMALLINT

	LET st = 0
		CASE p_Action
			WHEN "#"	# must be updated
				CALL sql_update_strings_translation(p_prykey.*,p_rec_strings_translation.*) RETURNING statut
		WHEN "+"	# must be inserted
				CALL sql_insert_strings_translation(p_rec_strings_translation.*) RETURNING statut
		WHEN "-"	# must be deleted
				CALL sql_delete_strings_translation(p_prykey.*) RETURNING statut
		END CASE
	return statut
END FUNCTION  # sql_update_one_element_strings_translation


FUNCTION sql_translate_similar_messages (l_enu_message,l_translation,l_language,l_country_code) 
	DEFINE l_enu_message,l_translation LIKE strings_translation.translation 
	DEFINE l_language LIKE strings_translation.language_code 
	DEFINE l_country_code LIKE strings_translation.country_code 
	LET l_translation = l_translation clipped 
	UPDATE strings_translation 
	SET (translation,last_modification_ts) = (l_translation,current) 
	WHERE strings_translation.string_id in ( SELECT string_id FROM application_strings WHERE string_contents = l_enu_message )
	AND language_code = l_language 
	AND country_code = l_country_code

	IF sqlca.sqlcode = 0 THEN 
		RETURN sqlca.sqlerrd[3] 
	ELSE 
		RETURN -1 
	END IF 
END FUNCTION # sql_translate_similar_messages

FUNCTION count_translations(p_array_strings_translation)
	DEFINE p_array_strings_translation DYNAMIC ARRAY OF type_ArrElem_U807_strings_translation
	DEFINE l_idx INTEGER
	DEFINE l_translated_msg INTEGER
	LET l_translated_msg = 0
	FOR l_idx = 1 TO p_array_strings_translation.GetSize()
		IF p_array_strings_translation[l_idx].translation IS NOT NULL THEN
			LET l_translated_msg = l_translated_msg + 1
		END IF
	END FOR
	RETURN l_translated_msg
END FUNCTION # count_translations

FUNCTION replay_child_query()

	CALL frm_input_array_srec_translation (NULL,NULL)

END FUNCTION # replay_child_query()