# module generated by Kandoo Ffg(c)
# Generated on 2019-11-05 19:55:27
# template I:\Users\BeGooden-IT\git\KandooERP\KandooERP\Resources\Utilities\Perl\Ffg/templates/module/child-form-basic.mtplt
############################################################
# GLOBAL Scope Variables
############################################################
GLOBALS "../common/glob_GLOBALS.4gl" 

# define type of primary key of child table
DEFINE t_pky_column_documentation TYPE AS RECORD 
	tabname LIKE column_documentation.tabname, # varchar(128) 
	colname LIKE column_documentation.colname, # varchar(128) 
	language_code LIKE column_documentation.language_code # char(3) 
END RECORD

# define type of foreign key to parent table
DEFINE t_fky_table_documentation TYPE AS RECORD 
	tabname LIKE column_documentation.tabname, # varchar(128) 
	language_code LIKE column_documentation.language_code # char(3) 
END RECORD

# define type of form array element
DEFINE t_elements_contents_column_documentation TYPE AS RECORD 
	colname LIKE column_documentation.colname, # varchar(128) 
	datatype VARCHAR(30), 
	col_documentation LIKE column_documentation.col_documentation, # nvarchar(255) 
	mtime LIKE column_documentation.mtime # DATETIME year TO second 
END RECORD

# define type of child table record
DEFINE t_tbl_column_documentation TYPE AS RECORD 
	tabname LIKE column_documentation.tabname, # varchar(128) 
	colname LIKE column_documentation.colname, # varchar(128) 
	language_code LIKE column_documentation.language_code, # char(3) 
	colno LIKE column_documentation.colno, # INTEGER 
	col_documentation LIKE column_documentation.col_documentation, # nvarchar(255) 
	mtime LIKE column_documentation.mtime # DATETIME year TO second 
END RECORD 

DEFINE pky_array_column_documentation DYNAMIC ARRAY OF t_pky_column_documentation
DEFINE scr_array_column_documentation DYNAMIC ARRAY OF t_elements_contents_column_documentation 
DEFINE act_array_column_documentation DYNAMIC ARRAY OF CHAR(1) 

DEFINE tbl_column_documentation t_tbl_column_documentation 

FUNCTION xxx_whenever_error()
		WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
END FUNCTION

FUNCTION sql_prepare_queries_z_table_documentation_mngr_column_documentation () 
	# this function initializes all cursors and prepared statements for the column_documentation and lookups


	DEFINE query_text STRING 
	# Prepare the cursor to display the column_documentation array
	# using foreign key pointing to table_documentation


	LET query_text = "SELECT '=',column_documentation.tabname,column_documentation.colname,column_documentation.language_code,", 
	"column_documentation.colname,", 
	"'datatype',", 
	"column_documentation.col_documentation,", 
	"column_documentation.mtime,", 
	"column_documentation.colno", 
	" FROM column_documentation ", 
	" WHERE column_documentation.tabname = ? ", 
	" AND column_documentation.language_code = ? ", #@g00034 
	" ORDER BY column_documentation.colno" 

	PREPARE pr_child_column_documentation FROM query_text 
	DECLARE crs_child_column_documentation CURSOR FOR pr_child_column_documentation 


	# PREPARE INSERT statement
	LET query_text = 
	"INSERT INTO column_documentation ( tabname,colname,language_code,colno,col_documentation,mtime 
	)", #@G00041 
	" VALUES ( ?,?,?,?,?,? )" #@g00042 
	PREPARE pr_ins_column_documentation FROM query_text 


	# PREPARE UPDATE statement
	LET query_text= 
	"UPDATE column_documentation ", 
	"SET ( col_documentation,mtime )", #@g00048 
	" = ( ?,? )", #@g00049 
	" WHERE tabname = ? 
	AND colname = ? 
	AND language_code = ? " #@G00052 
	PREPARE pr_upd_column_documentation FROM query_text 


	# PREPARE DELETE statement
	LET query_text= "DELETE FROM column_documentation ", 
	" WHERE tabname = ? 
	AND colname = ? 
	AND language_code = ? " #@G00059 
	PREPARE pr_del_column_documentation FROM query_text 

END FUNCTION 


FUNCTION sql_open_array_crs_scr_array_column_documentation(fky) 
	## This function opens the main cursor for the table column_documentation
	DEFINE lsql_ok INTEGER 
	DEFINE fky t_fky_table_documentation 

	WHENEVER SQLERROR CONTINUE 
	OPEN crs_child_column_documentation USING fky.* 

	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	CASE 
		WHEN sqlca.sqlcode = 100 
			LET lsql_ok = 0 
		WHEN sqlca.sqlcode < 0 
			LET lsql_ok = -1 
		OTHERWISE 
			LET lsql_ok = 1 
	END CASE 
	RETURN lsql_ok 
END FUNCTION 


FUNCTION sql_insert_column_documentation(lr_column_documentation) 
	## INSERT in table column_documentation
	DEFINE lr_column_documentation t_tbl_column_documentation 
	DEFINE lsql_stmt_status INTEGER 
	DEFINE lookup_status INTEGER 
	DEFINE nb_deleted_rows INTEGER 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_ins_column_documentation 
	USING lr_column_documentation.tabname, 
	lr_column_documentation.colname, 
	lr_column_documentation.language_code, 
	lr_column_documentation.colno, 
	lr_column_documentation.col_documentation, 
	lr_column_documentation.mtime 
	# 		                                                                                                                      	#@G00099
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 

	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status = 0 
		WHEN sqlca.sqlcode < 0 
			CALL display_error_and_decide("sql_Insert column_documentation:failed",sqlerrmessage,"") 
			LET lsql_stmt_status = -1 
	END CASE 
	RETURN lsql_stmt_status 
END FUNCTION 


FUNCTION sql_edit_column_documentation(pky,lr_column_documentation) 
	## sql_Edit_column_documentation :update current column_documentation record
	DEFINE lr_column_documentation t_tbl_column_documentation 
	DEFINE lsql_stmt_status INTEGER 
	DEFINE nb_modified_rows INTEGER 
	DEFINE pky t_pky_column_documentation 

	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_upd_column_documentation 
	USING lr_column_documentation.col_documentation, 
	lr_column_documentation.mtime,  
	pky.* 

	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status = 0 
			LET nb_modified_rows = sqlca.sqlerrd[3] 
		WHEN sqlca.sqlcode < 0 
			CALL display_error_and_decide("sql_Edit column_documentation:failed",sqlerrmessage,"") 
			LET lsql_stmt_status = -1 
			LET nb_modified_rows = 0 
	END CASE 
	RETURN lsql_stmt_status,nb_modified_rows 
END FUNCTION 


FUNCTION sql_delete_column_documentation(pky) 
	## delete_column_documentation :delete Selected row in table column_documentation
	DEFINE lsql_stmt_status SMALLINT 
	DEFINE nb_deleted_rows INTEGER 
	DEFINE pky t_pky_column_documentation 

	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_del_column_documentation USING pky.* 


	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status=0 
			LET nb_deleted_rows = sqlca.sqlerrd[3] 
		WHEN sqlca.sqlcode < 0 
			CALL display_error_and_decide("sql_Delete column_documentation:failed",sqlerrmessage,"")
			LET lsql_stmt_status = -1 
	END CASE 


	RETURN lsql_stmt_status,nb_deleted_rows 
END FUNCTION 


################################################################################
FUNCTION sql_status_pk_column_documentation(pky) 
	#"# This function Checks if primary key exists
	## inbound parameter : record of primary key
	## outbound parameter:  status > 0 if exists, 0 if no record, < 0 if error
	################################################################################
	DEFINE pky t_pky_column_documentation 
	DEFINE pk_status INTEGER 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_pky_crs_ USING pky.* 
	FETCH crs_pky_crs_ 
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 


	CASE sqlca.sqlcode 
		WHEN 0 
			LET pk_status = 1 
		WHEN 100 
			LET pk_status = 0 
		WHEN sqlca.sqlerrd[2] = 104 
			LET pk_status = -1 # RECORD locked 
		WHEN sqlca.sqlcode < 0 
			LET pk_status = sqlca.sqlcode 
	END CASE 
	RETURN pk_status 
END FUNCTION 


#@G00194


#######################################################################
FUNCTION initialize_array_column_documentation() 
	#######################################################################
	# initializes arrays
	CALL scr_array_column_documentation.clear() 
	CALL pky_array_column_documentation.clear() 
END FUNCTION 


######################################################################################################################################################
FUNCTION display_array_column_documentation (fky,browse) 
	# This function displays the array data (scr_array_column_documentation) based on the foreign key
	# browse: False means that the array is displayed without possibility of browsing inside (just show array and skip to next parent row)
	######################################################################################################################################################
	DEFINE elem_num,choice,xpos,ypos INTEGER 
	DEFINE arrcurr,srcline INTEGER 
	DEFINE sql_ok INTEGER 
	DEFINE qbe_stmt STRING 
	DEFINE browse boolean 
	DEFINE where_clause STRING 
	DEFINE fky t_fky_table_documentation 
	DEFINE sql_stmt_status INTEGER 


	IF browse = false THEN 
		# opening array cursor and fetch data only when reading the parent row
		LET sql_ok = sql_open_array_crs_scr_array_column_documentation(fky.*) 
		LET elem_num = 1 
		FOREACH crs_child_column_documentation INTO act_array_column_documentation[elem_num], 
			pky_array_column_documentation[elem_num].*, 
			scr_array_column_documentation[elem_num].* 
			LET scr_array_column_documentation[elem_num].datatype = get_datatype(fky.tabname,scr_array_column_documentation[elem_num].colname) 
			LET elem_num = elem_num + 1 
		END FOREACH 
		IF elem_num > 1 THEN 
			CALL scr_array_column_documentation.deleteelement(elem_num) 
		END IF 
	END IF 


	DISPLAY ARRAY scr_array_column_documentation 
	TO sr_columndoc.* 
		BEFORE DISPLAY 
			CALL DIALOG.SetActionHidden("ACCEPT", false) 
			--CALL DIALOG.SetActionHidden("DELETE", true)
			IF browse = false THEN 
				EXIT DISPLAY 
			END IF 
	END DISPLAY 


	RETURN elem_num-1 
END FUNCTION 


###########################################################################################################
FUNCTION frm_edit_array_column_documentation (p_rec_pky_table_documentation) 
	# This function calls the INPUT array function (frm_input_array_column_documentation) to edit the array data
	# then, accordingly, the SQL statement functions (array_bulk_update_)
	# it is generally called from another module
	###########################################################################################################
	DEFINE p_rec_pky_table_documentation t_fky_table_documentation 
	DEFINE srcline INTEGER 
	DEFINE arrcurr INTEGER 
	DEFINE bulk_update_status SMALLINT 
	DEFINE nbr_edited_rows INTEGER 
	DEFINE sql_action SMALLINT 
	DEFINE i SMALLINT 
	DEFINE fky t_fky_table_documentation 

	BEGIN WORK 
		#@G00261
		WHILE true 
			CALL frm_input_array_column_documentation (p_rec_pky_table_documentation.*) RETURNING nbr_edited_rows,sql_action #huho added NULL arg  
			#@G00262
			IF nbr_edited_rows > 0 THEN 
				CASE 
					WHEN sql_action = 2 
						LET bulk_update_status = array_bulk_update_column_documentation(p_rec_pky_table_documentation.*) 
						IF bulk_update_status > 0 THEN 
							ROLLBACK WORK 
							#@G00267
							ERROR "frm_input_array failed" 
						ELSE 
							ERROR "frm_input_array Successful operation" 
						COMMIT WORK 
						#@G00270
						EXIT WHILE 
					END IF 
					WHEN sql_action = 1 
						# No
						ERROR "Please INPUT ARRAY AGAIN" 
					WHEN sql_action = 0 
						# Cancel
						MESSAGE "Cancelled, exit INPUT ARRAY" 
						EXIT WHILE 
				END CASE 
			ELSE 
				# Nothing
				MESSAGE "Nothing has been changed" 
				EXIT WHILE 
			END IF 
		END WHILE 


END FUNCTION 


####################################################################################################################
FUNCTION frm_input_array_column_documentation (pky_table_documentation) 
	## this function operates INPUT ARRAY for the table column_documentation
	# it handles 2 arrays:
	# 1) the Input Data Array (scr_array_column_documentation) will contain the data input by the user
	# 2) the primary key array (pky_table_documentation) contains the status for each element:
	#    NULL=>no data, 0=>elements not touched, 1=>element to INSERT, 2=>element to UPDATE, -1=>element to DELETE
	#    and also contains the primary key values of each element
	###################################################################################################################
	DEFINE arrcnt INTEGER 
	DEFINE srcline INTEGER 
	DEFINE arrcurr INTEGER 
	DEFINE last_element INTEGER 
	DEFINE lookup_status INTEGER 
	DEFINE sql_stmt_status INTEGER 
	DEFINE nbr_edited_rows INTEGER 
	DEFINE sql_action SMALLINT 
	DEFINE ins_key SMALLINT 
	DEFINE pky_table_documentation t_fky_table_documentation 
 
	DEFINE sav_scr_array_column_documentation t_elements_contents_column_documentation 
	DEFINE sql_ok SMALLINT 
	LET nbr_edited_rows = 0 


	LET int_flag = false 
	LET ins_key = false 


	INPUT ARRAY scr_array_column_documentation WITHOUT DEFAULTS 
	FROM sr_columndoc.* 
	attribute(normal) 
		BEFORE INPUT 
			CALL DIALOG.SetActionHidden("INSERT", false) 
			CALL DIALOG.SetActionHidden("DELETE", true) 


		ON KEY (INTERRUPT) 
			# Cancel from input
			LET int_flag=false 
			LET arrcurr = arr_curr() 
			LET srcline = scr_line () 
			LET scr_array_column_documentation[arrcurr].* = sav_scr_array_column_documentation.* 
			DISPLAY scr_array_column_documentation[arrcurr].* TO sr_columndoc[srcline].* 
			MESSAGE "Quit with quit key Control-C" 
			ROLLBACK WORK 
			#@G00330
			EXIT INPUT 


		BEFORE INSERT 
			# insert a row in pky_array
			LET arrcurr = arr_curr() 
			LET srcline = scr_line () 
			CALL pky_array_column_documentation.insert(arrcurr) 
			INITIALIZE pky_array_column_documentation[arrcurr].* TO NULL 


		BEFORE ROW 
			LET srcline = scr_line() 
			LET arrcurr = arr_curr() 
			LET sav_scr_array_column_documentation.* = scr_array_column_documentation[arrcurr].* 

		AFTER DELETE 
			IF act_array_column_documentation[arrcurr] IS NOT NULL THEN 
				LET last_element = pky_array_column_documentation.getsize() 
				# The deleted element becomes the last element of status_array and flagged -1
				# The pky is also copied to the last element
				LET pky_array_column_documentation[last_element].* = pky_array_column_documentation[arrcurr].* 
				LET act_array_column_documentation[arrcurr] = "-" # TO be deleted 
				LET nbr_edited_rows = nbr_edited_rows + 1 
			END IF 


		AFTER ROW 
			IF field_touched (sr_columndoc[srcline].*) THEN 
				LET nbr_edited_rows = nbr_edited_rows + 1 
				CASE 
					WHEN act_array_column_documentation[arrcurr] = "=" # existing 
						LET act_array_column_documentation[arrcurr] = "#" # TO be modified 
						LET pky_array_column_documentation[arrcurr].colname = scr_array_column_documentation[arrcurr].colname 
						LET pky_array_column_documentation[arrcurr].language_code = pky_table_documentation.language_code 
						LET pky_array_column_documentation[arrcurr].tabname = pky_table_documentation.tabname 
						LET scr_array_column_documentation[arrcurr].mtime = CURRENT #util.datetime.getcurrentaslocal() 


					WHEN act_array_column_documentation[arrcurr] IS NULL # new 
						LET act_array_column_documentation[arrcurr] = "+" # TO be inserted 
						LET pky_array_column_documentation[arrcurr].colname = scr_array_column_documentation[arrcurr].colname 
						LET pky_array_column_documentation[arrcurr].language_code = pky_table_documentation.language_code 
						LET pky_array_column_documentation[arrcurr].tabname = pky_table_documentation.tabname 
						#@G00367
				END CASE 
				IF sql_status_pk_column_documentation(pky_array_column_documentation[arrcurr].colname,pky_array_column_documentation[arrcurr].language_code,pky_array_column_documentation[arrcurr].tabname) THEN 
					ERROR "column_documentation: already exists" 
					NEXT FIELD mtime 
				END IF 
				#@G00373
			END IF 


		AFTER INPUT 
			IF int_flag THEN 
				LET int_flag = false 
				ERROR " Cancel column_documentation" 
				LET nbr_edited_rows = 0 
				LET sql_action = 0 
			ELSE 
				LET sql_action = confirm_operation(5,10,"frm_input_array ") 
				IF sql_action = 1 THEN 
					CONTINUE INPUT 
				END IF 
			END IF 
	END INPUT 
	RETURN nbr_edited_rows,sql_action 
END FUNCTION 


######################################################################################################
FUNCTION set_form_record_f_dbschema_documentation_sr_columndoc(tbl_contents) 
	# This function assigns the values from the table sr_columndoc to the form record frm_contents
	######################################################################################################
	DEFINE fgl_status SMALLINT 
	DEFINE frm_contents t_elements_contents_column_documentation 
	DEFINE tbl_contents t_tbl_column_documentation 

	INITIALIZE frm_contents.* TO NULL 
	#	LET frm_contents.colno = tbl_column_documentation.colno
	LET frm_contents.colname = tbl_contents.colname 
	LET frm_contents.col_documentation = tbl_contents.col_documentation 
	LET frm_contents.mtime = tbl_contents.mtime 
	#@G00410
	CASE 
		WHEN status = 0 
			LET fgl_status = 1 
		WHEN status < 0 
			LET fgl_status = status 
		OTHERWISE 
			LET fgl_status = status 
	END CASE 
	RETURN fgl_status,frm_contents.* 
END FUNCTION 


######################################################################################################
FUNCTION set_table_record_f_dbschema_documentation_column_documentation(sql_stmt,fky,pky,element_contents) 
	# This function assigns the values from the array element(element_contents) to the table record (tbl_contents)
	# It distinguishes the primary key (pky) of the table column_documentationand the foreign key (fky) point to the parent table (table_documentation)
	######################################################################################################
	DEFINE sql_stmt CHAR(1) -- "+" => INSERT "#" => UPDATE 
	DEFINE fgl_status SMALLINT 
	DEFINE element_contents t_elements_contents_column_documentation 
	DEFINE fky t_fky_table_documentation 
	DEFINE pky t_pky_column_documentation 
 
	DEFINE tbl_contents t_tbl_column_documentation 

	#WHENEVER SQLERROR CONTINUE
	INITIALIZE tbl_contents.* TO NULL 
	CASE sql_stmt 
		WHEN "+" -- SET TABLE RECORD TO INSERT ROW 
			LET tbl_contents.tabname = pky.tabname 
			LET tbl_contents.colname = pky.colname 
			LET tbl_contents.language_code = pky.language_code 
			#		LET tbl_contents.colno = element_contents.colno
			LET tbl_contents.col_documentation = element_contents.col_documentation 
			LET tbl_contents.mtime = element_contents.mtime 
			#@G00452


		WHEN "#" -- SET TABLE RECORD TO UPDATE ROW 
			#		LET tbl_contents.colno = element_contents.colno
			LET tbl_contents.col_documentation = element_contents.col_documentation 
			LET tbl_contents.mtime = element_contents.mtime 
			#@G00458
	END CASE 


	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	CASE 
		WHEN status = 0 
			LET fgl_status = 1 
		WHEN status < 0 
			LET fgl_status = status 
		OTHERWISE 
			LET fgl_status = status 
	END CASE 
	RETURN fgl_status,tbl_contents.* 
END FUNCTION 


#############################################################################################################
FUNCTION array_bulk_update_column_documentation (p_rec_parent_fky) 
	## This functions browses the action array act_array_column_documentation},
	# copies the element values to table values (column_documentation)
	# and executes the request SQL operation requested for each element
	#############################################################################################################
	DEFINE p_rec_parent_fky t_fky_table_documentation 
	DEFINE idx,arr_size INTEGER 
	DEFINE updarr_status,fgl_status,global_status INTEGER 
	DEFINE elements_contents t_elements_contents_column_documentation 
	DEFINE l_column_documentation t_tbl_column_documentation 
 
	LET global_status = 0 
	LET arr_size = pky_array_column_documentation.getsize() 
	FOR idx = 1 TO arr_size 
		CASE 
			WHEN act_array_column_documentation[idx] = "=" 
				CONTINUE FOR 
			WHEN act_array_column_documentation[idx] matches "[+#]" # insert,delete OR UPDATE 
				CALL set_table_record_f_dbschema_documentation_column_documentation (act_array_column_documentation[idx],p_rec_parent_fky.*,pky_array_column_documentation[idx].*,scr_array_column_documentation[idx].*) 
				RETURNING fgl_status,l_column_documentation.* 
		END CASE 
		LET updarr_status = sql_update_one_element__column_documentation(idx,l_column_documentation.*) 
		IF updarr_status < 0 THEN 
			ERROR "Error on element # ",idx 
			LET global_status = global_status + 1 
		END IF 
	END FOR 
	RETURN global_status 
END FUNCTION 




###############################################################################
FUNCTION sql_update_one_element__column_documentation(idx,lr_column_documentation) 
	## This function executes the SQL statement for each element
	## accord the to status array value of this element
	###############################################################################
	DEFINE st SMALLINT 
	DEFINE arrcnt SMALLINT 
	DEFINE idx SMALLINT 
	DEFINE statut SMALLINT 
	DEFINE lr_column_documentation t_tbl_column_documentation 
 
	LET st = 0 
	CASE act_array_column_documentation[idx] 
		WHEN "#" # must be updated 
			LET statut = sql_edit_column_documentation(pky_array_column_documentation[idx].*,lr_column_documentation.*) 
		WHEN "+" # must be inserted 
			LET statut = sql_insert_column_documentation(lr_column_documentation.*) 
		WHEN "-" # must be deleted 
			LET statut = sql_delete_column_documentation(pky_array_column_documentation[idx].*) 
	END CASE 
	RETURN statut 
END FUNCTION 

# This function returns the column's data type
FUNCTION get_datatype(l_tabname,l_colname) #@g00534 
	DEFINE l_tabname LIKE systables.tabname 
	DEFINE l_colname LIKE syscolumns.colname 
	DEFINE l_datatype CHAR(30) 
	DEFINE l_coltype LIKE syscolumns.coltype 
	DEFINE l_collength LIKE syscolumns.collength 
	DEFINE l_precision INTEGER 
	DEFINE l_scale INTEGER 
	DEFINE l_errmessage STRING

	SELECT coltype,collength 
	INTO l_coltype,l_collength 
	FROM syscolumns c,systables t 
	WHERE t.tabid = c.tabid 
	AND t.tabname = l_tabname 
	AND c.colname = l_colname 

	IF sqlca.sqlcode = 100 THEN 
		LET l_errmessage = "Column ",l_colname, " not found in ", l_tabname
		RETURN l_errmessage
	END IF 
	LET l_scale = l_collength mod 256 
	LET l_precision = l_collength/256 

	CASE 
		WHEN l_coltype mod 256 = 10 
			CASE l_collength 
				WHEN 3851 
					LET l_datatype = "DATETIME YEAR TO FRACTION(1)" 
				WHEN 4108 
					LET l_datatype = "DATETIME YEAR TO FRACTION(2)" 
				WHEN 4365 
					LET l_datatype = "DATETIME YEAR TO FRACTION(3)" 
				WHEN 4622 
					LET l_datatype = "DATETIME YEAR TO FRACTION(4)" 
				WHEN 4879 
					LET l_datatype = "DATETIME YEAR TO FRACTION(5)" 
				WHEN 3594 
					LET l_datatype = "DATETIME YEAR TO SECOND" 
				WHEN 3080 
					LET l_datatype = "DATETIME YEAR TO MINUTE" 
				WHEN 2566 
					LET l_datatype = "DATETIME YEAR TO HOUR" 
				WHEN 2052 
					LET l_datatype = "DATETIME YEAR TO DAY" 
				WHEN 1538 
					LET l_datatype = "DATETIME YEAR TO MONTH" 
				WHEN 1024 
					LET l_datatype = "DATETIME YEAR TO YEAR" 
				WHEN 546 
					LET l_datatype = "MONTH TO MONTH" 
				WHEN 1060 
					LET l_datatype = "MONTH TO DAY" 
				WHEN 1574 
					LET l_datatype = "MONTH TO HOUR" 
				WHEN 2088 
					LET l_datatype = "MONTH TO MINUTE" 
				WHEN 2602 
					LET l_datatype = "MONTH TO SECOND" 
				WHEN 580 
					LET l_datatype = "DAY TO DAY" 
				WHEN 1094 
					LET l_datatype = "DAY TO HOUR" 
				WHEN 1608 
					LET l_datatype = "DAY TO MINUTE" 
				WHEN 2122 
					LET l_datatype = "DAY TO SECOND" 
			END CASE 
		WHEN l_coltype mod 256 = 11 
			LET l_datatype = "BYTE" 
		WHEN l_coltype mod 256 = 12 
			LET l_datatype = "TEXT" 
		WHEN l_coltype mod 256 = 13 
			LET l_datatype = "VARCHAR(",l_collength USING "###",",",l_precision USING "&##",")" 
		WHEN l_coltype mod 256 = 14 
			LET l_datatype = "INTERVAL" 
		WHEN l_coltype mod 256 = 15 
			LET l_datatype = "NCHAR(",l_collength USING "#####",")" 
		WHEN l_coltype mod 256 = 16 
			LET l_datatype = "NVARCHAR(",l_collength USING "#####",",",l_precision USING "&##",")" 
		WHEN l_coltype mod 256 = 40 
			LET l_datatype = "LVARCHAR(",l_collength USING "######",",",l_precision USING "&##",")" 
		WHEN l_coltype mod 256 = 17 
			LET l_datatype = "INT8" 
		WHEN l_coltype mod 256 = 18 
			LET l_datatype = "SERIAL8" 
		WHEN l_coltype mod 256 = 19 
			LET l_datatype = "SET" 
		WHEN l_coltype mod 256 = 20 
			LET l_datatype = "MULTISET" 
		WHEN l_coltype mod 256 = 21 
			LET l_datatype = "LIST" 
		WHEN l_coltype mod 256 = 22 
			LET l_datatype = "ROW" 
		WHEN l_coltype mod 256 = 23 
			LET l_datatype = "COLLECTION" 
		WHEN l_coltype mod 256 = 24 
			LET l_datatype = "ROWREF" 
		WHEN l_coltype mod 256 = 0 
			LET l_datatype = "CHAR(",l_collength USING "#####",")" 
		WHEN l_coltype mod 256 = 1 
			LET l_datatype = "SMALLINT" 
		WHEN l_coltype mod 256 = 2 
			LET l_datatype = "INTEGER" 
		WHEN l_coltype mod 256 = 3 
			LET l_datatype = "FLOAT" 
		WHEN l_coltype mod 256 = 4 
			LET l_datatype = "SMALLFLOAT" 
		WHEN l_coltype mod 256 = 5 
			LET l_datatype = "DECIMAL(",l_precision USING "##",",",l_scale USING "&",")" 
		WHEN l_coltype mod 256 = 6 
			LET l_datatype = "INTEGER" 
		WHEN l_coltype mod 256 = 7 
			LET l_datatype = "DATE" 
		WHEN l_coltype mod 256 = 8 
			LET l_datatype = "MONEY(",l_precision USING "##",",",l_scale USING "&",")" 
		OTHERWISE 
			LET l_datatype = "unknown",l_coltype,":",l_collength 
	END CASE 

	RETURN l_datatype 
END FUNCTION 
