# module generated by Kandoo Ffg(c)
# Generated on 2019-12-09 13:43:30
# template I:\Users\BeGooden-IT\git\KandooERP\KandooERP\Resources\Utilities\Perl\Ffg/templates/module/child-form-basic.mtplt
############################################################
# GLOBAL Scope Variables
############################################################
GLOBALS "../common/glob_GLOBALS.4gl" 
GLOBALS "../utility/UT1_GLOBALS.4gl"
GLOBALS 
	DEFINE glob_dbsname LIKE dbschema_properties.dbsname 
	DEFINE glob_rec_dbschema_properties RECORD LIKE dbschema_properties.* 
	DEFINE local_patch_home_directory STRING 
	DEFINE wrong_files_list,error_files_list DYNAMIC ARRAY OF STRING 
	DEFINE script_files_list DYNAMIC ARRAY OF STRING 
	DEFINE errors_directory STRING 
	DEFINE dbserver_name STRING
	DEFINE host_name CHAR(64) 
	DEFINE last_valid_backup DATETIME year TO second
	DEFINE log_handle base.channel
	DEFINE log_filename STRING
	DEFINE user_is_dba BOOLEAN
	DEFINE glb_prp_ins_dbschema_fix_log PREPARED
	DEFINE glb_prp_ins_dbschema_fix_errors PREPARED
END GLOBALS 

# Define types
# define type of primary key of child table
DEFINE t_pky_dbschema_fix TYPE AS RECORD 
	fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
	fix_dbsname LIKE dbschema_fix.fix_dbsname, # nchar(15)
	fix_id LIKE dbschema_fix.fix_id
END RECORD

# define type of foreign key to parent table
DEFINE t_fky_dbschema_properties TYPE AS RECORD 
	fix_dbsname LIKE dbschema_fix.fix_dbsname # nchar(15) 
END RECORD

# define type of form array element
DEFINE t_elements_contents_dbschema_fix TYPE AS RECORD
	fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
	fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
	fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
	fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
	fix_status LIKE dbschema_fix.fix_status, # nchar(2), 
	fix_dependencies LIKE dbschema_fix.fix_dependencies # nchar(255)
END RECORD

# defined type of child table record
DEFINE t_tbl_dbschema_fix TYPE AS RECORD 
	fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
	fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
	fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
	fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
	fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
	fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
	fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
	git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
	fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
	fix_status LIKE dbschema_fix.fix_status, # nchar(2)
	fix_dbsname LIKE dbschema_fix.fix_dbsname # nchar(42) 
END RECORD

#Define module variables
DEFINE pky_arraydbschema_fix DYNAMIC ARRAY OF t_pky_dbschema_fix 
#DEFINE fky t_fky_dbschema_properties
DEFINE act_arraydbschema_fix DYNAMIC ARRAY OF CHAR(1) 
DEFINE scr_arraydbschema_fix DYNAMIC ARRAY OF t_elements_contents_dbschema_fix 
DEFINE modu_session_start_ts DATETIME YEAR TO SECOND

# DEFINE cursors
DEFINE crs_dbschema_log_for_patch CURSOR

FUNCTION UT1_schema_fix_mngr_prn_whenever_sqlerror ()
    # this code instanciates the default sql errors handling for all the code lines below this function
    # it is a compiler preprocessor instruction. It is not necessary to execute that function
    WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
END FUNCTION

FUNCTION sql_prepare_queries_schema_fix_mngr_dbschema_fix () 
	# this function initializes all cursors and prepared statements for the dbschema_fix and lookups
	DEFINE query_text STRING 
	# Prepare the cursor to display the dbschema_fix array from the foreign key
	# using foreign key pointing to dbschema_properties

	LET query_text = "SELECT \"=\",", 
	"dbschema_fix.fix_name,dbschema_fix.fix_dbsname,dbschema_fix.fix_id, ", 
	"dbschema_fix.fix_name,", 
	"dbschema_fix.fix_abstract,", 
	"dbschema_fix.fix_tableslist,", 
	"dbschema_fix.fix_apply_date,", 
	"dbschema_fix.fix_status,", 
	"dbschema_fix.fix_dependencies",
	" FROM dbschema_fix, ", 
	"dbschema_properties ", 
	"WHERE dbschema_fix.fix_dbsname = dbschema_properties.dbsname ", #@g00033 
	" AND dbschema_fix.fix_dbsname = ? ", #@g00034 
	" ORDER BY dbschema_fix.fix_name DESC" #@g00035 
	PREPARE pr_child_fky_dbschema_fix FROM query_text 
	DECLARE crs_child_fky_dbschema_fix CURSOR FOR pr_child_fky_dbschema_fix
	IF sqlca.sqlcode < 0 THEN
		ERROR "The table dbschema_fix has been modified, please consult the Kandoo DBA Team or Technical Support"
	END IF  
	
	# PREPARE INSERT statement
	LET query_text = 
	"INSERT INTO dbschema_fix ( fix_name,fix_dbvendor,fix_abstract,fix_type,fix_dependencies,fix_tableslist,fix_create_date,git_commit_hash,fix_apply_date,fix_status,fix_dbsname,fix_id)", #@G00041 
	" VALUES ( ?,?,?,?,?,?,?,?,?,?,?,?)" #@G00042 
	PREPARE pr_ins_dbschema_fix FROM query_text 
	IF sqlca.sqlcode < 0 THEN
		ERROR "The table dbschema_fix has been modified, please consult the Kandoo DBA Team or Technical Support"
	END IF

	# PREPARE UPDATE statement
	LET query_text= 
	"UPDATE dbschema_fix ", 
	"SET ( fix_abstract,fix_type,fix_dependencies,fix_tableslist,fix_create_date,git_commit_hash,fix_apply_date,fix_status)", #@G00048 
	" = ( ?,?,?,?,?,?,?,?)", #@G00049 
	" WHERE fix_name = ? 
	AND fix_dbsname = ? " #@G00051 
	PREPARE pr_upd_dbschema_fix FROM query_text 
	IF sqlca.sqlcode < 0 THEN
		ERROR "The table dbschema_fix has been modified, please consult the Kandoo DBA Team or Technical Support"
	END IF

	# PREPARE DELETE statement
	LET query_text= "DELETE FROM dbschema_fix ", 
	" WHERE fix_name = ? 
	AND fix_dbsname = ? " #@G00057 
	PREPARE pr_del_dbschema_fix FROM query_text 
	IF sqlca.sqlcode < 0 THEN
		ERROR "The table dbschema_fix has been modified, please consult the Kandoo DBA Team or Technical Support"
	END IF
	
	CALL glb_prp_ins_dbschema_fix_log.Prepare("INSERT INTO dbschema_fix_log VALUES (?,?,?,?,?,?,?,?,?,?)")
	CALL glb_prp_ins_dbschema_fix_errors.Prepare("INSERT INTO dbschema_fix_errors VALUES (?,?,?,?)")
	
	
	-- Cursor for the array of one fix log
	LET query_text = "SELECT session_start_ts,stmt_apply_ts,user_code,stmt_status,error_code,isam_code,stmt_response_time,stmt_text,session_start_ts,fix_id,stmt_order ",
	"FROM dbschema_fix_log WHERE fix_id = ? ",
	"ORDER BY session_start_ts DESC,stmt_order "
	CALL crs_dbschema_log_for_patch.Declare(query_text)
	
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
END FUNCTION 


FUNCTION sql_open_array_crs_scr_arraydbschema_fix(fky) 
	## This function opens the main cursor for the table dbschema_fix


	DEFINE lsql_ok INTEGER 
	DEFINE fky t_fky_dbschema_properties 

	WHENEVER SQLERROR CONTINUE
	OPEN crs_child_fky_dbschema_fix USING fky.* 
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
	CASE 
		WHEN sqlca.sqlcode = 100 
			LET lsql_ok = 0 
		WHEN sqlca.sqlcode < 0 
			LET lsql_ok = -1 
		OTHERWISE 
			LET lsql_ok = 1 
	END CASE 
	RETURN lsql_ok 
END FUNCTION 


FUNCTION sql_insert_dbschema_fix(p_rec_dbschema_fix) 
	## INSERT in table dbschema_fix
	DEFINE p_rec_dbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status, # nchar(2) 
		fix_dbsname LIKE dbschema_fix.fix_dbsname # nchar(42)
		#@G00088
	END RECORD 


	DEFINE lsql_stmt_status INTEGER 
	DEFINE lookup_status INTEGER 
	DEFINE nb_deleted_rows INTEGER 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_ins_dbschema_fix 
	USING p_rec_dbschema_fix.fix_name, 
	p_rec_dbschema_fix.fix_dbvendor, 
	p_rec_dbschema_fix.fix_abstract, 
	p_rec_dbschema_fix.fix_type, 
	p_rec_dbschema_fix.fix_dependencies, 
	p_rec_dbschema_fix.fix_tableslist, 
	p_rec_dbschema_fix.fix_create_date, 
	p_rec_dbschema_fix.git_commit_hash, 
	p_rec_dbschema_fix.fix_apply_date, 
	p_rec_dbschema_fix.fix_status,
	glob_rec_dbschema_properties.dbsname,
	0 
	# 		                                                                                                                      	#@G00097
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 


	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status = 0 
		WHEN sqlca.sqlcode < 0 
			LET lsql_stmt_status = -1 
	END CASE 
	RETURN lsql_stmt_status 
END FUNCTION  # sql_insert_dbschema_fix


FUNCTION sql_edit_dbschema_fix(pky,lr_dbschema_fix) 
	## sql_Edit_dbschema_fix :update current dbschema_fix record
	DEFINE lr_dbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status, # nchar(2)
		fix_dbsname LIKE dbschema_fix.fix_dbsname # nchar(42)
	END RECORD 
	DEFINE lsql_stmt_status INTEGER 
	DEFINE nb_modified_rows INTEGER 
	DEFINE pky t_pky_dbschema_fix 

	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_upd_dbschema_fix 
	USING lr_dbschema_fix.fix_abstract, 
	lr_dbschema_fix.fix_type, 
	lr_dbschema_fix.fix_dependencies, 
	lr_dbschema_fix.fix_tableslist, 
	lr_dbschema_fix.fix_create_date, 
	lr_dbschema_fix.git_commit_hash, 
	lr_dbschema_fix.fix_apply_date, 
	lr_dbschema_fix.fix_status 
	, #@g00123 
	pky.fix_name,
	pky.fix_dbsname 


	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status = 0 
			LET nb_modified_rows = sqlca.sqlerrd[3] 
		WHEN sqlca.sqlcode < 0 
			LET lsql_stmt_status = -1 
			LET nb_modified_rows = 0 
	END CASE 
	RETURN lsql_stmt_status,nb_modified_rows 
END FUNCTION 


FUNCTION sql_delete_dbschema_fix(pky) 
	## delete_dbschema_fix :delete Selected row in table dbschema_fix
	DEFINE lsql_stmt_status SMALLINT 
	DEFINE nb_deleted_rows INTEGER 
	DEFINE pky t_pky_dbschema_fix 

	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_del_dbschema_fix USING pky.fix_name,pky.fix_dbsname 

	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status=0 
			LET nb_deleted_rows = sqlca.sqlerrd[3] 
		WHEN sqlca.sqlcode < 0 
			LET lsql_stmt_status = -1 
	END CASE 

	RETURN lsql_stmt_status,nb_deleted_rows 
END FUNCTION 	# sql_delete_dbschema_fix


################################################################################
FUNCTION sql_status_pk_dbschema_fix(pky) 
	#"# This function Checks if primary key exists
	## inbound parameter : record of primary key
	## outbound parameter:  status > 0 if exists, 0 if no record, < 0 if error
	################################################################################
	DEFINE pky t_pky_dbschema_fix 
	DEFINE pk_status INTEGER 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_pky_crs_ USING pky.fix_name,pky.fix_dbsname 
	FETCH crs_pky_crs_ 
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 


	CASE sqlca.sqlcode 
		WHEN 0 
			LET pk_status = 1 
		WHEN 100 
			LET pk_status = 0 
		WHEN sqlca.sqlerrd[2] = 104 
			LET pk_status = -1 # RECORD locked 
		WHEN sqlca.sqlcode < 0 
			LET pk_status = sqlca.sqlcode 
	END CASE 
	RETURN pk_status 
END FUNCTION 


#@G00192


#######################################################################
FUNCTION initialize_array_dbschema_fix() 
	#######################################################################
	# initializes arrays
	CALL scr_arraydbschema_fix.clear() 
	CALL pky_arraydbschema_fix.clear() 
END FUNCTION 


######################################################################################################################################################
FUNCTION display_array_from_fky_dbschema_fix (fky,open_foreach_cursor,exit_display) 
	# This function displays the array data (scr_arraydbschema_fix) based on the foreign key
	# browse: False means that the array is displayed without possibility of browsing inside (just show array and skip to next parent row)
	######################################################################################################################################################
	DEFINE elem_num,choice,xpos,ypos INTEGER 
	DEFINE arrcurr,srcline INTEGER 
	DEFINE sql_ok INTEGER 
	DEFINE qbe_stmt STRING 
	DEFINE open_foreach_cursor,exit_display boolean 
	DEFINE where_clause STRING 
	DEFINE status_message STRING
	DEFINE fky t_fky_dbschema_properties 
	DEFINE sql_stmt_status INTEGER 
	DEFINE array_size,successful_scripts,skipped_scripts,waiting_scripts,failed_scripts INTEGER
	DEFINE script_file,log_file STRING 
	DEFINE script_contents,log_contents STRING 
	DEFINE script,errors TEXT
	
	IF open_foreach_cursor= true THEN 
		CALL act_arraydbschema_fix.clear()
		CALL scr_arraydbschema_fix.clear()
		CALL pky_arraydbschema_fix.clear()
		# opening array cursor and fetch data only when reading the parent row
		LET sql_ok = sql_open_array_crs_scr_arraydbschema_fix(fky.*) 
		LET elem_num = 1 
		FOREACH crs_child_fky_dbschema_fix INTO act_arraydbschema_fix[elem_num] ,pky_arraydbschema_fix[elem_num].*,scr_arraydbschema_fix[elem_num].* 
			LET elem_num = elem_num + 1 
		END FOREACH 
		IF elem_num > 1 THEN 
			CALL scr_arraydbschema_fix.deleteelement(elem_num) 
		END IF 
	END IF 

	DISPLAY ARRAY scr_arraydbschema_fix 
	TO scr_dbschema_fix.* 
		BEFORE DISPLAY 
			IF user_is_dba = false THEN
				CALL dialog.setActionHidden("Force patch execution",true)
				CALL dialog.setActionHidden("Force Status to OK",true)
				CALL dialog.setActionHidden("Force Status to Ignore",true)
				CALL dialog.setActionHidden("DELETE patch",true)
			END IF

		BEFORE ROW 
			IF exit_display= TRUE THEN 
				EXIT DISPLAY 
			END IF 
			LET elem_num = arr_curr() 
			LET script_file = local_patch_home_directory,"/",scr_arraydbschema_fix[elem_num].fix_name clipped,".sql" 
			LET log_file = errors_directory,"/",scr_arraydbschema_fix[elem_num].fix_name clipped,".err" 
			CALL display_array_dbschema_fix_log(pky_arraydbschema_fix[elem_num].fix_id,true)

		ON ACTION ("doubleclick","View Script") 
			LOCATE script  IN FILE script_file
			DISPLAY script TO fileviewer
			FREE script

		ON ACTION ("View Errors") 
			IF os.path.exists(log_file) THEN 
				LOCATE errors  IN FILE log_file
				DISPLAY errors TO fileviewer 
				FREE errors
			ELSE 
				DISPLAY "This script executed correctly" 
			END IF

		ON ACTION ("Execute All those patches")
			# Execute this patch even if has already been executed or it is not yet in conditions to be executed (except dependency), ex skip over some patches and
			# ex skip over some patches and execute only this one
			CALL apply_db_patch (fky.fix_dbsname,"execute",".*") 
			RETURNING array_size,successful_scripts,skipped_scripts,waiting_scripts,failed_scripts
			LET status_message = "Total scripts executed ", array_size USING "###&",", Successful: ",successful_scripts USING "###&", 
			", Skipped: ",skipped_scripts USING "###&"," , Waiting for dependency: ",waiting_scripts USING "###&"," , Failed " ,failed_scripts USING "###&"

		ON ACTION ("Force Status to OK")
			LET scr_arraydbschema_fix[elem_num].fix_status = "OKS"
			UPDATE dbschema_fix
			SET fix_status = scr_arraydbschema_fix[elem_num].fix_status,
			fix_apply_date = current
			WHERE fix_name = pky_arraydbschema_fix[elem_num].fix_name
			CALL glb_prp_ins_dbschema_fix_log.Execute(modu_session_start_ts,pky_arraydbschema_fix[elem_num].fix_id,0,"Force patch status to OK",current,"OKS",0,0,glob_rec_kandoouser.sign_on_code,"0:00:00")
			
		ON ACTION ("Force Status to Ignore")
			# Will be be ignored, ie no more executed
			LET scr_arraydbschema_fix[elem_num].fix_status = "IGN"
			UPDATE dbschema_fix
			SET fix_status = scr_arraydbschema_fix[elem_num].fix_status,
			fix_apply_date = current
			WHERE fix_name = pky_arraydbschema_fix[elem_num].fix_name
			CALL glb_prp_ins_dbschema_fix_log.Execute(modu_session_start_ts,pky_arraydbschema_fix[elem_num].fix_id,0,"Force patch status to ignore",current,"IGN",0,0,glob_rec_kandoouser.sign_on_code,"0:00:00")

					
		ON ACTION ("DELETE patch")
			# Will be flagged as deleted, but not deleted
			LET scr_arraydbschema_fix[elem_num].fix_status = "DEL"
			UPDATE dbschema_fix
			SET fix_status = scr_arraydbschema_fix[elem_num].fix_status,
			fix_apply_date = current
			WHERE fix_name = pky_arraydbschema_fix[elem_num].fix_name
			CALL glb_prp_ins_dbschema_fix_log.Execute(modu_session_start_ts,pky_arraydbschema_fix[elem_num].fix_id,0,"Force patch status to DELETE",current,"DEL",0,0,glob_rec_kandoouser.sign_on_code,"0:00:00")

	END DISPLAY 

	RETURN elem_num-1 
END FUNCTION 		# display_array_from_fky_dbschema_fix


###########################################################################################################
FUNCTION frm_edit_array_dbschema_fix (pky_dbschema_properties) 
	# This function calls the INPUT array function (frm_input_array_dbschema_fix) to edit the array data
	# then, accordingly, the SQL statement functions (array_bulk_update_)
	# it is generally called from another module
	###########################################################################################################
	DEFINE srcline INTEGER 
	DEFINE arrcurr INTEGER 
	DEFINE bulk_update_status SMALLINT 
	DEFINE nbr_edited_rows INTEGER 
	DEFINE sql_action SMALLINT 
	DEFINE i SMALLINT 
	DEFINE fky t_fky_dbschema_properties 
	DEFINE pky_dbschema_properties t_pky_dbschema_fix 

	BEGIN WORK 
		#@G00259
		WHILE true 
			CALL frm_input_array_dbschema_fix (pky_dbschema_properties.*) RETURNING nbr_edited_rows,sql_action 
			#@G00260
			IF nbr_edited_rows > 0 THEN 
				CASE 
					WHEN sql_action = 2 
						LET bulk_update_status = array_bulk_update_dbschema_fix (pky_dbschema_properties) 
						IF bulk_update_status > 0 THEN 
							ROLLBACK WORK 
							#@G00265
							ERROR "frm_input_array failed" 
						ELSE 
							ERROR "frm_input_array Successful operation" 
						COMMIT WORK 
						#@G00268
						EXIT WHILE 
					END IF 
					WHEN sql_action = 1 
						# No
						ERROR "Please INPUT ARRAY AGAIN" 
					WHEN sql_action = 0 
						# Cancel
						MESSAGE "Cancelled, exit INPUT ARRAY" 
						EXIT WHILE 
				END CASE 
			ELSE 
				# Nothing
				MESSAGE "Nothing has been changed" 
				EXIT WHILE 
			END IF 
		END WHILE 


END FUNCTION 


####################################################################################################################
FUNCTION frm_input_array_dbschema_fix (pky_dbschema_properties) 
	## this function operates INPUT ARRAY for the table dbschema_fix
	# it handles 2 arrays:
	# 1) the Input Data Array (scr_arraydbschema_fix) will contain the data input by the user
	# 2) the primary key array (pky_dbschema_properties) contains the status for each element:
	#    NULL=>no data, 0=>elements not touched, 1=>element to INSERT, 2=>element to UPDATE, -1=>element to DELETE
	#    and also contains the primary key values of each element
	###################################################################################################################
	DEFINE arrcnt INTEGER 
	DEFINE srcline INTEGER 
	DEFINE arrcurr INTEGER 
	DEFINE last_element INTEGER 
	DEFINE lookup_status INTEGER 
	DEFINE sql_stmt_status INTEGER 
	DEFINE nbr_edited_rows INTEGER 
	DEFINE sql_action SMALLINT 
	DEFINE ins_key SMALLINT 
	DEFINE pky_dbschema_properties t_pky_dbschema_fix 
	DEFINE savscr_arraydbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00310
	END RECORD 
	DEFINE sql_ok SMALLINT 
	LET nbr_edited_rows = 0 


	LET int_flag = false 
	LET ins_key = false 


	INPUT ARRAY scr_arraydbschema_fix WITHOUT DEFAULTS 
	FROM scr_dbschema_fix.* 
	attribute(normal) 
		BEFORE INPUT 
			CALL DIALOG.SetActionHidden("APPLY", true) 
			CALL DIALOG.SetActionHidden("CANCEL", true) 
		
		ON KEY (INTERRUPT) 
			# Cancel from input
			LET int_flag=false 
			LET arrcurr = arr_curr() 
			LET srcline = scr_line () 
			LET scr_arraydbschema_fix[arrcurr].* = savscr_arraydbschema_fix.* 
			DISPLAY scr_arraydbschema_fix[arrcurr].* TO scr_dbschema_fix[srcline].* 
			MESSAGE "Quit with quit key Control-C" 
			ROLLBACK WORK 
			#@G00328
			EXIT INPUT 

		BEFORE INSERT 
			# insert a row in pky_array
			LET arrcurr = arr_curr() 
			LET srcline = scr_line () 
			CALL pky_arraydbschema_fix.insert(arrcurr) 
			INITIALIZE pky_arraydbschema_fix[arrcurr].* TO NULL 

		BEFORE ROW 
			LET srcline = scr_line() 
			LET arrcurr = arr_curr() 
			LET savscr_arraydbschema_fix.* = scr_arraydbschema_fix[arrcurr].* 

		AFTER DELETE 
			IF act_arraydbschema_fix[arrcurr] IS NOT NULL THEN 
				LET last_element = pky_arraydbschema_fix.getsize() 
				# The deleted element becomes the last element of status_array and flagged -1
				# The pky is also copied to the last element
				LET pky_arraydbschema_fix[last_element].* = pky_arraydbschema_fix[arrcurr].* 
				LET act_arraydbschema_fix[arrcurr] = "-" # TO be deleted 
				LET nbr_edited_rows = nbr_edited_rows + 1 
			END IF 

		AFTER ROW 
			IF field_touched (scr_dbschema_fix[srcline].*) THEN 
				LET nbr_edited_rows = nbr_edited_rows + 1 
				CASE 
					WHEN act_arraydbschema_fix[arrcurr] = "=" # existing 
						LET act_arraydbschema_fix[arrcurr] = "#" # TO be modified 
						LET pky_arraydbschema_fix[arrcurr].fix_name = scr_arraydbschema_fix[arrcurr].fix_name 
						LET pky_arraydbschema_fix[arrcurr].fix_dbsname = pky_dbschema_properties.fix_dbsname 
						#@G00361


					WHEN act_arraydbschema_fix[arrcurr] IS NULL # new 
						LET act_arraydbschema_fix[arrcurr] = "+" # TO be inserted 
						LET pky_arraydbschema_fix[arrcurr].fix_name = scr_arraydbschema_fix[arrcurr].fix_name 
						LET pky_arraydbschema_fix[arrcurr].fix_dbsname = pky_dbschema_properties.fix_dbsname 
						#@G00365
				END CASE 
				IF sql_status_pk_dbschema_fix(pky_arraydbschema_fix[arrcurr].*) THEN 
					ERROR "dbschema_fix: already exists" 
					NEXT FIELD last_patch_ko_scripts 
				END IF 
				#@G00371
			END IF 


		AFTER INPUT 
			IF int_flag THEN 
				LET int_flag = false 
				ERROR " Cancel dbschema_fix" 
				LET nbr_edited_rows = 0 
				LET sql_action = 0 
			ELSE 
				LET sql_action = confirm_operation(5,10,"frm_input_array ") 
				IF sql_action = 1 THEN 
					CONTINUE INPUT 
				END IF 
			END IF 
	END INPUT 
	RETURN nbr_edited_rows,sql_action 
END FUNCTION 


######################################################################################################
FUNCTION set_form_record_f_dbschema_status_scr_dbschema_fix(tbl_contents) 
	# This function assigns the values from the table scr_dbschema_fix to the form record frm_contents
	######################################################################################################
	DEFINE fgl_status SMALLINT 
	DEFINE frm_contents t_elements_contents_dbschema_fix 
	DEFINE tbl_contents t_tbl_dbschema_fix 


	INITIALIZE frm_contents.* TO NULL 
	LET frm_contents.fix_name = tbl_contents.fix_name 
	LET frm_contents.fix_abstract = tbl_contents.fix_abstract 
	LET frm_contents.fix_tableslist = tbl_contents.fix_tableslist 
	LET frm_contents.fix_apply_date = tbl_contents.fix_apply_date 
	LET frm_contents.fix_status = tbl_contents.fix_status 
	#@G00409
	CASE 
		WHEN status = 0 
			LET fgl_status = 1 
		WHEN status < 0 
			LET fgl_status = status 
		OTHERWISE 
			LET fgl_status = status 
	END CASE 
	RETURN fgl_status,frm_contents.* 
END FUNCTION 


######################################################################################################
FUNCTION set_table_record_f_dbschema_status_dbschema_fix(p_sql_stmt,p_rec_fky,p_rec_pky,p_rec_element_contents) 
	# This function assigns the values from the array element(p_rec_element_contents) to the table record (tbl_contents)
	# It distinguishes the primary key (p_rec_pky) of the table dbschema_fixand the foreign key (p_rec_fky) point to the parent table (dbschema_properties)
	######################################################################################################
	DEFINE p_sql_stmt CHAR(1) -- "+" => INSERT "#" => UPDATE 
	DEFINE fgl_status SMALLINT 
	DEFINE p_rec_element_contents t_elements_contents_dbschema_fix 
	DEFINE p_rec_fky t_fky_dbschema_properties 
	DEFINE p_rec_pky t_pky_dbschema_fix 
	DEFINE tbl_contents t_tbl_dbschema_fix 

	#WHENEVER SQLERROR CONTINUE
	INITIALIZE tbl_contents.* TO NULL 
	CASE p_sql_stmt 
		WHEN "+" -- SET TABLE RECORD TO INSERT ROW 
			LET tbl_contents.fix_name = p_rec_element_contents.fix_name 
			-- LET tbl_contents.fix_dbvendor = YOUR VALUE
			LET tbl_contents.fix_abstract = p_rec_element_contents.fix_abstract 
			-- LET tbl_contents.fix_type = YOUR VALUE
			-- LET tbl_contents.fix_dependencies = YOUR VALUE
			LET tbl_contents.fix_tableslist = p_rec_element_contents.fix_tableslist 
			-- LET tbl_contents.fix_create_date = YOUR VALUE
			-- LET tbl_contents.git_commit_hash = YOUR VALUE
			LET tbl_contents.fix_apply_date = p_rec_element_contents.fix_apply_date 
			LET tbl_contents.fix_status = p_rec_element_contents.fix_status 
			--LET tbl_contents.fix_dbsname = p_rec_element_contents.fix_status

		WHEN "#" -- SET TABLE RECORD TO UPDATE ROW 
			-- LET tbl_contents.fix_dbvendor = YOUR VALUE
			LET tbl_contents.fix_abstract = p_rec_element_contents.fix_abstract 
			-- LET tbl_contents.fix_type = YOUR VALUE
			-- LET tbl_contents.fix_dependencies = YOUR VALUE
			LET tbl_contents.fix_tableslist = p_rec_element_contents.fix_tableslist 
			-- LET tbl_contents.fix_create_date = YOUR VALUE
			-- LET tbl_contents.git_commit_hash = YOUR VALUE
			LET tbl_contents.fix_apply_date = p_rec_element_contents.fix_apply_date 
			#@G00466
	END CASE 


	#WHENEVER ERROR CALL kandoo_sql_errors_handler
	CASE 
		WHEN status = 0 
			LET fgl_status = 1 
		WHEN status < 0 
			LET fgl_status = status 
		OTHERWISE 
			LET fgl_status = status 
	END CASE 
	RETURN fgl_status,tbl_contents.* 
END FUNCTION 


#############################################################################################################
FUNCTION array_bulk_update_dbschema_fix (parent_fky) 
	## This functions browses the action array act_arraydbschema_fix},
	# copies the element values to table values (dbschema_fix)
	# and executes the request SQL operation requested for each element
	#############################################################################################################
	DEFINE idx,arr_size INTEGER 
	DEFINE updarr_status,fgl_status,global_status INTEGER 
	DEFINE parent_fky t_fky_dbschema_properties 
	DEFINE elements_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00493
	END RECORD 
	DEFINE l_dbschema_fix t_tbl_dbschema_fix 

	LET global_status = 0 
	LET arr_size = pky_arraydbschema_fix.getsize() 
	FOR idx = 1 TO arr_size 
		CASE 
			WHEN act_arraydbschema_fix[idx] = "=" 
				CONTINUE FOR 
			WHEN act_arraydbschema_fix[idx] matches "[+#]" # insert,delete OR UPDATE 
				CALL set_table_record_f_dbschema_status_dbschema_fix (act_arraydbschema_fix[idx],parent_fky.*,pky_arraydbschema_fix[idx].*,scr_arraydbschema_fix[idx].*) 
				RETURNING fgl_status,l_dbschema_fix.* 
		END CASE 
		LET updarr_status = sql_update_one_element__dbschema_fix(idx,l_dbschema_fix.*) 
		IF updarr_status < 0 THEN 
			ERROR "Error on element # ",idx 
			LET global_status = global_status + 1 
		END IF 
	END FOR 
	RETURN global_status 
END FUNCTION 




###############################################################################
FUNCTION sql_update_one_element__dbschema_fix(idx,lr_dbschema_fix) 
	## This function executes the SQL statement for each element
	## accord the to status array value of this element
	###############################################################################
	DEFINE st SMALLINT 
	DEFINE arrcnt SMALLINT 
	DEFINE idx SMALLINT 
	DEFINE statut SMALLINT 
	DEFINE lr_dbschema_fix t_tbl_dbschema_fix 

	LET st = 0 
	CASE act_arraydbschema_fix[idx] 
		WHEN "#" # must be updated 
			LET statut = sql_edit_dbschema_fix(pky_arraydbschema_fix[idx].*,lr_dbschema_fix.*) 
		WHEN "+" # must be inserted 
			LET statut = sql_insert_dbschema_fix(lr_dbschema_fix.*) 
		WHEN "-" # must be deleted 
			LET statut = sql_delete_dbschema_fix(pky_arraydbschema_fix[idx].*) 
	END CASE 
	RETURN statut 
END FUNCTION 

FUNCTION add_new_dbschema_fix_element(l_rec_dbschema_fix)
	DEFINE l_rec_dbschema_fix OF dt_rec_dbschema_fix 
--	RECORD 
--		fix_name LIKE dbschema_fix.fix_name, 
--		fix_abstract LIKE dbschema_fix.fix_abstract, 
--		fix_tableslist LIKE dbschema_fix.fix_tableslist, 
--		fix_apply_date LIKE dbschema_fix.fix_apply_date, 
--		fix_status LIKE dbschema_fix.fix_status 
--	END RECORD
	DEFINE i,arrsize smallint
	CALL scr_arraydbschema_fix.appendelement()
	LET arrsize = scr_arraydbschema_fix.getsize()
	--CALL scr_arraydbschema_fix.append(l_rec_dbschema_fix.fix_name,l_rec_dbschema_fix.fix_abstract, 
	--l_rec_dbschema_fix.fix_tableslist,l_rec_dbschema_fix.fix_apply_date,l_rec_dbschema_fix.fix_status)
	LET scr_arraydbschema_fix[arrsize].* = l_rec_dbschema_fix.*
	LET i=1 
END FUNCTION

FUNCTION frm_qbe_dbschema_fix() 
	## frm_qbe_dbschema_fix: Query By Example on table dbschema_fix
	## Input selection criteria,
	## prepare the query,
	## open the data set
	DEFINE rec_dbschema_fix,where_clause,temp_where_clause STRING 
	DEFINE connection_string STRING 
	DEFINE xnumber,sql_stmt_status INTEGER  
	DEFINE reply CHAR(5) 
	DEFINE match util.match_results 

	LET xnumber = 0 
	MESSAGE "Please input query criteria" 
	# initialize record and display blank
	CLEAR FORM 
	--INITIALIZE frmschema_fix_mngr.* TO NULL 
	-- DISPLAY BY NAME frmschema_fix_mngr.* 

	CONSTRUCT BY NAME where_clause 
	ON dbschema_fix.fix_name, 
	dbschema_fix.fix_abstract, 
	dbschema_fix.fix_tableslist,
	dbschema_fix.fix_apply_date,
	dbschema_fix.fix_status,
	dbschema_fix.fix_dependencies

 --	CALL sql_prepare_queries_schema_fix_mngr_dbschema_fix () # INITIALIZE all cursors ON master TABLE 
--	CALL sql_prepare_queries_schema_fix_mngr_dbschema_fix() 

			## Check whether criteria have been entered
		AFTER CONSTRUCT 
			IF NOT field_touched(dbschema_fix.*) AND NOT int_flag THEN 
				LET reply = fgl_winbutton("","Select all rows, are you sure?","Yes","Yes|No","question",0) 
				CASE 
					WHEN reply matches "Yes" 
						EXIT CONSTRUCT 
					OTHERWISE # saisie d'un critere de selection 
						ERROR "Please input a least one criteria" 
						CONTINUE CONSTRUCT 
				END CASE 
			END IF 
	END CONSTRUCT 

	IF int_flag = true THEN 
		MESSAGE "Quit with quit key" 
		LET int_flag=0 
	ELSE 
	END IF 
	RETURN where_clause 
END FUNCTION ## query_dbschema_fix 

FUNCTION sql_open_array_crs_qbe_arraydbschema_fix(where_clause)
DEFINE where_clause STRING
DEFINE query_text STRING


	# Prepare the cursor to display the dbschema_fix array from the qbe on child table 
	# using foreign key pointing to dbschema_properties
	LET query_text = "SELECT \"=\",", 
	"dbschema_fix.fix_name,dbschema_fix.fix_dbsname,dbschema_fix.fix_id, ",
	"dbschema_fix.fix_name,", 
	"dbschema_fix.fix_abstract,", 
	"dbschema_fix.fix_tableslist,", 
	"dbschema_fix.fix_apply_date,", 
	"dbschema_fix.fix_status,", 
	"dbschema_fix.fix_dependencies",
	" FROM dbschema_fix ",  
	"WHERE ",
	where_clause, 
	" ORDER BY fix_name DESC" #@g00035 
	PREPARE pr_child_qbe_dbschema_fix FROM query_text 
	DECLARE crs_child_qbe_dbschema_fix CURSOR FOR pr_child_qbe_dbschema_fix

END FUNCTION

FUNCTION display_array_from_qbe_dbschema_fix (where_clause,open_foreach_cursor,exit_display) 
	# This function displays the array data (scr_arraydbschema_fix) based on the foreign key
	# browse: False means that the array is displayed without possibility of browsing inside (just show array and skip to next parent row)
	######################################################################################################################################################
	DEFINE elem_num,choice,xpos,ypos INTEGER 
	DEFINE arrcurr,srcline INTEGER 
	DEFINE sql_ok INTEGER 
	DEFINE qbe_stmt STRING 
	DEFINE status_message STRING
	DEFINE open_foreach_cursor,exit_display boolean 
	DEFINE where_clause STRING 
	DEFINE fky t_fky_dbschema_properties 
	DEFINE sql_stmt_status,record_found INTEGER 
	DEFINE script_file,log_file STRING 
	DEFINE script_contents,log_contents STRING 
	DEFINE script,errors TEXT
	DEFINE array_size,successful_scripts,skipped_scripts,waiting_scripts,failed_scripts INTEGER
	DEFINE l_session_start_ts DATETIME YEAR TO SECOND
	LET l_session_start_ts = CURRENT
	IF open_foreach_cursor = true THEN 
		CALL act_arraydbschema_fix.clear()
		CALL scr_arraydbschema_fix.clear()
		CALL pky_arraydbschema_fix.Clear()
		# opening array cursor and fetch data only when reading the parent row 
		LET elem_num = 1 
		FOREACH crs_child_qbe_dbschema_fix INTO act_arraydbschema_fix[elem_num],pky_arraydbschema_fix[elem_num].*,scr_arraydbschema_fix[elem_num].* 
			LET elem_num = elem_num + 1 
		END FOREACH 
		IF elem_num > 0 THEN
			# delete last empy elements 
			CALL act_arraydbschema_fix.deleteelement(elem_num) 
			CALL scr_arraydbschema_fix.deleteelement(elem_num)
			CALL pky_arraydbschema_fix.deleteelement(elem_num)
		END IF 
	END IF 

	DISPLAY ARRAY scr_arraydbschema_fix 
	TO scr_dbschema_fix.* 
	ATTRIBUTE (unbuffered)
		BEFORE DISPLAY 
			IF user_is_dba = false THEN
				CALL dialog.setActionHidden("Force patch execution",true)
				CALL dialog.setActionHidden("Force Status to OK",true)
				CALL dialog.setActionHidden("Force Status to Ignore",true)
				CALL dialog.setActionHidden("DELETE patch",true)
			END IF
			
		BEFORE ROW 
			IF exit_display= TRUE THEN 
				EXIT DISPLAY 
			END IF
			LET elem_num = arr_curr() 
			# display matching parent record
			CALL fetch_and_display_dbschema_properties (pky_arraydbschema_fix[elem_num].fix_dbsname)
			# Display log for the current row
			CALL display_array_dbschema_fix_log(pky_arraydbschema_fix[elem_num].fix_id,true)
			
			IF exit_display= TRUE THEN 
				EXIT DISPLAY 
			END IF
 
			LET script_file = local_patch_home_directory,"/",scr_arraydbschema_fix[elem_num].fix_name clipped,".sql" 
			LET log_file = errors_directory,"/",scr_arraydbschema_fix[elem_num].fix_name clipped,".err" 

		ON ACTION ("View Script Log")
			CALL display_array_dbschema_fix_log(pky_arraydbschema_fix[elem_num].fix_id,false)
		
		{ON ACTION ("doubleclick","View Script") 
			LOCATE script  IN FILE script_file
			DISPLAY script TO fileviewer
			FREE script

		ON ACTION ("View Errors") 
			IF os.path.exists(log_file) THEN 
				LOCATE errors  IN FILE log_file
				DISPLAY errors TO fileviewer 
				FREE errors
			ELSE 
				DISPLAY "This script executed correctly" 
			END IF
 		}
		ON ACTION ("Force patch execution")
			# Execute this patch even if has already been executed or it is not yet in conditions to be executed (except dependency), ex skip over some patches and
			# ex skip over some patches and execute only this one
			CALL force_new_patch_execution(pky_arraydbschema_fix[elem_num].fix_name)
			RETURNING array_size,successful_scripts,skipped_scripts,waiting_scripts,failed_scripts
			LET status_message = "Total scripts executed ", array_size USING "###&",", Successful: ",successful_scripts USING "###&", 
			", Skipped: ",skipped_scripts USING "###&"," , Waiting for dependency: ",waiting_scripts USING "###&"," , Failed " ,failed_scripts USING "###&"

		ON ACTION ("Force Status to OK")
			LET scr_arraydbschema_fix[elem_num].fix_status = "OKS"
			UPDATE dbschema_fix
			SET fix_status = scr_arraydbschema_fix[elem_num].fix_status,
			fix_apply_date = current
			WHERE fix_name = pky_arraydbschema_fix[elem_num].fix_name
			CALL glb_prp_ins_dbschema_fix_log.Execute(l_session_start_ts,scr_arraydbschema_fix[elem_num].fix_name,1,"Reset Patch Status",current,"OKS",0,0,glob_rec_kandoouser.sign_on_code,"0:00:00")
			
		ON ACTION ("Force REDO Patch")
			LET scr_arraydbschema_fix[elem_num].fix_status = "KO"
			UPDATE dbschema_fix
			SET fix_status = scr_arraydbschema_fix[elem_num].fix_status,
			fix_apply_date = NULL
			WHERE fix_name = pky_arraydbschema_fix[elem_num].fix_name
			CALL glb_prp_ins_dbschema_fix_log.Execute(l_session_start_ts,scr_arraydbschema_fix[elem_num].fix_name,1,"Reset Patch Status",current,"KOS",-1,0,glob_rec_kandoouser.sign_on_code,"0:00:00")
		
		ON ACTION ("Force Status to Ignore")
			# Will be be ignored, ie no more executed
			LET scr_arraydbschema_fix[elem_num].fix_status = "IGN"
			UPDATE dbschema_fix
			SET fix_status = scr_arraydbschema_fix[elem_num].fix_status,
			fix_apply_date = current
			WHERE fix_name = pky_arraydbschema_fix[elem_num].fix_name
			CALL glb_prp_ins_dbschema_fix_log.Execute(l_session_start_ts,scr_arraydbschema_fix[elem_num].fix_name,1,"Reset Patch Status",current,"IGN",0,0,glob_rec_kandoouser.sign_on_code,"0:00:00")
					
		ON ACTION ("DELETE patch")
			# Will be flagged as deleted, but not deleted
			LET scr_arraydbschema_fix[elem_num].fix_status = "DEL"
			UPDATE dbschema_fix
			SET fix_status = scr_arraydbschema_fix[elem_num].fix_status,
			fix_apply_date = current
			WHERE fix_name = pky_arraydbschema_fix[elem_num].fix_name
			CALL glb_prp_ins_dbschema_fix_log.Execute(l_session_start_ts,scr_arraydbschema_fix[elem_num].fix_name,1,"Reset Patch Status",current,"DEL",0,0,glob_rec_kandoouser.sign_on_code,"0:00:00")

	END DISPLAY 

	RETURN elem_num-1 
END FUNCTION

FUNCTION diff_with_reference_database()
	DEFINE elem_num SMALLINT
	DEFINE query_stmt STRING
	DEFINE script,errors TEXT
	DEFINE script_file,log_file STRING
	DEFINE reference_database STRING
	DEFINE compared_database STRING
	DEFINE prp_current_db PREPARED
	DEFINE crs_current_db CURSOR
	
	LET reference_database = "kandoodb_reference@kandoo_ref_tcp"
	
	LET query_stmt = "SELECT DBINFO('dbname') FROM systables WHERE tabid = 1"
	CALL crs_current_db.declare(query_stmt)
	CALL crs_current_db.open()
	CALL crs_current_db.fetchNext()
	
	IF sqlca.sqlcode = 0 THEN
		CALL crs_current_db.SetResults(compared_database)
	ELSE
		ERROR "Houston, we have a problem"
	END IF
	
		
	# good opportunity to place a web service accessing to the kandoo_ref instance, but read only
	# Next step : does not work with Developer. Implement connect to ... select into temp 
	LET query_stmt = "SELECT * FROM ",reference_database,":dbschema_fix where fix_status in (\"OK\",\"OKF\",\"WAD\") INTO TEMP ref_dbschema_fix "
	EXECUTE IMMEDIATE query_stmt
	
	LET query_stmt = "SELECT * FROM ",reference_database,":dbschema_properties INTO TEMP ref_dbschema_properties "
	EXECUTE IMMEDIATE query_stmt
	
	LET query_stmt = "SELECT \"=\",r.fix_name,",
	"r.fix_dbsname,",  
	"r.fix_name,",
	"r.fix_abstract,", 
	"r.fix_tableslist,", 
	"r.fix_apply_date,", 
	"r.fix_status,",
	"r.fix_dependencies ",
	"FROM ref_dbschema_fix r ",
	"WHERE r.fix_name not in ( SELECT fix_name FROM dbschema_fix ) ",
	"and r.fix_create_date >= ",
	"( SELECT max(snapshot_date) ",
	"FROM ( ",
	"SELECT snapshot_date FROM ref_dbschema_properties ",
	"UNION ALL SELECT snapshot_date FROM dbschema_properties) ",
	") ",
	"ORDER BY r.fix_name"
	PREPARE p_diff_reference FROM query_stmt
	DECLARE crs_diff_reference CURSOR FOR p_diff_reference
	
	CALL act_arraydbschema_fix.clear()
	CALL scr_arraydbschema_fix.clear()
	# opening array cursor and fetch data only when reading the parent row 

	LET elem_num = 1 
	FOREACH crs_diff_reference 
	INTO act_arraydbschema_fix[elem_num] ,pky_arraydbschema_fix[elem_num].*,scr_arraydbschema_fix[elem_num].* 
		LET elem_num = elem_num + 1 
	END FOREACH 
	IF elem_num = 1 THEN
		ERROR "This database is up to date"
	ELSE
		MESSAGE "Number of patches not found in ",compared_database,": ",elem_num-1
	END IF
	CALL scr_arraydbschema_fix.deleteElement(elem_num)
	CALL act_arraydbschema_fix.deleteElement(elem_num)
	
	DISPLAY ARRAY scr_arraydbschema_fix 
	TO scr_dbschema_fix.* 
	ATTRIBUTE (unbuffered)
		BEFORE DISPLAY 
			IF scr_arraydbschema_fix.GetSize() > 0 THEN
				ERROR "The following scripts are missing in your database"
			ELSE
				MESSAGE "You database seems to be in sync with the reference database"
			END IF
		BEFORE ROW 
			LET elem_num = arr_curr()
			LET script_file = local_patch_home_directory,"/",scr_arraydbschema_fix[elem_num].fix_name clipped,".sql" 
			LET log_file = errors_directory,"/",scr_arraydbschema_fix[elem_num].fix_name clipped,".err" 
			CALL display_array_dbschema_fix_log(pky_arraydbschema_fix[elem_num].fix_id,true)

		ON ACTION ("doubleclick","View Script")
			IF elem_num > 0 THEN 
				LOCATE script  IN FILE script_file
				DISPLAY script TO fileviewer
				FREE script
			END IF

		ON ACTION ("View Errors")
			IF elem_num > 0 THEN 
				IF os.path.exists(log_file) THEN 
					LOCATE errors  IN FILE log_file
					DISPLAY errors TO fileviewer 
					FREE errors
				ELSE 
					DISPLAY "This script executed correctly" 
				END IF
			END IF
	END DISPLAY
	DROP TABLE ref_dbschema_fix
	DROP TABLE ref_dbschema_properties
END FUNCTION

FUNCTION display_array_dbschema_fix_log(p_fix_id,p_exit_display)
# This function displays the log history for one patch
	DEFINE p_fix_id LIKE dbschema_fix_log.fix_id
	DEFINE arr_curr SMALLINT
	DEFINE elem_num SMALLINT
	DEFINE p_exit_display BOOLEAN
	--DEFINE l_error_msg LIKE dbschema_fix_errors.error_msg
	DEFINE l_error_msg CHAR(1024)
	DEFINE scr_array_dbschema_fix_log DYNAMIC ARRAY OF RECORD
		session_start_ts LIKE dbschema_fix_log.session_start_ts ,
		stmt_apply_ts LIKE dbschema_fix_log.stmt_apply_ts,
		user_code LIKE dbschema_fix_log.user_code,
		stmt_status LIKE dbschema_fix_log.stmt_status,
		error_code LIKE dbschema_fix_log.error_code,
		isam_code LIKE dbschema_fix_log.isam_code,
		stmt_response_time LIKE dbschema_fix_log.stmt_response_time,
		stmt_text LIKE dbschema_fix_log.stmt_text
	END RECORD
	DEFINE pky_array_dbschema_fix_log DYNAMIC ARRAY OF RECORD
		session_start_ts LIKE dbschema_fix_log.session_start_ts ,
		fix_id LIKE dbschema_fix_log.fix_id,
		stmt_order LIKE dbschema_fix_log.stmt_order
	END RECORD
	
	CALL crs_dbschema_log_for_patch.OPEN (p_fix_id)
	--CALL crs_dbschema_log_for_patch.FETCHALL (scr_array_dbschema_fix_log,pky_array_dbschema_fix_log)
	LET elem_num = 1
	
	WHILE sqlca.sqlcode = 0
		CALL crs_dbschema_log_for_patch.SetResults(scr_array_dbschema_fix_log[elem_num].*,pky_array_dbschema_fix_log[elem_num].*)
		CALL crs_dbschema_log_for_patch.FetchNext()  
		LET elem_num = elem_num + 1
	END WHILE
		
	
	DISPLAY ARRAY scr_array_dbschema_fix_log TO scr_dbschema_fix_log.*
		BEFORE DISPLAY
			IF p_exit_display = true THEN
				EXIT DISPLAY
			END IF
		BEFORE ROW
			LET arr_curr = arr_curr()
			
			IF  scr_array_dbschema_fix_log[arr_curr].error_code < 0 THEN
				SELECT error_msg INTO l_error_msg
				FROM dbschema_fix_errors
				WHERE session_start_ts = pky_array_dbschema_fix_log[arr_curr].session_start_ts
				AND fix_id = pky_array_dbschema_fix_log[arr_curr].fix_id
				AND stmt_order = pky_array_dbschema_fix_log[arr_curr].stmt_order
				
				IF sqlca.sqlcode = 0 THEN
					DISPLAY l_error_msg
					TO fileviewer
				ELSE
					DISPLAY "The script ran successfully"
					TO fileviewer
				END IF
			END IF
	END DISPLAY
	
END FUNCTION
