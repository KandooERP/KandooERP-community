############################################################
# GLOBAL Scope Variables
############################################################
GLOBALS "../common/glob_GLOBALS.4gl" 


# module generated by kandooERP Ffg(c)
# Generated on 2019-08-25 13:25:15
# Main template I:\Users\BeGooden-IT\git\KandooERP\KandooERP\Resources\Utilities\Perl\Ffg/templates/module/standalone-form-kandoo.mtplt
GLOBALS 
	DEFINE cmpy LIKE company.cmpy_code 
	DEFINE whom CHAR(32) 
END GLOBALS 

############################################################
# MODULE Scope Variables
############################################################
#@G00010
DEFINE modu_program CHAR(30) 


#@G00014
DEFINE modu__rec_dbschema_fix RECORD LIKE dbschema_fix.* 


MAIN 
	#Initial UI Init
	CALL setModuleId("UT6") 
	CALL ui_init(0) #initial ui init 

	DEFER quit 
	DEFER interrupt 

	CALL authenticate(getmoduleid()) #authenticate 
	CALL init_u_ut() #init utility module 


	#@G00019
	# WHENEVER ERROR CALL error_mngmt
	LET modu_program="p_z_dbschema_status_dbschema_fix" 


	CALL main_z_dbschema_status_dbschema_fix() 


END MAIN 


##########################################################################
FUNCTION mc_z_dbschema_status_sccs() 
	## definition variable sccs
	DEFINE sccs_var CHAR(70) 
	LET sccs_var="%W% %D%" 
END FUNCTION 
##########################################################################
FUNCTION main_z_dbschema_status_dbschema_fix () 
	## this module's main function called by MAIN
	DEFINE r_dbschema_properties RECORD LIKE dbschema_properties.* 
	DEFER quit 
	DEFER interrupt 


	#CALL setModuleId("f_dbschema_status")
	#CALL ui_init(0)
	#CALL authenticate(getModuleId()) RETURNING cmpy, whom


	OPEN WINDOW f_dbschema_status with FORM "U801_dbschema_status" 
	#	CALL winDecoration_u("f_dbschema_status")
	#CALL displaymoduletitle(NULL)  --first form of the module get's the title

	SELECT * INTO r_dbschema_properties.* 
	FROM dbschema_properties 

	DISPLAY BY NAME r_dbschema_properties.* 

	CALL sql_prepare_queries_z_dbschema_status_dbschema_fix () # INITIALIZE all cursors ON master TABLE 


	CALL menu_z_dbschema_status_dbschema_fix() 


	CLOSE WINDOW f_dbschema_status 


END FUNCTION 


######################################################################
FUNCTION menu_z_dbschema_status_dbschema_fix () 
	## menu_z_dbschema_status_dbschema_fix
	## the top level menu
	## input arguments: none
	## output arguments: none
	DEFINE nbsel_dbschema_fix INTEGER 
	DEFINE sql_stmt_status INTEGER 
	DEFINE record_num INTEGER 
	DEFINE ACTION SMALLINT 
	DEFINE xnumber SMALLINT 
	DEFINE arr_elem_num SMALLINT 
	DEFINE pky_dbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00068
	END RECORD 
	DEFINE l_rec_frm_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00071
	END RECORD 


	DEFINE tbl_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00075
	END RECORD 


	DEFINE record_found INTEGER 
	DEFINE lookup_status INTEGER 


	LET nbsel_dbschema_fix = 0 
	MENU "dbschema_fix" 
		BEFORE MENU 
			HIDE option "Next","Previous","EDIT","DELETE" 
		COMMAND "Query" "Query data with multiple criteria dbschema_fix" 
			#@G00085
			MESSAGE "" 
			INITIALIZE l_rec_frm_z_dbschema_status.* TO NULL 
			#CLEAR dbschema_properties.*
			DISPLAY BY NAME l_rec_frm_z_dbschema_status.* 
			HIDE option "Next","Previous" 


			CALL frm_query_z_dbschema_status() RETURNING nbsel_dbschema_fix 
			IF nbsel_dbschema_fix > 0 THEN 
				CALL sql_nxtprev_dbschema_fix(1) RETURNING record_found, 
				pky_dbschema_fix.* 


				CASE 
					WHEN record_found = 1 
						LET record_num = 1 
						CALL sql_fetch_full_row_dbschema_fix (pky_dbschema_fix.*) 
						RETURNING record_found,l_rec_frm_z_dbschema_status.* 
						CALL frm_display_z_dbschema_status(l_rec_frm_z_dbschema_status.*) 
					WHEN record_found = -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
				END CASE 
				IF nbsel_dbschema_fix > 1 THEN 
					SHOW option "Next" 
					NEXT option "Next" 
				END IF 
				SHOW option "EDIT","DELETE" 


			ELSE 
				ERROR "No row matches the criteria" 
				NEXT option "Query" 
			END IF 


		COMMAND "Next" "Display Next record dbschema_fix" 
			#@G00117
			MESSAGE "" 
			#CLEAR FORM
			INITIALIZE l_rec_frm_z_dbschema_status.* TO NULL 


			IF record_num <= nbsel_dbschema_fix THEN 
				CALL sql_nxtprev_dbschema_fix(1) RETURNING record_found, 
				pky_dbschema_fix.* 


				CASE 
					WHEN record_found = 0 
						ERROR "FETCH Last record of this selection dbschema_fix" 
					WHEN record_found = -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
					WHEN record_found = 1 
						LET record_num = record_num + 1 
						CALL sql_fetch_full_row_dbschema_fix (pky_dbschema_fix.*) 
						RETURNING record_found,l_rec_frm_z_dbschema_status.* 


						CALL frm_display_z_dbschema_status(l_rec_frm_z_dbschema_status.*) 


						IF record_num >= nbsel_dbschema_fix THEN 
							HIDE option "Next" 
						END IF 
						IF record_num > 1 THEN 
							SHOW option "Previous" 
						ELSE 
							HIDE option "Previous" 
						END IF 


				END CASE 
			ELSE 
				ERROR " Please set query criteria previously dbschema_fix " 
				NEXT option "Query" 
			END IF 


		COMMAND "Previous" "Display Previous Record dbschema_fix" 
			#@G00153


			MESSAGE "" 
			#CLEAR FORM
			INITIALIZE l_rec_frm_z_dbschema_status.* TO NULL 


			IF record_num >= 1 THEN 
				CALL sql_nxtprev_dbschema_fix(-1) RETURNING record_found, 
				pky_dbschema_fix.* 


				CASE 
					WHEN record_found = 0 
						ERROR "FETCH First record of this selection dbschema_fix" 
					WHEN record_found < -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
					WHEN record_found = 1 
						LET record_num = record_num - 1 
						CALL sql_fetch_full_row_dbschema_fix (pky_dbschema_fix.*) 
						RETURNING record_found,l_rec_frm_z_dbschema_status.* 
						CALL frm_display_z_dbschema_status(l_rec_frm_z_dbschema_status.*) 
						IF record_num = 1 THEN 
							HIDE option "Previous" 
						END IF 
						IF record_num < nbsel_dbschema_fix THEN 
							SHOW option "Next" 
						ELSE 
							HIDE option "Next" 
						END IF 


				END CASE 
			ELSE 
				ERROR " Please set query criteria previously dbschema_fix " 
				NEXT option "Query" 
			END IF 


		COMMAND "INSERT" "Add a new record dbschema_fix" 
			#@G00188
			MESSAGE "" 
			CALL frm_insert_z_dbschema_status() RETURNING sql_stmt_status,pky_dbschema_fix.* 
			MESSAGE "" 


		COMMAND "EDIT" "Modify current record dbschema_fix" 
			#@G00193
			MESSAGE "" 
			IF nbsel_dbschema_fix THEN 
				IF sql_status_pk_dbschema_fix(pky_dbschema_fix.*) < 0 THEN 
					ERROR "is locked " 
					NEXT option "Next" 
				ELSE 
					CALL frm_edit_z_dbschema_status(pky_dbschema_fix.*,l_rec_frm_z_dbschema_status.*) 
					RETURNING sql_stmt_status 
				END IF 
			ELSE 
				ERROR " Please set query criteria previously dbschema_fix " 
				NEXT option "Query" 
			END IF 


		COMMAND "DELETE" "Suppress current record dbschema_fix" 
			#@G00208
			MESSAGE "" 
			IF nbsel_dbschema_fix THEN 
				IF sql_status_pk_dbschema_fix(pky_dbschema_fix.*) < 0 THEN 
					ERROR "is locked " 
					NEXT option "Next" 
				END IF 
				WHILE true 
					CALL confirm_operation(5,10,"Delete") RETURNING ACTION 
					CASE 
						WHEN ACTION = 0 OR ACTION = 1 
							EXIT WHILE # degage abandon 
						WHEN ACTION = 2 
							CALL frm_delete_z_dbschema_status(pky_dbschema_fix.*) 
							RETURNING sql_stmt_status 
							EXIT WHILE 
					END CASE 
				END WHILE 
			ELSE 
				ERROR "Please set query criteria previously dbschema_fix " 
				NEXT option "Query" 
			END IF 


		COMMAND "Exit" "Exit program" 
			#@G00231
			MESSAGE "" 
			EXIT MENU 
	END MENU 
END FUNCTION 


#######################################################################
FUNCTION frm_query_z_dbschema_status() 
	## frm_Query_z_dbschema_status_f_dbschema_status : Query By Example on table dbschema_fix
	## Input selection criteria,
	## prepare the query,
	## OPEN the data set
	DEFINE rec_dbschema_fix,where_clause STRING 
	DEFINE xnumber,sql_stmt_status INTEGER 
	DEFINE l_pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00246
	END RECORD 
	DEFINE l_rec_frm_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00249
	END RECORD 


	DEFINE reply CHAR(5) 
	LET xnumber = 0 
	MESSAGE "Please input query criteria" 
	# initialize record and display blank
	#CLEAR FORM
	INITIALIZE l_rec_frm_z_dbschema_status.* TO NULL 
	DISPLAY BY NAME l_rec_frm_z_dbschema_status.* 


	CONSTRUCT BY NAME where_clause ON dbschema_fix.fix_name, 
	dbschema_fix.fix_dbvendor, 
	dbschema_fix.fix_abstract, 
	dbschema_fix.fix_type, 
	dbschema_fix.fix_dependencies, 
	dbschema_fix.fix_tableslist, 
	dbschema_fix.fix_create_date, 
	dbschema_fix.git_commit_hash, 
	dbschema_fix.fix_apply_date, 
	dbschema_fix.fix_status 

	#@G00260


	#@G00261


	## Check whether criteria have been entered
		AFTER CONSTRUCT 
			IF NOT field_touched(dbschema_fix.*) AND NOT int_flag THEN 
				LET reply = fgl_winbutton("","Select all rows, are you sure?","Yes","Yes|No","question",0) 
				CASE 
					WHEN reply matches "Yes" 
						EXIT CONSTRUCT 
					OTHERWISE # saisie d'un critere de selection 
						ERROR "Please input a least one criteria" 
						CONTINUE CONSTRUCT 
				END CASE 
			END IF 
	END CONSTRUCT 


	IF int_flag = true THEN 
		MESSAGE "Quit with quit key" 
		LET int_flag=0 
	ELSE 
		LET xnumber = sql_get_qbe_count_dbschema_fix(where_clause) 
		IF xnumber > 0 THEN 
			LET sql_stmt_status = sql_opn_pky_scr_curs_dbschema_fix(where_clause) 
		ELSE 
			RETURN -1 
		END IF 


	END IF 
	RETURN xnumber 
END FUNCTION ## query_dbschema_fix 


#######################################################################
# frm_Display_z_dbschema_status_f_dbschema_status : displays the form record AFTER reading and displays lookup records if any
# inbound: Form record.*
FUNCTION frm_display_z_dbschema_status(l_rec_frm_z_dbschema_status) 
	DEFINE l_rec_frm_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00297
	END RECORD 


	#@G00299
	#CLEAR FORM
	DISPLAY BY NAME l_rec_frm_z_dbschema_status.* 


	#@G00302


END FUNCTION # frm_display_z_dbschema_status_f_dbschema_status 




####################################################################
## frm_Insert_z_dbschema_status_f_dbschema_status: add a new dbschema_fix row
FUNCTION frm_insert_z_dbschema_status() 
	DEFINE sql_stmt_status SMALLINT 
	DEFINE rows_count SMALLINT 
	DEFINE nbre_dbschema_fix ,action SMALLINT 
	DEFINE l_rec_frm_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00314
	END RECORD 


	DEFINE l_rec_tbl_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00318
	END RECORD 


	#@G00320


	#CLEAR FORM
	INITIALIZE l_rec_frm_z_dbschema_status.* TO NULL 


	WHILE true 
		LET int_flag = false 
		INPUT BY NAME l_rec_frm_z_dbschema_status.fix_name, 
		l_rec_frm_z_dbschema_status.fix_dbvendor, 
		l_rec_frm_z_dbschema_status.fix_abstract, 
		l_rec_frm_z_dbschema_status.fix_type, 
		l_rec_frm_z_dbschema_status.fix_dependencies, 
		l_rec_frm_z_dbschema_status.fix_tableslist, 
		l_rec_frm_z_dbschema_status.fix_create_date, 
		l_rec_frm_z_dbschema_status.git_commit_hash, 
		l_rec_frm_z_dbschema_status.fix_apply_date, 
		l_rec_frm_z_dbschema_status.fix_status 

		#@G00327
		WITHOUT DEFAULTS 
			AFTER FIELD fix_name 
				IF l_rec_frm_z_dbschema_status.fix_name IS NULL THEN 
					ERROR "This field is required" 
					NEXT FIELD fix_name 
				END IF 
				IF sql_status_pk_dbschema_fix(l_rec_frm_z_dbschema_status.fix_name) THEN 
					ERROR "dbschema_fix: already exists" 
					NEXT FIELD fix_name 
				END IF 
				#@G00337
				#@G00337
				#@G00337
		END INPUT 
		IF int_flag = true THEN 
			# Resign from input
			LET int_flag=false 
			DISPLAY BY NAME l_rec_frm_z_dbschema_status.* 
			MESSAGE "Quit with quit key Control-C" 
			EXIT WHILE 
		END IF 


		CALL confirm_operation(3,10,"Insert") RETURNING ACTION 
		CASE ACTION 
			WHEN 0 # i want TO edit the input, remains displayed 'as is' 
				CONTINUE WHILE # ON laisse tout affiche comme tel 


			WHEN 2 # ON valide la transaction 
				BEGIN WORK 
					#@G00353
					CALL set_table_record_f_dbschema_status_dbschema_fix(1,l_rec_frm_z_dbschema_status.*) 
					RETURNING l_rec_tbl_z_dbschema_status.* 
					CALL sql_insert_dbschema_fix(l_rec_tbl_z_dbschema_status.*) 
					RETURNING sql_stmt_status, l_rec_tbl_z_dbschema_status.fix_name 
					#@G00357


					CASE 
						WHEN sql_stmt_status = 0 
							MESSAGE "Insert dbschema_fix Successful operation" 
						COMMIT WORK 
						#@G00362
						WHEN sql_stmt_status < 0 
							CALL display_eric_error("Insert dbschema_fix:failed ") 
							ROLLBACK WORK 
							#@G00365
					END CASE 
					EXIT WHILE 


			WHEN 0 
				ROLLBACK WORK 
				#@G00370
				EXIT WHILE 
		END CASE 
	END WHILE 
	# l_rec_tbl_z_dbschema_status
	RETURN sql_stmt_status, l_rec_tbl_z_dbschema_status.fix_name 
	#@G00375
END FUNCTION ## frm_insert_z_dbschema_status_f_dbschema_status 


#######################################################################
# frm_Edit_z_dbschema_status_f_dbschema_status : Edit a dbschema_fix RECORD
# inbound: table primary key
FUNCTION frm_edit_z_dbschema_status(p_rec_pky,p_rec_frm_z_dbschema_status) 
	DEFINE ACTION SMALLINT 
	DEFINE sql_stmt_status,dummy SMALLINT 


	DEFINE tbl_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00386
	END RECORD 


	DEFINE p_rec_frm_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00390
	END RECORD 


	DEFINE sav_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00394
	END RECORD 
	#@G00395
	DEFINE rows_count SMALLINT 
	DEFINE p_rec_pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00398
	END RECORD 


	## check if record can be accessed
	WHILE true 
		LET int_flag = false 
		# Save Screen Record values before altering
		LET sav_z_dbschema_status.* = p_rec_frm_z_dbschema_status.* 
		BEGIN WORK 
			EXECUTE immediate "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS" 
			WHENEVER ERROR CONTINUE 
			OPEN crs_upd_dbschema_fix USING p_rec_pky.* 
			FETCH crs_upd_dbschema_fix INTO dummy 
			IF sqlca.sqlcode = -244 THEN ERROR "THIS ROW IS BEING MODIFIED" 
				ROLLBACK WORK EXIT WHILE END IF 
				WHENEVER ERROR stop 
				#@G00413


				INPUT BY NAME p_rec_frm_z_dbschema_status.fix_dbvendor, 
				p_rec_frm_z_dbschema_status.fix_abstract, 
				p_rec_frm_z_dbschema_status.fix_type, 
				p_rec_frm_z_dbschema_status.fix_dependencies, 
				p_rec_frm_z_dbschema_status.fix_tableslist, 
				p_rec_frm_z_dbschema_status.fix_create_date, 
				p_rec_frm_z_dbschema_status.git_commit_hash, 
				p_rec_frm_z_dbschema_status.fix_apply_date, 
				p_rec_frm_z_dbschema_status.fix_status 

				#@G00415
				WITHOUT DEFAULTS 
				#@G00416


				#@G00417


				#@G00418
				END INPUT 
				IF int_flag = true THEN 
					LET int_flag=false 
					# Restore previous value
					LET p_rec_frm_z_dbschema_status.* = sav_z_dbschema_status.* 
					DISPLAY BY NAME p_rec_frm_z_dbschema_status.* 
					#@G00424
					EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
					ROLLBACK WORK 
					MESSAGE "$CancelCom Control-C" 
					EXIT WHILE 
				END IF 


				CALL confirm_operation(4,10,MODE_CLASSIC_EDIT) RETURNING ACTION 


				CASE 
					WHEN ACTION = 0 
						# Redo, leave values as modified
						CONTINUE WHILE 
					WHEN ACTION = 1 
						# Resign, restore original values
						LET p_rec_frm_z_dbschema_status.* = sav_z_dbschema_status.* 
						DISPLAY BY NAME p_rec_frm_z_dbschema_status.* 
						EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
						ROLLBACK WORK 
						EXIT WHILE # CANCEL operation 


					WHEN ACTION = 2 
						# confirm update
						CALL set_table_record_f_dbschema_status_dbschema_fix(2,p_rec_frm_z_dbschema_status.*) 
						RETURNING tbl_z_dbschema_status.* 


						# Perform the prepared update statement
						LET sql_stmt_status = sql_edit_dbschema_fix(p_rec_pky.*,tbl_z_dbschema_status.*) 
						CASE 
							WHEN sql_stmt_status = 0 
								MESSAGE "Edit dbschema_fix Successful operation" 
								EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
							COMMIT WORK 
							#@G00456
							WHEN sql_stmt_status < 0 
								CALL display_eric_error("Edit dbschema_fix:failed ") 
								EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
								ROLLBACK WORK 
								#@G00460
						END CASE 
						EXIT WHILE 
				END CASE 
			END WHILE 
			RETURN sql_stmt_status 
END FUNCTION ## frm_edit_z_dbschema_status(p_rec_pky) 


#######################################################################
# DELETE A dbschema_fix row
# inbound: table primary key
FUNCTION frm_delete_z_dbschema_status(pky) 
	DEFINE ACTION SMALLINT 
	DEFINE dummy SMALLINT 
	DEFINE sql_stmt_status SMALLINT 
	DEFINE pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00476
	END RECORD 


	WHILE true 
		CALL confirm_operation(5,10,"Delete") RETURNING ACTION 
		BEGIN WORK 
			EXECUTE immediate "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS" 
			WHENEVER ERROR CONTINUE 
			OPEN crs_upd_dbschema_fix USING pky.* 
			FETCH crs_upd_dbschema_fix INTO dummy 
			IF sqlca.sqlcode = -244 THEN ERROR "THIS ROW IS BEING MODIFIED" 
				ROLLBACK WORK EXIT WHILE END IF 
				WHENEVER ERROR stop 
				#@G00488
				CASE 
					WHEN ACTION = 0 OR ACTION = 1 
						# can the delete operation
						EXIT WHILE 
					WHEN ACTION = 2 
						# Validate the delete operation
						CALL sql_delete_dbschema_fix(pky.*) RETURNING sql_stmt_status 
						CASE 
							WHEN sql_stmt_status = 0 
								MESSAGE "Delete dbschema_fix Successful operation" 
							COMMIT WORK 
							#@G00499


							WHEN sql_stmt_status < 0 
								CALL display_eric_error("Delete dbschema_fix:failed ") 
								ROLLBACK WORK 
								#@G00503
						END CASE 
						EXIT WHILE 
				END CASE 
			END WHILE 
			RETURN sql_stmt_status 
END FUNCTION ## frm_delete_z_dbschema_status(pky) 


#########################################################################
#  Build, prepare, declare and initialize main queries and cursors
FUNCTION sql_prepare_queries_z_dbschema_status_dbschema_fix () 
	DEFINE query_text STRING 


	# PREPARE cursor for full master table row contents, access by primary key
	LET query_text= 
	"SELECT fix_name,fix_dbvendor,fix_abstract,fix_type,fix_dependencies,fix_tableslist,fix_create_date,git_commit_hash,fix_apply_date,fix_status 
	", #@G00518 
	" FROM dbschema_fix ", 
	"WHERE fix_name = ? " #@g00520 


	PREPARE sel_mrw_dbschema_fix FROM query_text 
	DECLARE crs_row_dbschema_fix CURSOR FOR sel_mrw_dbschema_fix 


	# PREPARE cursor for row test / check if locked
	LET query_text= "SELECT fix_name 
	", #@G00526 
	" FROM dbschema_fix ", 
	" WHERE fix_name = ? " #@g00528 


	PREPARE sel_pky_dbschema_fix FROM query_text 
	DECLARE crs_pky_dbschema_fix CURSOR FOR sel_pky_dbschema_fix 


	# PREPARE cursor for SELECT FOR UPDATE
	LET query_text= "SELECT fix_name 
	", #@G00534 
	" FROM dbschema_fix ", 
	" WHERE fix_name = ? ", #@g00536 
	" FOR UPDATE" 


	PREPARE sel_upd_dbschema_fix FROM query_text 
	DECLARE crs_upd_dbschema_fix CURSOR FOR sel_upd_dbschema_fix 


	# PREPARE INSERT statement
	LET query_text = 
	"INSERT INTO dbschema_fix ( fix_name,fix_dbvendor,fix_abstract,fix_type,fix_dependencies,fix_tableslist,fix_create_date,git_commit_hash,fix_apply_date,fix_status 
	)", #@G00544 
	" VALUES ( ?,?,?,?,?,?,?,?,?,? 
	)" #@G00545 
	PREPARE pr_ins_dbschema_fix FROM query_text 


	# PREPARE UPDATE statement
	LET query_text= 
	"UPDATE dbschema_fix ", 
	"SET ( fix_dbvendor,fix_abstract,fix_type,fix_dependencies,fix_tableslist,fix_create_date,git_commit_hash,fix_apply_date,fix_status 
	)", #@G00551 
	" = ( ?,?,?,?,?,?,?,?,? 
	)", #@G00552 
	" WHERE fix_name = ? " #@g00553 
	PREPARE pr_upd_dbschema_fix FROM query_text 


	# PREPARE DELETE statement
	LET query_text= "DELETE FROM dbschema_fix ", 
	" WHERE fix_name = ? " #@g00558 


	PREPARE pr_del_dbschema_fix FROM query_text 


END FUNCTION ## sql_prepare_queries_z_dbschema_status_dbschema_fix 


#########################################################
# Open the QBE cursor,
# counts returned rows_count,
# OPEN the data set,
# FETCH first row
# inbound parameter: query predicate
# outbound parameters: number of rows retried
FUNCTION sql_get_qbe_count_dbschema_fix(qry_stmt) 
	DEFINE qry_stmt STRING 
	DEFINE rec_dbschema_fix STRING 
	DEFINE rows_count INTEGER 
	DEFINE lsql_stmt_status INTEGER 


	# define primary_key record
	DEFINE l_pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00579
	END RECORD 


	LET rec_dbschema_fix = 
	"SELECT count(*) FROM dbschema_fix", 
	" WHERE ",qry_stmt clipped 


	PREPARE prp_cnt_dbschema_fix FROM rec_dbschema_fix 
	DECLARE crs_cnt_dbschema_fix CURSOR FOR prp_cnt_dbschema_fix 


	OPEN crs_cnt_dbschema_fix 
	SET ISOLATION TO dirty read 
	WHENEVER ERROR CONTINUE 
	FETCH crs_cnt_dbschema_fix INTO rows_count 
	WHENEVER ERROR CALL error_mngmt 
	SET ISOLATION TO committed read 


	# if FETCH fails, count = 0, the, get back to query
	IF sqlca.sqlcode OR rows_count = 0 THEN 
		LET rows_count =0 
	END IF 
	FREE crs_cnt_dbschema_fix 
	RETURN rows_count 
END FUNCTION ## sql_get_qbe_count_dbschema_fix 


#########################################################
FUNCTION sql_opn_pky_scr_curs_dbschema_fix(qry_stmt) 
	## Build the query generated by CONSTRUCT BY NAME,
	## Declare and OPEN the cursor
	## inbound param: query predicate
	## outbound parameter: query status
	DEFINE qry_stmt STRING 
	DEFINE rec_dbschema_fix STRING 
	DEFINE rows_count INTEGER 
	DEFINE lsql_stmt_status INTEGER 


	# define primary_key record
	DEFINE l_pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00617
	END RECORD 


	# display the selected columns


	LET rec_dbschema_fix = "SELECT fix_name 
	", #@G00622 
	" FROM dbschema_fix ", 
	"WHERE ",qry_stmt clipped, 
	" ORDER BY fix_name 
	" #@G00625 


	PREPARE rech_crs_ FROM rec_dbschema_fix 


	# crs_scrl_crs_ : the first cursor selects all the primary keys (not all the table columns)


	DECLARE crs_scrl_crs_ SCROLL CURSOR with HOLD 
	FOR rech_crs_ #@g00631 


	WHENEVER ERROR CONTINUE 
	OPEN crs_scrl_crs_ 
	WHENEVER ERROR CALL error_mngmt 


	RETURN sqlca.sqlcode 
END FUNCTION ## sql_opn_pky_scr_curs_dbschema_fix 


#######################################################################
FUNCTION sql_nxtprev_dbschema_fix(offset) 
	## sql_nxtprev_dbschema_fix : FETCH NEXT OR PREVIOUS RECORD
	DEFINE offset SMALLINT 
	DEFINE lsql_stmt_status,record_found INTEGER 
	DEFINE pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00646
	END RECORD 
	DEFINE l_rec_frm_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00649
	END RECORD 


	WHENEVER ERROR CONTINUE 
	FETCH relative offset crs_scrl_crs_ INTO pky.* 
	WHENEVER ERROR CALL error_mngmt 


	CASE 
		WHEN sqlca.sqlcode = 100 
			LET record_found = 0 


		WHEN sqlca.sqlcode < 0 
			LET record_found = -1 
		OTHERWISE 
			LET lsql_stmt_status = 1 
			LET record_found = 1 
			#CALL sql_FETCH_full_row_dbschema_fix (pky.*)
			#RETURNING record_found,l_rec_frm_z_dbschema_status.*


	END CASE 
	RETURN record_found,pky.* 
END FUNCTION ## sql_nxtprev_dbschema_fix 


#########################################################################################
FUNCTION sql_fetch_full_row_dbschema_fix(pky_dbschema_fix) 
	# sql_FETCH_full_row_dbschema_fix : read a complete row accessing by primary key
	# inbound parameter : primary key
	# outbound parameter: sql_stmt_status and row contents
	DEFINE sql_stmt_status SMALLINT 
	DEFINE pky_dbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00679
	END RECORD 
	DEFINE tbl_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00682
	END RECORD 
	DEFINE l_rec_frm_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00685
	END RECORD 


	#@G00687


	# read the table, access on primary key
	WHENEVER ERROR CONTINUE 
	OPEN crs_row_dbschema_fix 
	USING pky_dbschema_fix.* 


	FETCH crs_row_dbschema_fix INTO tbl_z_dbschema_status.* 


	WHENEVER ERROR CALL error_mngmt 
	CASE 
		WHEN sqlca.sqlcode = 100 
			LET sql_stmt_status = 0 
		WHEN sqlca.sqlcode < 0 
			LET sql_stmt_status = -1 
		OTHERWISE 
			LET sql_stmt_status = 1 
			CALL set_form_record_z_dbschema_status(tbl_z_dbschema_status.*) 
			RETURNING l_rec_frm_z_dbschema_status.* 


	END CASE 
	RETURN sql_stmt_status,l_rec_frm_z_dbschema_status.* 
END FUNCTION ## sql_fetch_full_row_dbschema_fix 


########################################################################
FUNCTION sql_insert_dbschema_fix(p_rec_tbl_z_dbschema_status) 
	## INSERT in table dbschema_fix
	DEFINE p_rec_tbl_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00720
	END RECORD 
	DEFINE lsql_stmt_status INTEGER 
	DEFINE rows_count SMALLINT 
	DEFINE pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00717
	END RECORD 

	WHENEVER ERROR CONTINUE 
	EXECUTE pr_ins_dbschema_fix 
	USING p_rec_tbl_z_dbschema_status.fix_name, 
	p_rec_tbl_z_dbschema_status.fix_dbvendor, 
	p_rec_tbl_z_dbschema_status.fix_abstract, 
	p_rec_tbl_z_dbschema_status.fix_type, 
	p_rec_tbl_z_dbschema_status.fix_dependencies, 
	p_rec_tbl_z_dbschema_status.fix_tableslist, 
	p_rec_tbl_z_dbschema_status.fix_create_date, 
	p_rec_tbl_z_dbschema_status.git_commit_hash, 
	p_rec_tbl_z_dbschema_status.fix_apply_date, 
	p_rec_tbl_z_dbschema_status.fix_status 
	#@G00724
	WHENEVER ERROR CALL error_mngmt 


	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status = 0 
		#@G00731


	END IF 
	RETURN lsql_stmt_status,pky.* 
END FUNCTION ## sql_insert_dbschema_fix 


########################################################################
FUNCTION sql_edit_dbschema_fix(p_rec_pky,p_rec_tbl_z_dbschema_status) 
	## sql_Edit_dbschema_fix :update dbschema_fix record
	DEFINE lsql_stmt_status INTEGER 
	DEFINE p_rec_pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) #@g00742 
	END RECORD 
	DEFINE p_rec_tbl_z_dbschema_status RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00745
	END RECORD 


	WHENEVER ERROR CONTINUE 
	EXECUTE pr_upd_dbschema_fix 
	USING p_rec_tbl_z_dbschema_status.fix_dbvendor, 
	p_rec_tbl_z_dbschema_status.fix_abstract, 
	p_rec_tbl_z_dbschema_status.fix_type, 
	p_rec_tbl_z_dbschema_status.fix_dependencies, 
	p_rec_tbl_z_dbschema_status.fix_tableslist, 
	p_rec_tbl_z_dbschema_status.fix_create_date, 
	p_rec_tbl_z_dbschema_status.git_commit_hash, 
	p_rec_tbl_z_dbschema_status.fix_apply_date, 
	p_rec_tbl_z_dbschema_status.fix_status 
	, #@g00750 
	p_rec_pky.* 


	WHENEVER ERROR CALL error_mngmt 
	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status = 0 
	END IF 
	RETURN lsql_stmt_status 
END FUNCTION ## sql_edit_dbschema_fix 


##############################################################################################
FUNCTION sql_delete_dbschema_fix(pky) 
	## sql_Delete_dbschema_fix :delete current row in table dbschema_fix
	DEFINE lsql_stmt_status SMALLINT 
	DEFINE pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00767
	END RECORD 


	WHENEVER ERROR CONTINUE 
	EXECUTE pr_del_dbschema_fix 
	USING pky.* 


	WHENEVER ERROR CALL error_mngmt 
	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status=0 
	END IF 
	RETURN lsql_stmt_status 
END FUNCTION ## sql_delete_dbschema_fix 


################################################################################
FUNCTION sql_status_pk_dbschema_fix(pky) 
	##   sql_status_pk_dbschema_fix : Check if primary key exists
	## inbound parameter : record of primary key
	## outbound parameter:  status > 0 if exists, 0 if no record, < 0 if error
	DEFINE pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00789
	END RECORD 
	DEFINE pk_status INTEGER 


	WHENEVER ERROR CONTINUE 
	OPEN crs_pky_dbschema_fix USING pky.* 
	FETCH crs_pky_dbschema_fix 
	WHENEVER ERROR CALL error_mngmt 


	CASE sqlca.sqlcode 
		WHEN 0 
			LET pk_status = 1 
		WHEN 100 
			LET pk_status = 0 
		WHEN sqlca.sqlerrd[2] = 104 
			LET pk_status = -1 # RECORD locked 
		WHEN sqlca.sqlcode < 0 
			LET pk_status = sqlca.sqlcode 
	END CASE 


	RETURN pk_status 
END FUNCTION ## sql_status_pk_dbschema_fix 


################################################################################################
FUNCTION set_form_record_z_dbschema_status(tbl_contents) 
	## set_form_record_z_dbschema_status_f_dbschema_status: assigns table values to form fields values
	DEFINE frm_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00816
	END RECORD 


	DEFINE tbl_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00820
	END RECORD 


	INITIALIZE frm_contents.* TO NULL 
	LET frm_contents.fix_name = tbl_contents.fix_name 
	LET frm_contents.fix_dbvendor = tbl_contents.fix_dbvendor 
	LET frm_contents.fix_abstract = tbl_contents.fix_abstract 
	LET frm_contents.fix_type = tbl_contents.fix_type 
	LET frm_contents.fix_dependencies = tbl_contents.fix_dependencies 
	LET frm_contents.fix_tableslist = tbl_contents.fix_tableslist 
	LET frm_contents.fix_create_date = tbl_contents.fix_create_date 
	LET frm_contents.git_commit_hash = tbl_contents.git_commit_hash 
	LET frm_contents.fix_apply_date = tbl_contents.fix_apply_date 
	LET frm_contents.fix_status = tbl_contents.fix_status 
	#@G00834
	RETURN frm_contents.* 
END FUNCTION ## set_form_recordz_dbschema_status_f_dbschema_status 


################################################################################################
FUNCTION set_table_record_f_dbschema_status_dbschema_fix(p_sql_stmt,p_rec_frm_contents) 
	## set_table_record_f_dbschema_status_dbschema_fix: assigns form fields value to table values
	DEFINE p_sql_stmt SMALLINT # 1 => insert, 2 => UPDATE 
	DEFINE p_rec_frm_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00847
	END RECORD 
	DEFINE tbl_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATE 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00851
	END RECORD 

	DEFINE pky RECORD 
		fix_name LIKE dbschema_fix.fix_name # nchar(48) 
		#@G00843
	END RECORD 


	INITIALIZE tbl_contents.* TO NULL 
	LET tbl_contents.fix_name = p_rec_frm_contents.fix_name 
	LET tbl_contents.fix_dbvendor = p_rec_frm_contents.fix_dbvendor 
	LET tbl_contents.fix_abstract = p_rec_frm_contents.fix_abstract 
	LET tbl_contents.fix_type = p_rec_frm_contents.fix_type 
	LET tbl_contents.fix_dependencies = p_rec_frm_contents.fix_dependencies 
	LET tbl_contents.fix_tableslist = p_rec_frm_contents.fix_tableslist 
	LET tbl_contents.fix_create_date = p_rec_frm_contents.fix_create_date 
	LET tbl_contents.git_commit_hash = p_rec_frm_contents.git_commit_hash 
	LET tbl_contents.fix_apply_date = p_rec_frm_contents.fix_apply_date 
	LET tbl_contents.fix_status = p_rec_frm_contents.fix_status 
	#@G00865


	RETURN tbl_contents.* 
END FUNCTION ## set_table_recordf_dbschema_status_dbschema_fix 


#@G00870


#@G00872


#@G00874


#@G00876
