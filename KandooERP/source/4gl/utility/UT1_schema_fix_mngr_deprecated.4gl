# module generated by KandooERP Ffg(c)
# Generated on 2019-12-09 13:43:30
# Main template I:\Users\BeGooden-IT\git\KandooERP\KandooERP\Resources\Utilities\Perl\Ffg/templates/module/parent-form-basic.mtplt


#@G00005
############################################################
# GLOBAL Scope Variables
############################################################
GLOBALS "../common/glob_GLOBALS.4gl" 
DEFINE m_program CHAR(30) 


#@G00009
DEFINE g_dbschema_properties RECORD LIKE dbschema_properties.* 


MAIN 

	#Initial UI Init
	CALL setModuleId("UT1") 
	CALL ui_init(0) #initial ui init 

	DEFER quit 
	DEFER interrupt 

	CALL authenticate(getmoduleid()) #authenticate 
	CALL init_u_ut() #init utility module 



	#@G00014
	# WHENEVER SQLERROR CALL error_mngmt
	# CALL ui_init(0)
	LET m_program="p_schema_fix_mngr_dbschema_properties" 


	CALL main_schema_fix_mngr_dbschema_properties() 


END MAIN 


##########################################################################
FUNCTION mc_schema_fix_mngr_sccs() 
	## definition variable sccs
	DEFINE sccs_var CHAR(70) 
	LET sccs_var="%W% %D%" 
END FUNCTION 
##########################################################################
FUNCTION main_schema_fix_mngr_dbschema_properties () 
	## this module's main function called by MAIN

	OPEN WINDOW f_dbschema_status with FORM "U801_dbschema_status" 
	CALL windecoration_u("U801_dbschema_status") #@g00034 


	CALL sql_prepare_queries_schema_fix_mngr_dbschema_properties () # INITIALIZE all cursors ON master TABLE 
	CALL sql_prepare_queries_schema_fix_mngr_dbschema_fix() 
	#@G00037


	CALL menu_schema_fix_mngr_dbschema_properties() 


	CLOSE WINDOW f_dbschema_status 


END FUNCTION 


######################################################################
FUNCTION menu_schema_fix_mngr_dbschema_properties () 
	## menu_schema_fix_mngr_dbschema_properties
	## the top level menu
	## input arguments: none
	## output arguments: none
	DEFINE nbsel_dbschema_properties INTEGER 
	DEFINE sql_stmt_status INTEGER 
	DEFINE record_num INTEGER 
	DEFINE ACTION SMALLINT 
	DEFINE xnumber SMALLINT 
	DEFINE arr_elem_num SMALLINT 
	DEFINE pky_dbschema_properties RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00058
	END RECORD 
	DEFINE frmschema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00061
	END RECORD 


	DEFINE tbl_schema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00065
	END RECORD 


	DEFINE record_found INTEGER 
	DEFINE lookup_status INTEGER 


	LET nbsel_dbschema_properties = 0 
	MENU "dbschema_properties" 
		BEFORE MENU 
			HIDE option "Next","Previous","EDIT","DELETE","View Array dbschema_fix","Edit Array dbschema_fix" 
		COMMAND "Query" "Query data with multiple criteria dbschema_properties" 
			#@G00075
			MESSAGE "" 
			INITIALIZE frmschema_fix_mngr.* TO NULL 
			CLEAR FORM 
			DISPLAY BY NAME frmschema_fix_mngr.* 
			HIDE option "Next","Previous" 


			CALL frm_query_schema_fix_mngr() RETURNING nbsel_dbschema_properties 
			IF nbsel_dbschema_properties > 0 THEN 
				CALL sql_nxtprev_dbschema_properties(1) RETURNING record_found, 
				pky_dbschema_properties.* 


				CASE 
					WHEN record_found = 1 
						LET record_num = 1 
						CALL sql_fetch_full_row_dbschema_properties (pky_dbschema_properties.*) 
						RETURNING record_found,frmschema_fix_mngr.* 


						CALL frm_display_schema_fix_mngr(frmschema_fix_mngr.*) 


						CALL initialize_array_dbschema_fix() 
						LET arr_elem_num = display_array_dbschema_fix (pky_dbschema_properties.*,false) 
						SHOW option "View Array dbschema_fix","Edit Array dbschema_fix" 
						#@G00097
					WHEN record_found = -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
				END CASE 
				IF nbsel_dbschema_properties > 1 THEN 
					SHOW option "Next" 
					NEXT option "Next" 
				END IF 
				SHOW option "EDIT","DELETE" 
			ELSE 
				ERROR "No row matches the criteria" 
				NEXT option "Query" 
			END IF 
		COMMAND KEY (tab) "View Array dbschema_fix" 
			CALL display_array_dbschema_fix (pky_dbschema_properties.*,true) 
		COMMAND KEY (shift-tab) "Edit Array dbschema_fix" 
			CALL frm_edit_array_dbschema_fix (pky_dbschema_properties.*,true) 
			#@G00111


		COMMAND "Next" "Display Next record dbschema_properties" 
			#@G00113
			MESSAGE "" 
			CLEAR FORM 
			INITIALIZE frmschema_fix_mngr.* TO NULL 


			IF record_num <= nbsel_dbschema_properties THEN 
				CALL sql_nxtprev_dbschema_properties(1) RETURNING record_found, 
				pky_dbschema_properties.* 


				CASE 
					WHEN record_found = 0 
						ERROR "fetch Last record of this selection dbschema_properties" 
					WHEN record_found = -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
					WHEN record_found = 1 
						LET record_num = record_num + 1 
						CALL sql_fetch_full_row_dbschema_properties (pky_dbschema_properties.*) 
						RETURNING record_found,frmschema_fix_mngr.* 


						CALL frm_display_schema_fix_mngr(frmschema_fix_mngr.*) 
						CALL initialize_array_dbschema_fix() 
						LET arr_elem_num = display_array_dbschema_fix (pky_dbschema_properties.*,false) 
						SHOW option "View Array dbschema_fix","Edit Array dbschema_fix" 
						#@G00135


						IF record_num >= nbsel_dbschema_properties THEN 
							HIDE option "Next" 
						END IF 
						IF record_num > 1 THEN 
							SHOW option "Previous" 
						ELSE 
							HIDE option "Previous" 
						END IF 
				END CASE 
			ELSE 
				ERROR " Please set query criteria previously dbschema_properties " 
				NEXT option "Query" 
			END IF 
		COMMAND KEY (tab) "View Array dbschema_fix" 
			CALL display_array_dbschema_fix (pky_dbschema_properties.*,true) 
		COMMAND KEY (shift-tab) "Edit Array dbschema_fix" 
			CALL frm_edit_array_dbschema_fix (pky_dbschema_properties.*,true) 
			#@G00151


		COMMAND "Previous" "Display Previous Record dbschema_properties" 
			#@G00153


			MESSAGE "" 
			CLEAR FORM 
			INITIALIZE frmschema_fix_mngr.* TO NULL 


			IF record_num >= 1 THEN 
				CALL sql_nxtprev_dbschema_properties(-1) RETURNING record_found, 
				pky_dbschema_properties.* 
				CASE 
					WHEN record_found = 0 
						ERROR "fetch First record of this selection dbschema_properties" 
					WHEN record_found < -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
					WHEN record_found = 1 
						LET record_num = record_num - 1 
						CALL sql_fetch_full_row_dbschema_properties (pky_dbschema_properties.*) 
						RETURNING record_found,frmschema_fix_mngr.* 


						CALL frm_display_schema_fix_mngr(frmschema_fix_mngr.*) 
						CALL initialize_array_dbschema_fix() 
						LET arr_elem_num = display_array_dbschema_fix (pky_dbschema_properties.*,false) 
						SHOW option "View Array dbschema_fix","Edit Array dbschema_fix" 
						#@G00175
						IF record_num = 1 THEN 
							HIDE option "Previous" 
						END IF 
						IF record_num < nbsel_dbschema_properties THEN 
							SHOW option "Next" 
						ELSE 
							HIDE option "Next" 
						END IF 
				END CASE 
			ELSE 
				ERROR " Please set query criteria previously dbschema_properties " 
				NEXT option "Query" 
			END IF 
		COMMAND KEY (tab) "View Array dbschema_fix" 
			CALL display_array_dbschema_fix (pky_dbschema_properties.*,true) 
		COMMAND KEY (shift-tab) "Edit Array dbschema_fix" 
			CALL frm_edit_array_dbschema_fix (pky_dbschema_properties.*,true) 
			#@G00190




		COMMAND "Exit" "Exit program" 
			#@G00237
			MESSAGE "" 
			EXIT MENU 
	END MENU 
END FUNCTION 


#######################################################################
FUNCTION frm_query_schema_fix_mngr() 
	## frm_Query_schema_fix_mngr_f_dbschema_status : Query By Example on table dbschema_properties
	## Input selection criteria,
	## prepare the query,
	## open the data set
	DEFINE rec_dbschema_properties,where_clause STRING 
	DEFINE xnumber,sql_stmt_status INTEGER 
	DEFINE l_pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00252
	END RECORD 
	DEFINE frmschema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00255
	END RECORD 


	DEFINE reply CHAR(5) 
	LET xnumber = 0 
	MESSAGE "Please input query criteria" 
	# initialize record and display blank
	CLEAR FORM 
	INITIALIZE frmschema_fix_mngr.* TO NULL 
	DISPLAY BY NAME frmschema_fix_mngr.* 




	CONSTRUCT BY NAME where_clause ON dbschema_properties.dbsname, 
	dbschema_properties.last_patch_ok_scripts, 
	dbschema_properties.last_patch_ko_scripts 

	#@G00267


	#@G00268


	## Check whether criteria have been entered
		AFTER CONSTRUCT 
			IF NOT field_touched(dbschema_properties.*) AND NOT int_flag THEN 
				LET reply = fgl_winbutton("","Select all rows, are you sure?","Yes","Yes|No","question",0) 
				CASE 
					WHEN reply matches "Yes" 
						EXIT CONSTRUCT 
					OTHERWISE # saisie d'un critere de selection 
						ERROR "Please input a least one criteria" 
						CONTINUE CONSTRUCT 
				END CASE 
			END IF 
	END CONSTRUCT 


	IF int_flag = true THEN 
		MESSAGE "Quit with quit key" 
		LET int_flag=0 
	ELSE 
		LET xnumber = sql_get_qbe_count_dbschema_properties(where_clause) 
		IF xnumber > 0 THEN 
			LET sql_stmt_status = sql_opn_pky_scr_curs_dbschema_properties(where_clause) 
		ELSE 
			RETURN -1 
		END IF 


	END IF 
	RETURN xnumber 
END FUNCTION ## query_dbschema_properties 


#######################################################################
# frm_Display_schema_fix_mngr_f_dbschema_status : displays the form record after reading and displays lookup records if any
# inbound: Form record.*
FUNCTION frm_display_schema_fix_mngr(frmschema_fix_mngr) 
	DEFINE frmschema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00304
	END RECORD 


	#@G00306
	CLEAR FORM 
	DISPLAY BY NAME frmschema_fix_mngr.* 


	#@G00309


END FUNCTION # frm_display_schema_fix_mngr_f_dbschema_status 




####################################################################
## frm_Insert_schema_fix_mngr_f_dbschema_status: add a new dbschema_properties row
FUNCTION frm_insert_schema_fix_mngr() 
	DEFINE sql_stmt_status SMALLINT 
	DEFINE rows_count SMALLINT 
	DEFINE nbre_dbschema_properties ,action SMALLINT 
	DEFINE frmschema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00321
	END RECORD 


	DEFINE tbl_schema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00325
	END RECORD 


	#@G00327


	CLEAR FORM 
	INITIALIZE frmschema_fix_mngr.* TO NULL 


	WHILE true 
		LET int_flag = false 
		INPUT BY NAME frmschema_fix_mngr.dbsname, 
		frmschema_fix_mngr.last_patch_ok_scripts, 
		frmschema_fix_mngr.last_patch_ko_scripts 

		#@G00334
		WITHOUT DEFAULTS 
		#@G00335


		#@G00336
		#@G00336
		END INPUT 
		IF int_flag = true THEN 
			# Resign from input
			LET int_flag=false 
			DISPLAY BY NAME frmschema_fix_mngr.* 
			MESSAGE "Quit with quit key Control-C" 
			EXIT WHILE 
		END IF 


		CALL confirm_operation(3,10,"Insert") RETURNING ACTION 
		CASE ACTION 
			WHEN 0 # i want TO edit the input, remains displayed 'as is' 
				CONTINUE WHILE # ON laisse tout affiche comme tel 


			WHEN 2 # ON valide la transaction 
				BEGIN WORK 
					#@G00352
					CALL set_table_record_f_dbschema_status_dbschema_properties('+',frmschema_fix_mngr.*) 
					RETURNING tbl_schema_fix_mngr.* 
					CALL sql_insert_dbschema_properties(tbl_schema_fix_mngr.*) 
					RETURNING sql_stmt_status, tbl_schema_fix_mngr.dbsvendor 
					#@G00356


					CASE 
						WHEN sql_stmt_status = 0 
							MESSAGE "Insert dbschema_properties Successful operation" 
						COMMIT WORK 
						#@G00361
						WHEN sql_stmt_status < 0 
							CALL display_error2("Insert dbschema_properties:failed ") 
							ROLLBACK WORK 
							#@G00364
					END CASE 
					EXIT WHILE 


			WHEN 0 
				ROLLBACK WORK 
				#@G00369
				EXIT WHILE 
		END CASE 
	END WHILE 
	# tbl_schema_fix_mngr
	RETURN sql_stmt_status, tbl_schema_fix_mngr.dbsvendor 
	#@G00374
END FUNCTION ## frm_insert_schema_fix_mngr_f_dbschema_status 




#######################################################################
# frm_Edit_schema_fix_mngr_f_dbschema_status : Edit a dbschema_properties RECORD
# inbound: table primary key
FUNCTION frm_edit_schema_fix_mngr(pky,frmschema_fix_mngr) 
	DEFINE ACTION SMALLINT 
	DEFINE sql_stmt_status,dummy SMALLINT 


	DEFINE tbl_schema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00386
	END RECORD 


	DEFINE frmschema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00390
	END RECORD 


	DEFINE savschema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00394
	END RECORD 
	#@G00395
	DEFINE rows_count SMALLINT 
	DEFINE pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00398
	END RECORD 


	## check if record can be accessed
	WHILE true 
		LET int_flag = false 
		# Save Screen Record values before altering
		LET savschema_fix_mngr.* = frmschema_fix_mngr.* 
		BEGIN WORK 
			EXECUTE immediate "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS" 
			WHENEVER SQLERROR CONTINUE 
			OPEN crs_upd_dbschema_properties USING pky.* 
			FETCH crs_upd_dbschema_properties INTO dummy 
			IF sqlca.sqlcode = -244 THEN ERROR "THIS ROW IS BEING MODIFIED" 
				ROLLBACK WORK EXIT WHILE END IF 
				WHENEVER SQLERROR stop 
				#@G00413
				INPUT BY NAME frmschema_fix_mngr.dbsname, 
				frmschema_fix_mngr.last_patch_ok_scripts, 
				frmschema_fix_mngr.last_patch_ko_scripts 

				#@G00414
				WITHOUT DEFAULTS 
				#@G00415


				#@G00416


				#@G00417
				END INPUT 
				IF int_flag = true THEN 
					LET int_flag=false 
					# Restore previous value
					LET frmschema_fix_mngr.* = savschema_fix_mngr.* 
					DISPLAY BY NAME frmschema_fix_mngr.* 
					#@G00423
					EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
					ROLLBACK WORK 
					MESSAGE "$CancelCom Control-C" 
					EXIT WHILE 
				END IF 


				CALL confirm_operation(4,10,MODE_CLASSIC_EDIT) RETURNING ACTION 


				CASE 
					WHEN ACTION = 0 
						# Redo, leave values as modified
						CONTINUE WHILE 
					WHEN ACTION = 1 
						# Resign, restore original values
						LET frmschema_fix_mngr.* = savschema_fix_mngr.* 
						DISPLAY BY NAME frmschema_fix_mngr.* 
						EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
						ROLLBACK WORK 
						EXIT WHILE # CANCEL operation 


					WHEN ACTION = 2 
						# confirm update
						CALL set_table_record_f_dbschema_status_dbschema_properties("#",frmschema_fix_mngr.*) 
						RETURNING tbl_schema_fix_mngr.* 


						# Perform the prepared update statement
						LET sql_stmt_status = sql_edit_dbschema_properties(pky.*,tbl_schema_fix_mngr.*) 
						CASE 
							WHEN sql_stmt_status = 0 
								MESSAGE "Edit dbschema_properties Successful operation" 
								EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
							COMMIT WORK 
							#@G00455
							WHEN sql_stmt_status < 0 
								CALL display_error2("Edit dbschema_properties:failed ") 
								EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
								ROLLBACK WORK 
								#@G00459
						END CASE 
						EXIT WHILE 
				END CASE 
			END WHILE 
			RETURN sql_stmt_status 
END FUNCTION ## frm_edit_schema_fix_mngr(pky) 




#######################################################################
# DELETE A dbschema_properties row
# inbound: table primary key
FUNCTION frm_delete_schema_fix_mngr(pky) 
	DEFINE ACTION SMALLINT 
	DEFINE dummy SMALLINT 
	DEFINE sql_stmt_status SMALLINT 
	DEFINE pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00476
	END RECORD 


	WHILE true 
		CALL confirm_operation(5,10,"Delete") RETURNING ACTION 
		BEGIN WORK 
			EXECUTE immediate "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS" 
			WHENEVER SQLERROR CONTINUE 
			OPEN crs_upd_dbschema_properties USING pky.* 
			FETCH crs_upd_dbschema_properties INTO dummy 
			IF sqlca.sqlcode = -244 THEN ERROR "THIS ROW IS BEING MODIFIED" 
				ROLLBACK WORK EXIT WHILE END IF 
				WHENEVER SQLERROR stop 
				#@G00488
				CASE 
					WHEN ACTION = 0 OR ACTION = 1 
						# can the delete operation
						EXIT WHILE 
					WHEN ACTION = 2 
						# Validate the delete operation
						CALL sql_delete_dbschema_properties(pky.*) RETURNING sql_stmt_status 
						CASE 
							WHEN sql_stmt_status = 0 
								MESSAGE "Delete dbschema_properties Successful operation" 
							COMMIT WORK 
							#@G00499


							WHEN sql_stmt_status < 0 
								CALL display_error2("Delete dbschema_properties:failed ") 
								ROLLBACK WORK 
								#@G00503
						END CASE 
						EXIT WHILE 
				END CASE 
			END WHILE 
			RETURN sql_stmt_status 
END FUNCTION ## frm_delete_schema_fix_mngr(pky) 


#########################################################################
#  Build, prepare, declare and initialize main queries and cursors
FUNCTION sql_prepare_queries_schema_fix_mngr_dbschema_properties () 
	DEFINE query_text STRING 


	# PREPARE cursor for full master table row contents, access by primary key
	LET query_text= 
	"SELECT dbsname,dbsvendor,snapshot_date,last_patch_date,last_patch_apply,build_id,last_patch_ok_scripts,last_patch_ko_scripts 
	", #@G00518 
	" FROM dbschema_properties ", 
	"WHERE dbsvendor = ? " #@g00520 


	PREPARE sel_mrw_dbschema_properties FROM query_text 
	DECLARE crs_row_dbschema_properties CURSOR FOR sel_mrw_dbschema_properties 


	# PREPARE cursor for row test / check if locked
	LET query_text= "SELECT dbsvendor 
	", #@G00526 
	" FROM dbschema_properties ", 
	" WHERE dbsvendor = ? " #@g00528 


	PREPARE sel_pky_dbschema_properties FROM query_text 
	DECLARE crs_pky_dbschema_properties CURSOR FOR sel_pky_dbschema_properties 


	# PREPARE cursor for SELECT FOR UPDATE
	LET query_text= "SELECT dbsvendor 
	", #@G00534 
	" FROM dbschema_properties ", 
	" WHERE dbsvendor = ? ", #@g00536 
	" FOR UPDATE" 


	PREPARE sel_upd_dbschema_properties FROM query_text 
	DECLARE crs_upd_dbschema_properties CURSOR FOR sel_upd_dbschema_properties 


	# PREPARE INSERT statement
	LET query_text = 
	"INSERT INTO dbschema_properties ( dbsname,dbsvendor,snapshot_date,last_patch_date,last_patch_apply,build_id,last_patch_ok_scripts,last_patch_ko_scripts 
	)", #@G00544 
	" VALUES ( ?,?,?,?,?,?,?,? 
	)" #@G00545 
	PREPARE pr_ins_dbschema_properties FROM query_text 


	# PREPARE UPDATE statement
	LET query_text= 
	"UPDATE dbschema_properties ", 
	"SET ( dbsname,snapshot_date,last_patch_date,last_patch_apply,build_id,last_patch_ok_scripts,last_patch_ko_scripts 
	)", #@G00551 
	" = ( ?,?,?,?,?,?,? 
	)", #@G00552 
	" WHERE dbsvendor = ? " #@g00553 
	PREPARE pr_upd_dbschema_properties FROM query_text 


	# PREPARE DELETE statement
	LET query_text= "DELETE FROM dbschema_properties ", 
	" WHERE dbsvendor = ? " #@g00558 


	PREPARE pr_del_dbschema_properties FROM query_text 


END FUNCTION ## sql_prepare_queries_schema_fix_mngr_dbschema_properties 




#########################################################
# Open the QBE cursor,
# counts returned rows_count,
# open the data set,
# fetch first row
# inbound parameter: query predicate
# outbound parameters: number of rows retried
FUNCTION sql_get_qbe_count_dbschema_properties(qry_stmt) 
	DEFINE qry_stmt STRING 
	DEFINE rec_dbschema_properties STRING 
	DEFINE rows_count INTEGER 
	DEFINE lsql_stmt_status INTEGER 


	# define primary_key record
	DEFINE l_pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00580
	END RECORD 


	LET rec_dbschema_properties = 
	"SELECT count(*) FROM dbschema_properties", 
	" WHERE ",qry_stmt clipped 




	PREPARE prp_cnt_dbschema_properties FROM rec_dbschema_properties 
	DECLARE crs_cnt_dbschema_properties CURSOR FOR prp_cnt_dbschema_properties 


	OPEN crs_cnt_dbschema_properties 
	SET ISOLATION TO dirty read 
	WHENEVER SQLERROR CONTINUE 
	FETCH crs_cnt_dbschema_properties INTO rows_count 
	WHENEVER SQLERROR CALL error_mngmt 
	SET ISOLATION TO committed read 


	# if FETCH fails, count = 0, the, get back to query
	IF sqlca.sqlcode OR rows_count = 0 THEN 
		LET rows_count =0 
	END IF 
	FREE crs_cnt_dbschema_properties 
	RETURN rows_count 
END FUNCTION ## sql_get_qbe_count_dbschema_properties 


#########################################################
FUNCTION sql_opn_pky_scr_curs_dbschema_properties(qry_stmt) 
	## Build the query generated by CONSTRUCT BY NAME,
	## Declare and open the cursor
	## inbound param: query predicate
	## outbound parameter: query status
	DEFINE qry_stmt STRING 
	DEFINE rec_dbschema_properties STRING 
	DEFINE rows_count INTEGER 
	DEFINE lsql_stmt_status INTEGER 


	# define primary_key record
	DEFINE l_pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00619
	END RECORD 


	# display the selected columns


	LET rec_dbschema_properties = "SELECT dbsvendor 
	", #@G00624 
	" FROM dbschema_properties ", 
	"WHERE ",qry_stmt clipped, 
	" ORDER BY dbsvendor 
	" #@G00627 


	PREPARE rech_crs_ FROM rec_dbschema_properties 


	# crs_scrl_crs_ : the first cursor selects all the primary keys (not all the table columns)


	DECLARE crs_scrl_crs_ SCROLL CURSOR with HOLD 
	FOR rech_crs_ #@g00633 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_scrl_crs_ 
	WHENEVER SQLERROR CALL error_mngmt 


	RETURN sqlca.sqlcode 
END FUNCTION ## sql_opn_pky_scr_curs_dbschema_properties 


#######################################################################
FUNCTION sql_nxtprev_dbschema_properties(offset) 
	## sql_nxtprev_dbschema_properties : FETCH NEXT OR PREVIOUS RECORD
	DEFINE offset SMALLINT 
	DEFINE lsql_stmt_status,record_found INTEGER 
	DEFINE pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00648
	END RECORD 
	DEFINE frmschema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00651
	END RECORD 


	WHENEVER SQLERROR CONTINUE 
	FETCH relative offset crs_scrl_crs_ INTO pky.* 
	WHENEVER SQLERROR CALL error_mngmt 


	CASE 
		WHEN sqlca.sqlcode = 100 
			LET record_found = 0 


		WHEN sqlca.sqlcode < 0 
			LET record_found = -1 
		OTHERWISE 
			LET lsql_stmt_status = 1 
			LET record_found = 1 
			#CALL sql_fetch_full_row_dbschema_properties (pky.*)
			#RETURNING record_found,frmschema_fix_mngr.*


	END CASE 
	RETURN record_found,pky.* 
END FUNCTION ## sql_nxtprev_dbschema_properties 


#########################################################################################
FUNCTION sql_fetch_full_row_dbschema_properties(pky_dbschema_properties) 
	# sql_fetch_full_row_dbschema_properties : read a complete row accessing by primary key
	# inbound parameter : primary key
	# outbound parameter: sql_stmt_status and row contents
	DEFINE sql_stmt_status SMALLINT 
	DEFINE pky_dbschema_properties RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00681
	END RECORD 
	DEFINE tbl_schema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00684
	END RECORD 
	DEFINE frmschema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00687
	END RECORD 


	#@G00689


	# read the table, access on primary key
	WHENEVER SQLERROR CONTINUE 
	OPEN crs_row_dbschema_properties 
	USING pky_dbschema_properties.* 


	FETCH crs_row_dbschema_properties INTO tbl_schema_fix_mngr.* 


	WHENEVER SQLERROR CALL error_mngmt 
	CASE 
		WHEN sqlca.sqlcode = 100 
			LET sql_stmt_status = 0 
		WHEN sqlca.sqlcode < 0 
			LET sql_stmt_status = -1 
		OTHERWISE 
			LET sql_stmt_status = 1 
			CALL set_form_record_schema_fix_mngr(tbl_schema_fix_mngr.*) 
			RETURNING frmschema_fix_mngr.* 
	END CASE 
	RETURN sql_stmt_status,frmschema_fix_mngr.* 
END FUNCTION ## sql_fetch_full_row_dbschema_properties 


########################################################################
FUNCTION sql_insert_dbschema_properties(tbl_schema_fix_mngr) 
	## INSERT in table dbschema_properties
	DEFINE lsql_stmt_status INTEGER 
	DEFINE rows_count SMALLINT 
	DEFINE pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00718
	END RECORD 
	DEFINE tbl_schema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00721
	END RECORD 
	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_ins_dbschema_properties 
	USING tbl_schema_fix_mngr.dbsname, 
	tbl_schema_fix_mngr.dbsvendor, 
	tbl_schema_fix_mngr.snapshot_date, 
	tbl_schema_fix_mngr.last_patch_date, 
	tbl_schema_fix_mngr.last_patch_apply, 
	tbl_schema_fix_mngr.build_id, 
	tbl_schema_fix_mngr.last_patch_ok_scripts, 
	tbl_schema_fix_mngr.last_patch_ko_scripts 
	#@G00725
	WHENEVER SQLERROR CALL error_mngmt 


	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status = 0 
		#@G00732


	END IF 
	RETURN lsql_stmt_status,pky.* 
END FUNCTION ## sql_insert_dbschema_properties 


########################################################################
FUNCTION sql_edit_dbschema_properties(pky,tbl_schema_fix_mngr) 
	## sql_Edit_dbschema_properties :update dbschema_properties record
	DEFINE lsql_stmt_status INTEGER 
	DEFINE pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00743
	END RECORD 
	DEFINE tbl_schema_fix_mngr RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00746
	END RECORD 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_upd_dbschema_properties 
	USING tbl_schema_fix_mngr.dbsname, 
	tbl_schema_fix_mngr.snapshot_date, 
	tbl_schema_fix_mngr.last_patch_date, 
	tbl_schema_fix_mngr.last_patch_apply, 
	tbl_schema_fix_mngr.build_id, 
	tbl_schema_fix_mngr.last_patch_ok_scripts, 
	tbl_schema_fix_mngr.last_patch_ko_scripts 
	, #@g00751 
	pky.* 


	WHENEVER SQLERROR CALL error_mngmt 
	IF sqlca.sqlcode < 0 THEN 


		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status = 0 
	END IF 
	RETURN lsql_stmt_status 
END FUNCTION ## sql_edit_dbschema_properties 


##############################################################################################
FUNCTION sql_delete_dbschema_properties(pky) 
	## sql_Delete_dbschema_properties :delete current row in table dbschema_properties
	DEFINE lsql_stmt_status SMALLINT 
	DEFINE pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00769
	END RECORD 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_del_dbschema_properties 
	USING pky.* 


	WHENEVER SQLERROR CALL error_mngmt 
	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status=0 
	END IF 
	RETURN lsql_stmt_status 
END FUNCTION ## sql_delete_dbschema_properties 


################################################################################
FUNCTION sql_status_pk_dbschema_properties(pky) 
	##   sql_status_pk_dbschema_properties : Check if primary key exists
	## inbound parameter : record of primary key
	## outbound parameter:  status > 0 if exists, 0 if no record, < 0 if error
	DEFINE pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00791
	END RECORD 
	DEFINE pk_status INTEGER 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_pky_dbschema_properties USING pky.* 
	FETCH crs_pky_dbschema_properties 
	WHENEVER SQLERROR CALL error_mngmt 


	CASE sqlca.sqlcode 
		WHEN 0 
			LET pk_status = 1 
		WHEN 100 
			LET pk_status = 0 
		WHEN sqlca.sqlerrd[2] = 104 
			LET pk_status = -1 # RECORD locked 
		WHEN sqlca.sqlcode < 0 
			LET pk_status = sqlca.sqlcode 
	END CASE 


	RETURN pk_status 
END FUNCTION ## sql_status_pk_dbschema_properties 


################################################################################################
FUNCTION set_form_record_schema_fix_mngr(tbl_contents) 
	## set_form_record_schema_fix_mngr_f_dbschema_status: assigns table values to form fields values
	DEFINE frm_contents RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00818
	END RECORD 


	DEFINE tbl_contents RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00822
	END RECORD 


	INITIALIZE frm_contents.* TO NULL 
	LET frm_contents.dbsname = tbl_contents.dbsname 
	LET frm_contents.dbsvendor = tbl_contents.dbsvendor 
	LET frm_contents.snapshot_date = tbl_contents.snapshot_date 
	LET frm_contents.last_patch_date = tbl_contents.last_patch_date 
	LET frm_contents.last_patch_apply = tbl_contents.last_patch_apply 
	LET frm_contents.build_id = tbl_contents.build_id 
	LET frm_contents.last_patch_ok_scripts = tbl_contents.last_patch_ok_scripts 
	LET frm_contents.last_patch_ko_scripts = tbl_contents.last_patch_ko_scripts 
	#@G00834
	RETURN frm_contents.* 
END FUNCTION ## set_form_recordschema_fix_mngr_f_dbschema_status 


################################################################################################
FUNCTION set_table_record_f_dbschema_status_dbschema_properties(sql_stmt,frm_contents) 
	## set_table_record_f_dbschema_status_dbschema_properties: assigns form fields value to table values
	DEFINE sql_stmt SMALLINT # + => insert, # => UPDATE 
	DEFINE pky RECORD 
		dbsvendor LIKE dbschema_properties.dbsvendor # nchar(32) 
		#@G00843
	END RECORD 


	DEFINE frm_contents RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00847
	END RECORD 


	DEFINE tbl_contents RECORD 
		dbsname LIKE dbschema_properties.dbsname, # nchar(48) 
		dbsvendor LIKE dbschema_properties.dbsvendor, # nchar(32) 
		snapshot_date LIKE dbschema_properties.snapshot_date, # DATE 
		last_patch_date LIKE dbschema_properties.last_patch_date, # DATE 
		last_patch_apply LIKE dbschema_properties.last_patch_apply, # DATETIME year TO second 
		build_id LIKE dbschema_properties.build_id, # nchar(32) 
		last_patch_ok_scripts LIKE dbschema_properties.last_patch_ok_scripts, # SMALLINT 
		last_patch_ko_scripts LIKE dbschema_properties.last_patch_ko_scripts # SMALLINT 
		#@G00851
	END RECORD 


	INITIALIZE tbl_contents.* TO NULL 
	CASE sql_stmt 
		WHEN "+" # PREPARE RECORD FOR INSERT 
			LET tbl_contents.dbsname = frm_contents.dbsname 
			-- LET tbl_contents.dbsvendor = YOUR VALUE
			-- LET tbl_contents.snapshot_date = YOUR VALUE
			-- LET tbl_contents.last_patch_date = YOUR VALUE
			-- LET tbl_contents.last_patch_apply = YOUR VALUE
			-- LET tbl_contents.build_id = YOUR VALUE
			LET tbl_contents.last_patch_ok_scripts = frm_contents.last_patch_ok_scripts 
			LET tbl_contents.last_patch_ko_scripts = frm_contents.last_patch_ko_scripts 
			#@G00865
		WHEN "#" # PREPARE RECORD FOR UPDATE 
			LET tbl_contents.dbsname = frm_contents.dbsname 
			-- LET tbl_contents.dbsvendor = YOUR VALUE
			-- LET tbl_contents.snapshot_date = YOUR VALUE
			-- LET tbl_contents.last_patch_date = YOUR VALUE
			-- LET tbl_contents.last_patch_apply = YOUR VALUE
			-- LET tbl_contents.build_id = YOUR VALUE
			LET tbl_contents.last_patch_ok_scripts = frm_contents.last_patch_ok_scripts 
			LET tbl_contents.last_patch_ko_scripts = frm_contents.last_patch_ko_scripts 
			#@G00875
	END CASE 


	RETURN tbl_contents.* 
END FUNCTION ## set_table_recordf_dbschema_status_dbschema_properties 


#@G00881


#@G00883


#@G00885


#@G00887


