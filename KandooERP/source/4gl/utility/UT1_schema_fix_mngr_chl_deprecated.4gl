# module generated by Kandoo Ffg(c)
# Generated on 2019-12-09 13:43:30
# template I:\Users\BeGooden-IT\git\KandooERP\KandooERP\Resources\Utilities\Perl\Ffg/templates/module/child-form-basic.mtplt
############################################################
# GLOBAL Scope Variables
############################################################
GLOBALS "../common/glob_GLOBALS.4gl" 
DEFINE pky_arraydbschema_fix DYNAMIC ARRAY OF RECORD 
	fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
	fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
#@G00006
END RECORD 


DEFINE scr_arraydbschema_fix DYNAMIC ARRAY OF RECORD 
	fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
	fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
	fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
	fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
	fix_status LIKE dbschema_fix.fix_status # nchar(2) 
#@G00010
END RECORD 


DEFINE act_arraydbschema_fix DYNAMIC ARRAY OF CHAR(1) 


DEFINE tbl_dbschema_fix RECORD 
	fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
	fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
	fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
	fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
	fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
	fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
	fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
	git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
	fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
	fix_status LIKE dbschema_fix.fix_status # nchar(2) 
#@G00016
END RECORD 




FUNCTION sql_prepare_queries_schema_fix_mngr_dbschema_fix () 
	# this function initializes all cursors and prepared statements for the dbschema_fix and lookups


	DEFINE query_text STRING 
	# Prepare the cursor to display the dbschema_fix array
	# using foreign key pointing to dbschema_properties


	LET query_text = "SELECT \"=\",", 
	"dbschema_fix.fix_name,dbschema_fix.fix_dbvendor, ", 
	"dbschema_fix.fix_name,", 
	"dbschema_fix.fix_abstract,", 
	"dbschema_fix.fix_tableslist,", 
	"dbschema_fix.fix_apply_date,", 
	"dbschema_fix.fix_status", 
	" FROM dbschema_fix, ", 
	"dbschema_properties ", 
	"WHERE dbschema_fix.fix_dbvendor = dbschema_properties.dbsvendor ", #@g00033 
	" AND dbschema_fix.fix_dbvendor = ? ", #@g00034 
	" ORDER BY dbschema_fix.fix_name DESC" #@g00035 
	PREPARE pr_child_dbschema_fix FROM query_text 
	DECLARE crs_child_dbschema_fix CURSOR FOR pr_child_dbschema_fix 


	# PREPARE INSERT statement
	LET query_text = 
	"INSERT INTO dbschema_fix ( fix_name,fix_dbvendor,fix_abstract,fix_type,fix_dependencies,fix_tableslist,fix_create_date,git_commit_hash,fix_apply_date,fix_status 
	)", #@G00041 
	" VALUES ( ?,?,?,?,?,?,?,?,?,? 
	)" #@G00042 
	PREPARE pr_ins_dbschema_fix FROM query_text 


	# PREPARE UPDATE statement
	LET query_text= 
	"UPDATE dbschema_fix ", 
	"SET ( fix_abstract,fix_type,fix_dependencies,fix_tableslist,fix_create_date,git_commit_hash,fix_apply_date,fix_status 
	)", #@G00048 
	" = ( ?,?,?,?,?,?,?,? 
	)", #@G00049 
	" WHERE fix_name = ? 
	AND fix_dbvendor = ? " #@G00051 
	PREPARE pr_upd_dbschema_fix FROM query_text 


	# PREPARE DELETE statement
	LET query_text= "DELETE FROM dbschema_fix ", 
	" WHERE fix_name = ? 
	AND fix_dbvendor = ? " #@G00057 
	PREPARE pr_del_dbschema_fix FROM query_text 


END FUNCTION 


FUNCTION sql_open_array_crs_scr_arraydbschema_fix(fky) 
	## This function opens the main cursor for the table dbschema_fix


	DEFINE lsql_ok INTEGER 
	DEFINE fky RECORD 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00067
	END RECORD 


	#WHENEVER SQLERROR CONTINUE
	OPEN crs_child_dbschema_fix USING fky.* 


	# WHENEVER SQLERROR CALL error_mngmt
	CASE 
		WHEN sqlca.sqlcode = 100 
			LET lsql_ok = 0 
		WHEN sqlca.sqlcode < 0 
			LET lsql_ok = -1 
		OTHERWISE 
			LET lsql_ok = 1 
	END CASE 
	RETURN lsql_ok 
END FUNCTION 


FUNCTION sql_insert_dbschema_fix(p_rec_dbschema_fix) 
	## INSERT in table dbschema_fix
	DEFINE p_rec_dbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00088
	END RECORD 


	DEFINE lsql_stmt_status INTEGER 
	DEFINE lookup_status INTEGER 
	DEFINE nb_deleted_rows INTEGER 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_ins_dbschema_fix 
	USING p_rec_dbschema_fix.fix_name, 
	p_rec_dbschema_fix.fix_dbvendor, 
	p_rec_dbschema_fix.fix_abstract, 
	p_rec_dbschema_fix.fix_type, 
	p_rec_dbschema_fix.fix_dependencies, 
	p_rec_dbschema_fix.fix_tableslist, 
	p_rec_dbschema_fix.fix_create_date, 
	p_rec_dbschema_fix.git_commit_hash, 
	p_rec_dbschema_fix.fix_apply_date, 
	p_rec_dbschema_fix.fix_status 
	# 		                                                                                                                      	#@G00097
	WHENEVER SQLERROR CALL error_mngmt 


	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status = 0 
		WHEN sqlca.sqlcode < 0 
			CALL display_error2("sql_Insert dbschema_fix:failed ",sqlca.sqlcode) 
			LET lsql_stmt_status = -1 
	END CASE 
	RETURN lsql_stmt_status 
END FUNCTION 


FUNCTION sql_edit_dbschema_fix(p_rec_pky,p_rec_lr_dbschema_fix) 
	## sql_Edit_dbschema_fix :update current dbschema_fix record
	DEFINE p_rec_lr_dbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00113
	END RECORD 
	DEFINE lsql_stmt_status INTEGER 
	DEFINE nb_modified_rows INTEGER 
	DEFINE p_rec_pky RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00118
	END RECORD 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_upd_dbschema_fix 
	USING p_rec_lr_dbschema_fix.fix_abstract, 
	p_rec_lr_dbschema_fix.fix_type, 
	p_rec_lr_dbschema_fix.fix_dependencies, 
	p_rec_lr_dbschema_fix.fix_tableslist, 
	p_rec_lr_dbschema_fix.fix_create_date, 
	p_rec_lr_dbschema_fix.git_commit_hash, 
	p_rec_lr_dbschema_fix.fix_apply_date, 
	p_rec_lr_dbschema_fix.fix_status 
	, #@g00123 
	p_rec_pky.* 


	WHENEVER SQLERROR CALL error_mngmt 
	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status = 0 
			LET nb_modified_rows = sqlca.sqlerrd[3] 
		WHEN sqlca.sqlcode < 0 
			CALL display_error2("sql_Edit dbschema_fix:failed ",sqlca.sqlcode) 
			LET lsql_stmt_status = -1 
			LET nb_modified_rows = 0 
	END CASE 
	RETURN lsql_stmt_status,nb_modified_rows 
END FUNCTION 


FUNCTION sql_delete_dbschema_fix(pky) 
	## delete_dbschema_fix :delete Selected row in table dbschema_fix
	DEFINE lsql_stmt_status SMALLINT 
	DEFINE nb_deleted_rows INTEGER 
	DEFINE pky RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00144
	END RECORD 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_del_dbschema_fix USING pky.* 


	WHENEVER SQLERROR CALL error_mngmt 
	CASE 
		WHEN sqlca.sqlcode = 0 
			LET lsql_stmt_status=0 
			LET nb_deleted_rows = sqlca.sqlerrd[3] 
		WHEN sqlca.sqlcode < 0 
			CALL display_error2("sql_Delete dbschema_fix:failed ",sqlca.sqlcode) 
			LET lsql_stmt_status = -1 
	END CASE 


	RETURN lsql_stmt_status,nb_deleted_rows 
END FUNCTION 


################################################################################
FUNCTION sql_status_pk_dbschema_fix(pky) 
	#"# This function Checks if primary key exists
	## inbound parameter : record of primary key
	## outbound parameter:  status > 0 if exists, 0 if no record, < 0 if error
	################################################################################
	DEFINE pky RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00170
	END RECORD 
	DEFINE pk_status INTEGER 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_pky_crs_ USING pky.* 
	FETCH crs_pky_crs_ 
	WHENEVER SQLERROR CALL error_mngmt 


	CASE sqlca.sqlcode 
		WHEN 0 
			LET pk_status = 1 
		WHEN 100 
			LET pk_status = 0 
		WHEN sqlca.sqlerrd[2] = 104 
			LET pk_status = -1 # RECORD locked 
		WHEN sqlca.sqlcode < 0 
			LET pk_status = sqlca.sqlcode 
	END CASE 
	RETURN pk_status 
END FUNCTION 


#@G00192


#######################################################################
FUNCTION initialize_array_dbschema_fix() 
	#######################################################################
	# initializes arrays
	CALL scr_arraydbschema_fix.clear() 
	CALL pky_arraydbschema_fix.clear() 
END FUNCTION 


######################################################################################################################################################
FUNCTION display_array_dbschema_fix (fky,browse) 
	# This function displays the array data (scr_arraydbschema_fix) based on the foreign key
	# browse: False means that the array is displayed without possibility of browsing inside (just show array and skip to next parent row)
	######################################################################################################################################################
	DEFINE elem_num,choice,xpos,ypos INTEGER 
	DEFINE arrcurr,srcline INTEGER 
	DEFINE sql_ok INTEGER 
	DEFINE qbe_stmt STRING 
	DEFINE browse boolean 
	DEFINE where_clause STRING 
	DEFINE fky RECORD 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00214
	END RECORD 
	DEFINE sql_stmt_status INTEGER 


	IF browse = false THEN 
		# opening array cursor and fetch data only when reading the parent row
		LET sql_ok = sql_open_array_crs_scr_arraydbschema_fix(fky.*) 
		LET elem_num = 1 
		FOREACH crs_child_dbschema_fix INTO act_arraydbschema_fix[elem_num] ,pky_arraydbschema_fix[elem_num].*,scr_arraydbschema_fix[elem_num].* 
			LET elem_num = elem_num + 1 
		END FOREACH 
		IF elem_num > 1 THEN 
			CALL scr_arraydbschema_fix.deleteelement(elem_num) 
		END IF 
	END IF 


	DISPLAY ARRAY scr_arraydbschema_fix 
	TO table2.* 
		BEFORE DISPLAY 
			IF browse = false THEN 
				EXIT DISPLAY 
			END IF 
	END DISPLAY 


	RETURN elem_num-1 
END FUNCTION 


###########################################################################################################
FUNCTION frm_edit_array_dbschema_fix (p_rec_pky_dbschema_properties) 
	# This function calls the INPUT array function (frm_input_array_dbschema_fix) to edit the array data
	# then, accordingly, the SQL statement functions (array_bulk_update_)
	# it is generally called from another module
	###########################################################################################################
	DEFINE p_rec_pky_dbschema_properties RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00257
	END RECORD 

	DEFINE srcline INTEGER 
	DEFINE arrcurr INTEGER 
	DEFINE bulk_update_status SMALLINT 
	DEFINE nbr_edited_rows INTEGER 
	DEFINE sql_action SMALLINT 
	DEFINE i SMALLINT 
	DEFINE fky RECORD 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00254
	END RECORD 


	BEGIN WORK 
		#@G00259
		WHILE true 
			CALL frm_input_array_dbschema_fix (p_rec_pky_dbschema_properties.*) RETURNING nbr_edited_rows,sql_action 
			#@G00260
			IF nbr_edited_rows > 0 THEN 
				CASE 
					WHEN sql_action = 2 
						LET bulk_update_status = array_bulk_update_dbschema_fix (p_rec_pky_dbschema_properties.*) 
						IF bulk_update_status > 0 THEN 
							ROLLBACK WORK 
							#@G00265
							ERROR "frm_input_array failed" 
						ELSE 
							ERROR "frm_input_array Successful operation" 
						COMMIT WORK 
						#@G00268
						EXIT WHILE 
					END IF 
					WHEN sql_action = 1 
						# No
						ERROR "Please INPUT ARRAY AGAIN" 
					WHEN sql_action = 0 
						# Cancel
						MESSAGE "Cancelled, exit INPUT ARRAY" 
						EXIT WHILE 
				END CASE 
			ELSE 
				# Nothing
				MESSAGE "Nothing has been changed" 
				EXIT WHILE 
			END IF 
		END WHILE 


END FUNCTION 


####################################################################################################################
FUNCTION frm_input_array_dbschema_fix (pky_dbschema_properties) 
	## this function operates INPUT ARRAY for the table dbschema_fix
	# it handles 2 arrays:
	# 1) the Input Data Array (scr_arraydbschema_fix) will contain the data input by the user
	# 2) the primary key array (pky_dbschema_properties) contains the status for each element:
	#    NULL=>no data, 0=>elements not touched, 1=>element to INSERT, 2=>element to UPDATE, -1=>element to DELETE
	#    and also contains the primary key values of each element
	###################################################################################################################
	DEFINE arrcnt INTEGER 
	DEFINE srcline INTEGER 
	DEFINE arrcurr INTEGER 
	DEFINE last_element INTEGER 
	DEFINE lookup_status INTEGER 
	DEFINE sql_stmt_status INTEGER 
	DEFINE nbr_edited_rows INTEGER 
	DEFINE sql_action SMALLINT 
	DEFINE ins_key SMALLINT 
	DEFINE pky_dbschema_properties RECORD 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00307
	END RECORD 
	DEFINE savscr_arraydbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00310
	END RECORD 
	DEFINE sql_ok SMALLINT 
	LET nbr_edited_rows = 0 


	LET int_flag = false 
	LET ins_key = false 


	INPUT ARRAY scr_arraydbschema_fix WITHOUT DEFAULTS 
	FROM table2.* 
	attribute(normal) 
		ON KEY (INTERRUPT) 
			# Cancel from input
			LET int_flag=false 
			LET arrcurr = arr_curr() 
			LET srcline = scr_line () 
			LET scr_arraydbschema_fix[arrcurr].* = savscr_arraydbschema_fix.* 
			DISPLAY scr_arraydbschema_fix[arrcurr].* TO table2[srcline].* 
			MESSAGE "Quit with quit key Control-C" 
			ROLLBACK WORK 
			#@G00328
			EXIT INPUT 


		BEFORE INSERT 
			# insert a row in pky_array
			LET arrcurr = arr_curr() 
			LET srcline = scr_line () 
			CALL pky_arraydbschema_fix.insert(arrcurr) 
			INITIALIZE pky_arraydbschema_fix[arrcurr].* TO NULL 


		BEFORE ROW 
			LET srcline = scr_line() 
			LET arrcurr = arr_curr() 
			LET savscr_arraydbschema_fix.* = scr_arraydbschema_fix[arrcurr].* 


			#@G00342


			#@G00343


		AFTER DELETE 
			IF act_arraydbschema_fix[arrcurr] IS NOT NULL THEN 
				LET last_element = pky_arraydbschema_fix.getsize() 
				# The deleted element becomes the last element of status_array and flagged -1
				# The pky is also copied to the last element
				LET pky_arraydbschema_fix[last_element].* = pky_arraydbschema_fix[arrcurr].* 
				LET act_arraydbschema_fix[arrcurr] = "-" # TO be deleted 
				LET nbr_edited_rows = nbr_edited_rows + 1 
			END IF 


		AFTER ROW 
			IF field_touched (table2[srcline].*) THEN 
				LET nbr_edited_rows = nbr_edited_rows + 1 
				CASE 
					WHEN act_arraydbschema_fix[arrcurr] = "=" # existing 
						LET act_arraydbschema_fix[arrcurr] = "#" # TO be modified 
						LET pky_arraydbschema_fix[arrcurr].fix_name = scr_arraydbschema_fix[arrcurr].fix_name 
						LET pky_arraydbschema_fix[arrcurr].fix_dbvendor = pky_dbschema_properties.fix_dbvendor 
						#@G00361


					WHEN act_arraydbschema_fix[arrcurr] IS NULL # new 
						LET act_arraydbschema_fix[arrcurr] = "+" # TO be inserted 
						LET pky_arraydbschema_fix[arrcurr].fix_name = scr_arraydbschema_fix[arrcurr].fix_name 
						LET pky_arraydbschema_fix[arrcurr].fix_dbvendor = pky_dbschema_properties.fix_dbvendor 
						#@G00365
				END CASE 
				IF sql_status_pk_dbschema_fix(pky_arraydbschema_fix[arrcurr].*) THEN 
					ERROR "dbschema_fix: already exists" 
					NEXT FIELD last_patch_ko_scripts 
				END IF 
				#@G00371
			END IF 


		AFTER INPUT 
			IF int_flag THEN 
				LET int_flag = false 
				ERROR " Cancel dbschema_fix" 
				LET nbr_edited_rows = 0 
				LET sql_action = 0 
			ELSE 
				LET sql_action = confirm_operation(5,10,"frm_input_array ") 
				IF sql_action = 1 THEN 
					CONTINUE INPUT 
				END IF 
			END IF 
	END INPUT 
	RETURN nbr_edited_rows,sql_action 
END FUNCTION 


######################################################################################################
FUNCTION set_form_record_f_dbschema_status_table2(tbl_contents) 
	# This function assigns the values from the table Table2 to the form record frm_contents
	######################################################################################################
	DEFINE fgl_status SMALLINT 
	DEFINE frm_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00396
	END RECORD 


	DEFINE tbl_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00400
	END RECORD 


	INITIALIZE frm_contents.* TO NULL 
	LET frm_contents.fix_name = tbl_dbschema_fix.fix_name 
	LET frm_contents.fix_abstract = tbl_dbschema_fix.fix_abstract 
	LET frm_contents.fix_tableslist = tbl_dbschema_fix.fix_tableslist 
	LET frm_contents.fix_apply_date = tbl_dbschema_fix.fix_apply_date 
	LET frm_contents.fix_status = tbl_dbschema_fix.fix_status 
	#@G00409
	CASE 
		WHEN status = 0 
			LET fgl_status = 1 
		WHEN status < 0 
			LET fgl_status = status 
		OTHERWISE 
			LET fgl_status = status 
	END CASE 
	RETURN fgl_status,frm_contents.* 
END FUNCTION 


######################################################################################################
FUNCTION set_table_record_f_dbschema_status_dbschema_fix(p_sql_stmt,p_rec_fky,p_rec_pky,p_rec_element_contents) 
	# This function assigns the values from the array element(p_rec_element_contents) to the table record (tbl_contents)
	# It distinguishes the primary key (p_rec_pky) of the table dbschema_fixand the foreign key (p_rec_fky) point to the parent table (dbschema_properties)
	######################################################################################################
	DEFINE p_sql_stmt CHAR(1) -- "+" => INSERT "#" => UPDATE 
	DEFINE p_rec_element_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00429
	END RECORD 
	DEFINE p_rec_fky RECORD 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00432
	END RECORD 
	DEFINE p_rec_pky RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00435
	END RECORD 
	DEFINE fgl_status SMALLINT 
	DEFINE tbl_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00438
	END RECORD 


	#WHENEVER SQLERROR CONTINUE
	INITIALIZE tbl_contents.* TO NULL 
	CASE p_sql_stmt 
		WHEN "+" -- SET TABLE RECORD TO INSERT ROW 
			LET tbl_contents.fix_name = p_rec_element_contents.fix_name 
			-- LET tbl_contents.fix_dbvendor = YOUR VALUE
			LET tbl_contents.fix_abstract = p_rec_element_contents.fix_abstract 
			-- LET tbl_contents.fix_type = YOUR VALUE
			-- LET tbl_contents.fix_dependencies = YOUR VALUE
			LET tbl_contents.fix_tableslist = p_rec_element_contents.fix_tableslist 
			-- LET tbl_contents.fix_create_date = YOUR VALUE
			-- LET tbl_contents.git_commit_hash = YOUR VALUE
			LET tbl_contents.fix_apply_date = p_rec_element_contents.fix_apply_date 
			LET tbl_contents.fix_status = p_rec_element_contents.fix_status 
			#@G00455


		WHEN "#" -- SET TABLE RECORD TO UPDATE ROW 
			-- LET tbl_contents.fix_dbvendor = YOUR VALUE
			LET tbl_contents.fix_abstract = p_rec_element_contents.fix_abstract 
			-- LET tbl_contents.fix_type = YOUR VALUE
			-- LET tbl_contents.fix_dependencies = YOUR VALUE
			LET tbl_contents.fix_tableslist = p_rec_element_contents.fix_tableslist 
			-- LET tbl_contents.fix_create_date = YOUR VALUE
			-- LET tbl_contents.git_commit_hash = YOUR VALUE
			LET tbl_contents.fix_apply_date = p_rec_element_contents.fix_apply_date 
			#@G00466
	END CASE 


	#WHENEVER ERROR CALL error_mngmt
	CASE 
		WHEN status = 0 
			LET fgl_status = 1 
		WHEN status < 0 
			LET fgl_status = status 
		OTHERWISE 
			LET fgl_status = status 
	END CASE 
	RETURN fgl_status,tbl_contents.* 
END FUNCTION 


#############################################################################################################
FUNCTION array_bulk_update_dbschema_fix (p_rec_parent_fky) 
	## This functions browses the action array act_arraydbschema_fix},
	# copies the element values to table values (dbschema_fix)
	# and executes the request SQL operation requested for each element
	#############################################################################################################
	DEFINE p_rec_parent_fky RECORD 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor # nchar(15) 
		#@G00490
	END RECORD 
	DEFINE idx,arr_size INTEGER 
	DEFINE updarr_status,fgl_status,global_status INTEGER 

	DEFINE elements_contents RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00493
	END RECORD 
	DEFINE l_dbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00496
	END RECORD 
	LET global_status = 0 
	LET arr_size = pky_arraydbschema_fix.getsize() 
	FOR idx = 1 TO arr_size 
		CASE 
			WHEN act_arraydbschema_fix[idx] = "=" 
				CONTINUE FOR 
			WHEN act_arraydbschema_fix[idx] matches "[+#]" # insert,delete OR UPDATE 
				CALL set_table_record_f_dbschema_status_dbschema_fix (act_arraydbschema_fix[idx],p_rec_parent_fky.*,pky_arraydbschema_fix[idx].*,scr_arraydbschema_fix[idx].*) 
				RETURNING fgl_status,l_dbschema_fix.* 
		END CASE 
		LET updarr_status = sql_update_one_element__dbschema_fix(idx,l_dbschema_fix.*) 
		IF updarr_status < 0 THEN 
			ERROR "Error on element # ",idx 
			LET global_status = global_status + 1 
		END IF 
	END FOR 
	RETURN global_status 
END FUNCTION 




###############################################################################
FUNCTION sql_update_one_element__dbschema_fix(p_idx,p_rec_dbschema_fix) 
	## This function executes the SQL statement for each element
	## accord the to status array value of this element
	###############################################################################
	DEFINE st SMALLINT 
	DEFINE arrcnt SMALLINT 
	DEFINE p_idx SMALLINT 
	DEFINE statut SMALLINT 
	DEFINE p_rec_dbschema_fix RECORD 
		fix_name LIKE dbschema_fix.fix_name, # nchar(48) 
		fix_dbvendor LIKE dbschema_fix.fix_dbvendor, # nchar(15) 
		fix_abstract LIKE dbschema_fix.fix_abstract, # nchar(80) 
		fix_type LIKE dbschema_fix.fix_type, # nchar(15) 
		fix_dependencies LIKE dbschema_fix.fix_dependencies, # nvarchar(255) 
		fix_tableslist LIKE dbschema_fix.fix_tableslist, # nvarchar(255) 
		fix_create_date LIKE dbschema_fix.fix_create_date, # DATE 
		git_commit_hash LIKE dbschema_fix.git_commit_hash, # nchar(50) 
		fix_apply_date LIKE dbschema_fix.fix_apply_date, # DATETIME year TO second 
		fix_status LIKE dbschema_fix.fix_status # nchar(2) 
		#@G00528
	END RECORD 
	LET st = 0 
	CASE act_arraydbschema_fix[p_idx] 
		WHEN "#" # must be updated 
			LET statut = sql_edit_dbschema_fix(pky_arraydbschema_fix[p_idx].*,p_rec_dbschema_fix.*) 
		WHEN "+" # must be inserted 
			LET statut = sql_insert_dbschema_fix(p_rec_dbschema_fix.*) 
		WHEN "-" # must be deleted 
			LET statut = sql_delete_dbschema_fix(pky_arraydbschema_fix[p_idx].*) 
	END CASE 
	RETURN statut 
END FUNCTION 


#@G00542
