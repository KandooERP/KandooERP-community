# module generated by KandooERP Ffg(c)
# Generated on 2019-11-05 19:55:27
# Main template I:\Users\BeGooden-IT\git\KandooERP\KandooERP\Resources\Utilities\Perl\Ffg/templates/module/parent-form-basic.mtplt
############################################################
# GLOBAL Scope Variables
############################################################
GLOBALS "../common/glob_GLOBALS.4gl"

DEFINE m_program CHAR(30) 

# Define record type for parent table primary key structure
DEFINE g_table_documentation RECORD LIKE table_documentation.* 

# Define record type for parent table primary key structure
DEFINE t_pky_table_documentation TYPE AS RECORD 
	tabname LIKE table_documentation.tabname, # varchar(128) 
	language_code LIKE table_documentation.language_code # char(3) 
END RECORD 

# Define record type for form fields image
DEFINE t_frm_z_table_documentation_mngr TYPE AS RECORD 
	tabname LIKE table_documentation.tabname, # varchar(128) 
	tabtype LIKE table_documentation.tabtype, # char(10) 
	usage_bmlist LIKE table_documentation.usage_bmlist, # char(50)
	language_code LIKE table_documentation.language_code, # char(3) 
	documentation LIKE table_documentation.documentation, # nvarchar(255) 
	mtime LIKE table_documentation.mtime # DATETIME year TO second 
END RECORD 

# Define record type for table image
DEFINE t_tbl_z_table_documentation_mngr TYPE AS RECORD 
	tabname LIKE table_documentation.tabname, # varchar(128) 
	tabtype LIKE table_documentation.tabtype, # char(10)
	usage_bmlist LIKE table_documentation.usage_bmlist, # char(50) 
	language_code LIKE table_documentation.language_code, # char(3) 
	documentation LIKE table_documentation.documentation, # nvarchar(255) 
	mtime LIKE table_documentation.mtime # DATETIME year TO second 
END RECORD 

MAIN 
	DEFER interrupt 

	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
	CALL setModuleId("UT2") 
	CALL ui_init(0) #initial ui init 

	DEFER quit 
	DEFER interrupt 

	CALL authenticate(getmoduleid()) #authenticate 
	CALL init_u_ut() #init utility module 

	CALL main_z_table_documentation_mngr_table_documentation() 
	  
END MAIN 

##########################################################################
FUNCTION mc_z_table_documentation_mngr_sccs() 
	## definition variable sccs
	DEFINE sccs_var CHAR(70) 
	LET sccs_var="%W% %D%" 
END FUNCTION 
##########################################################################
FUNCTION main_z_table_documentation_mngr_table_documentation () 
	## this module's main function called by MAIN

	OPEN WINDOW f_dbschema_documentation with FORM "f_dbschema_documentation" 
	#@G00034

	CALL sql_prepare_queries_z_table_documentation_mngr_table_documentation () # INITIALIZE all cursors ON master TABLE 
	CALL sql_prepare_queries_z_table_documentation_mngr_column_documentation() 
	#@G00037


	CALL menu_z_table_documentation_mngr_table_documentation() 


	CLOSE WINDOW f_dbschema_documentation 


END FUNCTION 


######################################################################
FUNCTION menu_z_table_documentation_mngr_table_documentation () 
	## menu_z_table_documentation_mngr_table_documentation
	## the top level menu
	## input arguments: none
	## output arguments: none
	DEFINE nbsel_table_documentation INTEGER 
	DEFINE sql_stmt_status INTEGER 
	DEFINE record_num INTEGER 
	DEFINE ACTION SMALLINT 
	DEFINE xnumber,nbr_new_tables,nbr_new_columns SMALLINT 
	DEFINE arr_elem_num SMALLINT 
	DEFINE pky_table_documentation t_pky_table_documentation 
	DEFINE frm_z_table_documentation_mngr t_frm_z_table_documentation_mngr 
	DEFINE tbl_z_table_documentation_mngr t_tbl_z_table_documentation_mngr 
	DEFINE record_found INTEGER 
	DEFINE lookup_status INTEGER 


	LET nbsel_table_documentation = 0 
	MENU "table_documentation" 
		BEFORE MENU 
			HIDE option "INSERT","EDIT","DELETE" 
			HIDE option "Modify Table Doc","Next","Previous","View Columns Doc","Modify Columns Doc" 

		COMMAND "Query" "Query data with multiple criteria table_documentation" 
			#@G00075
			MESSAGE "" 
			INITIALIZE frm_z_table_documentation_mngr.* TO NULL 
			CLEAR FORM 
			DISPLAY BY NAME frm_z_table_documentation_mngr.* 
			HIDE option "Next","Previous","View Columns Doc","Modify Columns Doc" 


			CALL frm_query_z_table_documentation_mngr() RETURNING nbsel_table_documentation 
			ERROR "Number of table documents found: ",nbsel_table_documentation 
			IF nbsel_table_documentation > 0 THEN 
				CALL sql_nxtprev_table_documentation(1) RETURNING record_found, 
				pky_table_documentation.* 


				CASE 
					WHEN record_found = 1 
						LET record_num = 1 
						CALL sql_fetch_full_row_table_documentation (pky_table_documentation.*) 
						RETURNING record_found,frm_z_table_documentation_mngr.* 

						CALL frm_display_z_table_documentation_mngr(frm_z_table_documentation_mngr.*) 

						CALL initialize_array_column_documentation() 
						LET arr_elem_num = display_array_column_documentation (pky_table_documentation.*,false) 
						SHOW option "Modify Table Doc","View Columns Doc","Modify Columns Doc" 
						#@G00097
					WHEN record_found = -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
				END CASE 
				IF nbsel_table_documentation > 1 THEN 
					SHOW option "Next" 
					NEXT option "Next" 
				END IF 
			ELSE 
				ERROR "No row matches the criteria" 
				NEXT option "Query" 
			END IF 

		COMMAND "Modify Table Doc" "Modify current table documentation" #@g00191 
			#HELP 4000		                                                                                                              	#@G00192
			MESSAGE "" #@g00193 
			IF nbsel_table_documentation THEN #@g00194 
				IF sql_status_pk_table_documentation(pky_table_documentation.*) < 0 THEN #@g00195 
					ERROR "IS locked " #@g00196 
					NEXT option "Next" #@g00197 
				ELSE #@g00198 
					LET sql_stmt_status = frm_edit_z_table_documentation_mngr(pky_table_documentation.*,frm_z_table_documentation_mngr.*) #@g00199 
				END IF #@g00200 
			ELSE #@g00201 
				ERROR " Please SET query criteria previously form_attributes " #@g00202 
				NEXT option "Query" #@g00203 
			END IF #@g00204 

		COMMAND "Check New Tables" "Check New Tables that are not documented" 
			CALL insert_new_tables () RETURNING nbr_new_tables 
			CALL insert_new_columns () RETURNING nbr_new_columns 

		COMMAND "DocumentFromFORMS" "Document columns by reading FORMS fields comments" 
			CALL fill_in_column_doc_from_translation () 

		COMMAND KEY (tab) "View Columns Doc" "Browse columns documentation for this table" 
			CALL display_array_column_documentation (pky_table_documentation.*,true) 

		COMMAND KEY (shift-tab) "Modify Columns Doc" "Modify columns documentation for this table" 
			CALL frm_edit_array_column_documentation (pky_table_documentation.*) 

		COMMAND "Next" "Display Next record table_documentation" #@g00113 
			MESSAGE "" 
			CLEAR FORM 
			INITIALIZE frm_z_table_documentation_mngr.* TO NULL 

			IF record_num <= nbsel_table_documentation THEN 
				CALL sql_nxtprev_table_documentation(1) RETURNING record_found, 
				pky_table_documentation.* 

				CASE 
					WHEN record_found = 0 
						ERROR "fetch Last record of this selection table_documentation" 
					WHEN record_found = -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
					WHEN record_found = 1 
						LET record_num = record_num + 1 
						CALL sql_fetch_full_row_table_documentation (pky_table_documentation.*) 
						RETURNING record_found,frm_z_table_documentation_mngr.* 


						CALL frm_display_z_table_documentation_mngr(frm_z_table_documentation_mngr.*) 
						CALL initialize_array_column_documentation() 
						LET arr_elem_num = display_array_column_documentation (pky_table_documentation.*,false) 
						SHOW option "View Columns","Edit Columns" 
						#@G00135


						IF record_num >= nbsel_table_documentation THEN 
							HIDE option "Next" 
						END IF 
						IF record_num > 1 THEN 
							SHOW option "Previous" 
						ELSE 
							HIDE option "Previous" 
						END IF 
				END CASE 
			ELSE 
				ERROR " Please set query criteria previously table_documentation " 
				NEXT option "Query" 
			END IF 
			#@G00151
		COMMAND "Previous" "Display Previous Record table_documentation" 
			MESSAGE "" 
			CLEAR FORM 
			INITIALIZE frm_z_table_documentation_mngr.* TO NULL 


			IF record_num >= 1 THEN 
				CALL sql_nxtprev_table_documentation(-1) RETURNING record_found, 
				pky_table_documentation.* 
				CASE 
					WHEN record_found = 0 
						ERROR "fetch First record of this selection table_documentation" 
					WHEN record_found < -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
					WHEN record_found = 1 
						LET record_num = record_num - 1 
						CALL sql_fetch_full_row_table_documentation (pky_table_documentation.*) 
						RETURNING record_found,frm_z_table_documentation_mngr.* 


						CALL frm_display_z_table_documentation_mngr(frm_z_table_documentation_mngr.*) 
						CALL initialize_array_column_documentation() 
						LET arr_elem_num = display_array_column_documentation (pky_table_documentation.*,false) 
						SHOW option "View Columns","Edit Columns" 
						#@G00175
						IF record_num = 1 THEN 
							HIDE option "Previous" 
						END IF 
						IF record_num < nbsel_table_documentation THEN 
							SHOW option "Next" 
						ELSE 
							HIDE option "Next" 
						END IF 
				END CASE 
			ELSE 
				ERROR " Please set query criteria previously table_documentation " 
				NEXT option "Query" 
			END IF 


		COMMAND "Exit" "Exit program" 
			MESSAGE "" 
			EXIT MENU 
	END MENU 
END FUNCTION 


#######################################################################
FUNCTION frm_query_z_table_documentation_mngr() 
	## frm_Query_z_table_documentation_mngr_f_dbschema_documentation : Query By Example on table table_documentation
	## Input selection criteria,
	## prepare the query,
	## open the data set
	DEFINE rec_table_documentation,where_clause STRING 
	DEFINE xnumber,sql_stmt_status INTEGER 
	DEFINE l_pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00252
	END RECORD 
	DEFINE frm_z_table_documentation_mngr t_frm_z_table_documentation_mngr 

	DEFINE reply CHAR(5) 
	LET xnumber = 0 
	MESSAGE "Please input query criteria" 
	# initialize record and display blank
	CLEAR FORM 
	INITIALIZE frm_z_table_documentation_mngr.* TO NULL 
	DISPLAY BY NAME frm_z_table_documentation_mngr.* 

	CONSTRUCT BY NAME where_clause 
	ON table_documentation.tabname, 
	table_documentation.tabtype, 
	table_documentation.usage_bmlist,
	table_documentation.language_code, 
	table_documentation.documentation, 
	table_documentation.mtime, 
	column_documentation.colname, 
	# column_documentation.data_type,    # we'll see that one later, since data display is different from data stored in table
	column_documentation.col_documentation, 
	column_documentation.mtime 

	## Check whether criteria have been entered
		AFTER CONSTRUCT 
			IF NOT field_touched(table_documentation.*) AND NOT int_flag THEN 
				LET reply = fgl_winbutton("","Select all rows, are you sure?","Yes","Yes|No","question",0) 
				CASE 
					WHEN reply matches "Yes" 
						EXIT CONSTRUCT 
					OTHERWISE # saisie d'un critere de selection 
						ERROR "Please input a least one criteria" 
						CONTINUE CONSTRUCT 
				END CASE 
			END IF 
	END CONSTRUCT 


	IF int_flag = true THEN 
		MESSAGE "Quit with quit key" 
		LET int_flag=0 
	ELSE 
		LET xnumber = sql_get_qbe_count_table_documentation(where_clause) 
		IF xnumber > 0 THEN 
			LET sql_stmt_status = sql_opn_pky_scr_curs_table_documentation(where_clause) 
		ELSE 
			RETURN -1 
		END IF 


	END IF 
	RETURN xnumber 
END FUNCTION ## query_table_documentation 


#######################################################################
# frm_Display_z_table_documentation_mngr_f_dbschema_documentation : displays the form record after reading and displays lookup records if any
# inbound: Form record.*
FUNCTION frm_display_z_table_documentation_mngr(frm_z_table_documentation_mngr) 
	DEFINE frm_z_table_documentation_mngr t_frm_z_table_documentation_mngr 
	DEFINE table_formonly RECORD 
		nrows INTEGER 
	END RECORD 
	DEFINE match_rslt util.match_results
	DEFINE l_usage_bmlist LIKE table_documentation.usage_bmlist
	DEFINE arr_usage_bmlist DYNAMIC ARRAY OF CHAR(3)

	# Fetch current number of rows in the table
	SELECT p.nrows INTO table_formonly.nrows 
	FROM sysmaster:sysptnhdr p,systables t 
	WHERE t.tabname = frm_z_table_documentation_mngr.tabname 
	AND hex(t.partnum) = p.partnum 

	CLEAR FORM
	# using the new function arrayname.split(char)
	LET  arr_usage_bmlist = frm_z_table_documentation_mngr.usage_bmlist.split (",")
 
		
	DISPLAY BY NAME frm_z_table_documentation_mngr.*, table_formonly.nrows 
	DISPLAY arr_usage_bmlist TO usage_bmlist

END FUNCTION # frm_display_z_table_documentation_mngr_f_dbschema_documentation 

####################################################################
## frm_Insert_z_table_documentation_mngr_f_dbschema_documentation: add a new table_documentation row
FUNCTION frm_insert_z_table_documentation_mngr() 
	DEFINE sql_stmt_status SMALLINT 
	DEFINE rows_count SMALLINT 
	DEFINE nbre_table_documentation ,action SMALLINT 
	DEFINE frm_z_table_documentation_mngr t_frm_z_table_documentation_mngr 
	DEFINE tbl_z_table_documentation_mngr t_tbl_z_table_documentation_mngr
	DEFINE l_usage_bmlist LIKE table_documentation.usage_bmlist
	DEFINE arr_usage_bmlist DYNAMIC ARRAY OF CHAR(3)
	DEFINE match_rslt util.match_results

	CLEAR FORM 
	INITIALIZE frm_z_table_documentation_mngr.* TO NULL 


	WHILE true 
		LET int_flag = false
		--LET l_usage_bmlist=frm_z_table_documentation_mngr.usage_bmlist
		LET  arr_usage_bmlist = frm_z_table_documentation_mngr.usage_bmlist.split (",")
		--WHILE length(l_usage_bmlist clipped) > 1
			--LET match_rslt = util.regex.search(l_usage_bmlist,/(\w+)/)
			--IF match_rslt = false THEN
				--EXIT WHILE
			--END IF
			--CALL arr_usage_bmlist.append(match_rslt.str(1))
			--LET l_usage_bmlist = match_rslt.suffix()
		--END WHILE 
		INPUT BY NAME frm_z_table_documentation_mngr.tabname, 
		frm_z_table_documentation_mngr.language_code,
		frm_z_table_documentation_mngr.usage_bmlist,
		frm_z_table_documentation_mngr.tabtype,
		frm_z_table_documentation_mngr.documentation, 
		frm_z_table_documentation_mngr.mtime 

		#@G00334
		WITHOUT DEFAULTS 
 
					
		AFTER FIELD tabname 
				IF frm_z_table_documentation_mngr.tabname IS NULL THEN 
					ERROR "This field is required" 
					NEXT FIELD tabname 
				END IF 
				IF sql_status_pk_table_documentation(frm_z_table_documentation_mngr.language_code,frm_z_table_documentation_mngr.tabname) THEN 
					ERROR "table_documentation: already exists" 
					NEXT FIELD tabname 
				END IF 
			AFTER FIELD language_code 
				IF frm_z_table_documentation_mngr.language_code IS NULL THEN 
					ERROR "This field is required" 
					NEXT FIELD language_code 
				END IF 
				IF sql_status_pk_table_documentation(frm_z_table_documentation_mngr.language_code,frm_z_table_documentation_mngr.tabname) THEN 
					ERROR "table_documentation: already exists" 
					NEXT FIELD language_code 
				END IF 
				#@G00353


				#@G00354
				#@G00354
		END INPUT 
		IF int_flag = true THEN 
			# Resign from input
			LET int_flag=false 
			DISPLAY BY NAME frm_z_table_documentation_mngr.* 
			MESSAGE "Quit with quit key Control-C" 
			EXIT WHILE 
		END IF 


		CALL confirm_operation(3,10,"Insert") RETURNING ACTION 
		CASE ACTION 
			WHEN 0 # i want TO edit the input, remains displayed 'as is' 
				CONTINUE WHILE # ON laisse tout affiche comme tel 


			WHEN 2 # ON valide la transaction 
				BEGIN WORK 
					#@G00370
					CALL set_table_record_f_dbschema_documentation_table_documentation('+',frm_z_table_documentation_mngr.*) 
					RETURNING tbl_z_table_documentation_mngr.* 
					CALL sql_insert_table_documentation(tbl_z_table_documentation_mngr.*) 
					RETURNING sql_stmt_status, tbl_z_table_documentation_mngr.tabname,tbl_z_table_documentation_mngr.language_code 
					#@G00374


					CASE 
						WHEN sql_stmt_status = 0 
							MESSAGE "Insert table_documentation Successful operation" 
						COMMIT WORK 
						#@G00379
						WHEN sql_stmt_status < 0 
							CALL display_error_and_decide("Insert table_documentation:failed",sqlerrmessage,"") 
							ROLLBACK WORK 
							#@G00382
					END CASE 
					EXIT WHILE 


			WHEN 0 
				ROLLBACK WORK 
				#@G00387
				EXIT WHILE 
		END CASE 
	END WHILE 
	# tbl_z_table_documentation_mngr
	RETURN sql_stmt_status, tbl_z_table_documentation_mngr.tabname,tbl_z_table_documentation_mngr.language_code 
	#@G00392
END FUNCTION ## frm_insert_z_table_documentation_mngr_f_dbschema_documentation 




#######################################################################
# frm_Edit_z_table_documentation_mngr_f_dbschema_documentation : Edit a table_documentation RECORD
# inbound: table primary key
FUNCTION frm_edit_z_table_documentation_mngr(pky,frm_z_table_documentation_mngr) 
	DEFINE ACTION SMALLINT 
	DEFINE sql_stmt_status,dummy SMALLINT 
	DEFINE tbl_z_table_documentation_mngr t_tbl_z_table_documentation_mngr 
	DEFINE frm_z_table_documentation_mngr t_frm_z_table_documentation_mngr 
	DEFINE sav_z_table_documentation_mngr t_tbl_z_table_documentation_mngr 
	DEFINE rows_count,elem_num SMALLINT 
	DEFINE pky t_pky_table_documentation 
	DEFINE arr_usage_bmlist DYNAMIC ARRAY OF CHAR(3)
	DEFINE match_rslt util.match_results
	DEFINE l_usage_bmlist LIKE table_documentation.usage_bmlist

	## check if record can be accessed
	WHILE true 
		LET int_flag = false
		LET l_usage_bmlist=frm_z_table_documentation_mngr.usage_bmlist
		--WHILE length(l_usage_bmlist clipped) > 1
			--LET match_rslt = util.regex.search(l_usage_bmlist,/(\w+)/)
			--IF match_rslt = false THEN
				--EXIT WHILE
			--END IF
			--CALL arr_usage_bmlist.append(match_rslt.str(1))
			--LET l_usage_bmlist = match_rslt.suffix()
		--END WHILE
		LET  arr_usage_bmlist = frm_z_table_documentation_mngr.usage_bmlist.split (",")
		DISPLAY arr_usage_bmlist TO usage_bmlist
		# Save Screen Record values before altering
		LET sav_z_table_documentation_mngr.* = frm_z_table_documentation_mngr.* 
		BEGIN WORK 
			EXECUTE immediate "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS" 
			WHENEVER SQLERROR CONTINUE 
			OPEN crs_upd_table_documentation USING pky.* 
			FETCH crs_upd_table_documentation INTO dummy 
			IF sqlca.sqlcode = -244 THEN ERROR "THIS ROW IS BEING MODIFIED" 
				ROLLBACK WORK 
				EXIT WHILE 
			END IF 
			WHENEVER SQL ERROR CALL kandoo_sql_errors_handler
			{  
			--INPUT arr_usage_bmlist WITHOUT DEFAULTS FROM usage_bmlist
				ON CHANGE "usage_bmlist"
					# concatenate the array into the frm_z_table_documentation_mngr.usage_bmlist variable
					INITIALIZE frm_z_table_documentation_mngr.usage_bmlist TO NULL
					LET frm_z_table_documentation_mngr.usage_bmlist = arr_usage_bmlist.Join(",")
					--FOR elem_num = 1 TO arr_usage_bmlist.getSize()
						--LET frm_z_table_documentation_mngr.usage_bmlist = frm_z_table_documentation_mngr.usage_bmlist clipped,arr_usage_bmlist[elem_num],","
					--END FOR
			END INPUT
}
			INPUT arr_usage_bmlist, 
				frm_z_table_documentation_mngr.tabtype,
				frm_z_table_documentation_mngr.documentation
			WITHOUT DEFAULTS
			FROM  usage_bmlist,
				tabtype,
				documentation
				ON CHANGE "usage_bmlist"
					INITIALIZE frm_z_table_documentation_mngr.usage_bmlist TO NULL
					LET frm_z_table_documentation_mngr.usage_bmlist = arr_usage_bmlist.Join(",")
					
				ON CHANGE "documentation" 
					LET frm_z_table_documentation_mngr.mtime = CURRENT 
					DISPLAY BY NAME frm_z_table_documentation_mngr.mtime 
					 
			END INPUT 
			IF int_flag = true THEN 
				LET int_flag=false 
				# Restore previous value
				LET frm_z_table_documentation_mngr.* = sav_z_table_documentation_mngr.* 
				DISPLAY BY NAME frm_z_table_documentation_mngr.* 
				#@G00441
				EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
				ROLLBACK WORK 
				MESSAGE "Cancelled INPUT" 
				EXIT WHILE 
			END IF 


				CALL confirm_operation(4,10,MODE_CLASSIC_EDIT) RETURNING ACTION 


				CASE 
					WHEN ACTION = 0 
						# Redo, leave values as modified
						CONTINUE WHILE 
					WHEN ACTION = 1 
						# Resign, restore original values
						LET frm_z_table_documentation_mngr.* = sav_z_table_documentation_mngr.* 
						DISPLAY BY NAME frm_z_table_documentation_mngr.* 
						EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
						ROLLBACK WORK 
						EXIT WHILE # CANCEL operation 


					WHEN ACTION = 2 
						# confirm update
						CALL set_table_record_f_dbschema_documentation_table_documentation("#",frm_z_table_documentation_mngr.*) 
						RETURNING tbl_z_table_documentation_mngr.* 


						# Perform the prepared update statement
						LET sql_stmt_status = sql_edit_table_documentation(pky.*,tbl_z_table_documentation_mngr.*) 
						CASE 
							WHEN sql_stmt_status = 0 
								MESSAGE "Edit table_documentation Successful operation" 
								EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
							COMMIT WORK 
							#@G00473
							WHEN sql_stmt_status < 0 
								CALL display_error_and_decide("Edit table_documentation:failed",sqlerrmessage,"")  
								EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
								ROLLBACK WORK 
								#@G00477
						END CASE 
						EXIT WHILE 
				END CASE 
			END WHILE 
			RETURN sql_stmt_status 
END FUNCTION ## frm_edit_z_table_documentation_mngr(pky) 




#######################################################################
# DELETE A table_documentation row
# inbound: table primary key
FUNCTION frm_delete_z_table_documentation_mngr(pky) 
	DEFINE ACTION SMALLINT 
	DEFINE dummy SMALLINT 
	DEFINE sql_stmt_status SMALLINT 
	DEFINE pky t_pky_table_documentation 

	WHILE true 
		CALL confirm_operation(5,10,"Delete") RETURNING ACTION 
		BEGIN WORK 
			EXECUTE immediate "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS" 
			WHENEVER SQLERROR CONTINUE 
			OPEN crs_upd_table_documentation USING pky.* 
			FETCH crs_upd_table_documentation INTO dummy 
			IF sqlca.sqlcode = -244 THEN ERROR "THIS ROW IS BEING MODIFIED" 
				ROLLBACK WORK 
				EXIT WHILE 
			END IF 
				WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
				#@G00506
				CASE 
					WHEN ACTION = 0 OR ACTION = 1 
						# can the delete operation
						EXIT WHILE 
					WHEN ACTION = 2 
						# Validate the delete operation
						CALL sql_delete_table_documentation(pky.*) RETURNING sql_stmt_status 
						CASE 
							WHEN sql_stmt_status = 0 
								MESSAGE "Delete table_documentation Successful operation" 
							COMMIT WORK 
							#@G00517


							WHEN sql_stmt_status < 0 
								CALL display_error_and_decide("Delete table_documentation:failed",sqlerrmessage,"")
								ROLLBACK WORK 
								#@G00521
						END CASE 
						EXIT WHILE 
				END CASE 
			END WHILE 
			RETURN sql_stmt_status 
END FUNCTION ## frm_delete_z_table_documentation_mngr(pky) 


#########################################################################
#  Build, prepare, declare and initialize main queries and cursors
FUNCTION sql_prepare_queries_z_table_documentation_mngr_table_documentation () 
	DEFINE query_text STRING 


	# PREPARE cursor for full master table row contents, access by primary key
	LET query_text= 
	"SELECT tabname,tabtype,usage_bmlist,language_code,documentation,mtime 
	", #@G00536 
	" FROM table_documentation ", 
	"WHERE tabname = ? 
	AND language_code = ? " #@G00539 


	PREPARE sel_mrw_table_documentation FROM query_text 
	DECLARE crs_row_table_documentation CURSOR FOR sel_mrw_table_documentation 


	# PREPARE cursor for row test / check if locked
	LET query_text= "SELECT tabname,language_code 
	", #@G00545 
	" FROM table_documentation ", 
	" WHERE tabname = ? 
	AND language_code = ? " #@G00548 


	PREPARE sel_pky_table_documentation FROM query_text 
	DECLARE crs_pky_table_documentation CURSOR FOR sel_pky_table_documentation 


	# PREPARE cursor for SELECT FOR UPDATE
	LET query_text= "SELECT tabname,language_code 
	", #@G00554 
	" FROM table_documentation ", 
	" WHERE tabname = ? 
	AND language_code = ? ", #@G00557 
	" FOR UPDATE" 


	PREPARE sel_upd_table_documentation FROM query_text 
	DECLARE crs_upd_table_documentation CURSOR FOR sel_upd_table_documentation 


	# PREPARE INSERT statement
	LET query_text = 
	"INSERT INTO table_documentation ( tabname,tabtype,usage_bmlist,language_code,documentation,mtime 
	)", #@G00565 
	" VALUES ( ?,?,?,?,?,? 
	)" #@G00566 
	PREPARE pr_ins_table_documentation FROM query_text 


	# PREPARE UPDATE statement
	LET query_text= 
	"UPDATE table_documentation ", 
	"SET ( tabtype,usage_bmlist,documentation,mtime	)",  
	" = ( ?,?,?,? )", #@G00573 
	" WHERE tabname = ? 
	AND language_code = ? " #@G00575 
	PREPARE pr_upd_table_documentation FROM query_text 


	# PREPARE DELETE statement
	LET query_text= "DELETE FROM table_documentation ", 
	" WHERE tabname = ? 
	AND language_code = ? " #@G00581 


	PREPARE pr_del_table_documentation FROM query_text 


END FUNCTION ## sql_prepare_queries_z_table_documentation_mngr_table_documentation 




#########################################################
# Open the QBE cursor,
# counts returned rows_count,
# open the data set,
# fetch first row
# inbound parameter: query predicate
# outbound parameters: number of rows retried
FUNCTION sql_get_qbe_count_table_documentation(where_clause) 
	DEFINE where_clause STRING 
	DEFINE join_clause STRING 
	DEFINE rec_table_documentation STRING 
	DEFINE tables_list STRING 
	DEFINE rows_count INTEGER 
	DEFINE lsql_stmt_status INTEGER 
	DEFINE regexp,regexp_quotes util.regex 
	DEFINE match util.match_results 


	# define primary_key record
	DEFINE l_pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00603
	END RECORD 

	LET tables_list = "table_documentation" 
	LET match = util.regex.search(where_clause,/\b(column_documentation)\.(\w+)/) 
	IF (match) THEN 
		LET tables_list = tables_list,",",match.str(1) 
		LET join_clause = "AND table_documentation.tabname = column_documentation.tabname " 
	END IF 
	LET rec_table_documentation = 
	"SELECT count(distinct(table_documentation.tabname)) FROM ", tables_list, 
	" WHERE ",where_clause clipped, 
	join_clause clipped 

	PREPARE prp_cnt_table_documentation FROM rec_table_documentation 
	DECLARE crs_cnt_table_documentation CURSOR FOR prp_cnt_table_documentation 


	OPEN crs_cnt_table_documentation 
	SET ISOLATION TO dirty read 
	WHENEVER SQLERROR CONTINUE 
	FETCH crs_cnt_table_documentation INTO rows_count 
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	SET ISOLATION TO committed read 


	# if FETCH fails, count = 0, the, get back to query
	IF sqlca.sqlcode OR rows_count = 0 THEN 
		LET rows_count =0 
	END IF 
	FREE crs_cnt_table_documentation 
	RETURN rows_count 
END FUNCTION ## sql_get_qbe_count_table_documentation 


#########################################################
FUNCTION sql_opn_pky_scr_curs_table_documentation(where_clause) 
	## Build the query generated by CONSTRUCT BY NAME,
	## Declare and open the cursor
	## inbound param: query predicate
	## outbound parameter: query status
	DEFINE where_clause STRING 
	DEFINE join_clause STRING 
	DEFINE rec_table_documentation STRING 
	DEFINE rows_count INTEGER 
	DEFINE lsql_stmt_status INTEGER 
	DEFINE tables_list STRING 
	DEFINE regexp,regexp_quotes util.regex 
	DEFINE match util.match_results 



	# define primary_key record
	DEFINE l_pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00642
	END RECORD 


	# display the selected columns
	LET tables_list = "table_documentation" 
	LET match = util.regex.search(where_clause,/\b(column_documentation)\.(\w+)/) 
	IF (match) THEN 
		LET tables_list = tables_list,",",match.str(1) 
		LET join_clause = " AND table_documentation.tabname = column_documentation.tabname " 
	END IF 

	LET rec_table_documentation = "SELECT distinct table_documentation.tabname,table_documentation.language_code ", #@g00647 
	" FROM ",tables_list, 
	" WHERE ",where_clause clipped,join_clause clipped, 
	" ORDER BY table_documentation.tabname,table_documentation.language_code " 

	PREPARE rech_crs_ FROM rec_table_documentation 


	# crs_scrl_crs_ : the first cursor selects all the primary keys (not all the table columns)


	DECLARE crs_scrl_crs_ SCROLL CURSOR with HOLD 
	FOR rech_crs_ #@g00656 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_scrl_crs_ 
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 


	RETURN sqlca.sqlcode 
END FUNCTION ## sql_opn_pky_scr_curs_table_documentation 


#######################################################################
FUNCTION sql_nxtprev_table_documentation(offset) 
	## sql_nxtprev_table_documentation : FETCH NEXT OR PREVIOUS RECORD
	DEFINE offset SMALLINT 
	DEFINE lsql_stmt_status,record_found INTEGER 
	DEFINE pky t_pky_table_documentation 
	DEFINE frm_z_table_documentation_mngr t_frm_z_table_documentation_mngr 

	WHENEVER SQLERROR CONTINUE 
	FETCH relative offset crs_scrl_crs_ INTO pky.* 
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 


	CASE 
		WHEN sqlca.sqlcode = 100 
			LET record_found = 0 


		WHEN sqlca.sqlcode < 0 
			LET record_found = -1 
		OTHERWISE 
			LET lsql_stmt_status = 1 
			LET record_found = 1 
			#CALL sql_fetch_full_row_table_documentation (pky.*)
			#RETURNING record_found,frm_z_table_documentation_mngr.*


	END CASE 
	RETURN record_found,pky.* 
END FUNCTION ## sql_nxtprev_table_documentation 


#########################################################################################
FUNCTION sql_fetch_full_row_table_documentation(pky_table_documentation) 
	# sql_fetch_full_row_table_documentation : read a complete row accessing by primary key
	# inbound parameter : primary key
	# outbound parameter: sql_stmt_status and row contents
	DEFINE sql_stmt_status SMALLINT 
	DEFINE pky_table_documentation t_pky_table_documentation 
	DEFINE tbl_z_table_documentation_mngr t_tbl_z_table_documentation_mngr 
	DEFINE frm_z_table_documentation_mngr t_frm_z_table_documentation_mngr 

	# read the table, access on primary key
	WHENEVER SQLERROR CONTINUE 
	OPEN crs_row_table_documentation 
	USING pky_table_documentation.* 


	FETCH crs_row_table_documentation INTO tbl_z_table_documentation_mngr.* 


	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	CASE 
		WHEN sqlca.sqlcode = 100 
			LET sql_stmt_status = 0 
		WHEN sqlca.sqlcode < 0 
			LET sql_stmt_status = -1 
		OTHERWISE 
			LET sql_stmt_status = 1 
			CALL set_form_record_z_table_documentation_mngr(tbl_z_table_documentation_mngr.*) 
			RETURNING frm_z_table_documentation_mngr.* 
	END CASE 
	RETURN sql_stmt_status,frm_z_table_documentation_mngr.* 
END FUNCTION ## sql_fetch_full_row_table_documentation 


########################################################################
FUNCTION sql_insert_table_documentation(tbl_z_table_documentation_mngr) 
	## INSERT in table table_documentation
	DEFINE lsql_stmt_status INTEGER 
	DEFINE rows_count SMALLINT 
	DEFINE pky t_pky_table_documentation 
	DEFINE tbl_z_table_documentation_mngr t_tbl_z_table_documentation_mngr 
 
	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_ins_table_documentation 
	USING tbl_z_table_documentation_mngr.tabname, 
	tbl_z_table_documentation_mngr.tabtype,
	tbl_z_table_documentation_mngr.usage_bmlist, 
	tbl_z_table_documentation_mngr.language_code, 
	tbl_z_table_documentation_mngr.documentation, 
	tbl_z_table_documentation_mngr.mtime 
	#@G00748
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 


	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status = 0 
		#@G00755


	END IF 
	RETURN lsql_stmt_status,pky.* 
END FUNCTION ## sql_insert_table_documentation 


########################################################################
FUNCTION sql_edit_table_documentation(pky,tbl_z_table_documentation_mngr) 
	## sql_Edit_table_documentation :update table_documentation record
	DEFINE lsql_stmt_status INTEGER 
	DEFINE pky t_pky_table_documentation 
	DEFINE tbl_z_table_documentation_mngr t_tbl_z_table_documentation_mngr 

	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_upd_table_documentation 
	USING tbl_z_table_documentation_mngr.tabtype, 
	tbl_z_table_documentation_mngr.usage_bmlist,
	tbl_z_table_documentation_mngr.documentation, 
	tbl_z_table_documentation_mngr.mtime 
	, #@g00774 
	pky.* 


	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	IF sqlca.sqlcode < 0 THEN 


		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status = 0 
	END IF 
	RETURN lsql_stmt_status 
END FUNCTION ## sql_edit_table_documentation 


##############################################################################################
FUNCTION sql_delete_table_documentation(pky) 
	## sql_Delete_table_documentation :delete current row in table table_documentation
	DEFINE lsql_stmt_status SMALLINT 
	DEFINE pky t_pky_table_documentation 
	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_del_table_documentation 
	USING pky.* 


	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 
	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status=0 
	END IF 
	RETURN lsql_stmt_status 
END FUNCTION ## sql_delete_table_documentation 


################################################################################
FUNCTION sql_status_pk_table_documentation(pky) 
	##   sql_status_pk_table_documentation : Check if primary key exists
	## inbound parameter : record of primary key
	## outbound parameter:  status > 0 if exists, 0 if no record, < 0 if error
	DEFINE pky t_pky_table_documentation 
	DEFINE pk_status INTEGER 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_pky_table_documentation USING pky.* 
	FETCH crs_pky_table_documentation 
	WHENEVER SQL ERROR CALL kandoo_sql_errors_handler 


	CASE sqlca.sqlcode 
		WHEN 0 
			LET pk_status = 1 
		WHEN 100 
			LET pk_status = 0 
		WHEN sqlca.sqlerrd[2] = 104 
			LET pk_status = -1 # RECORD locked 
		WHEN sqlca.sqlcode < 0 
			LET pk_status = sqlca.sqlcode 
	END CASE 


	RETURN pk_status 
END FUNCTION ## sql_status_pk_table_documentation 


################################################################################################
FUNCTION set_form_record_z_table_documentation_mngr(tbl_contents) 
	## set_form_record_z_table_documentation_mngr_f_dbschema_documentation: assigns table values to form fields values
	DEFINE frm_contents t_frm_z_table_documentation_mngr 
	DEFINE tbl_contents t_tbl_z_table_documentation_mngr 

	INITIALIZE frm_contents.* TO NULL 
	LET frm_contents.tabname = tbl_contents.tabname 
	LET frm_contents.tabtype = tbl_contents.tabtype
	LET frm_contents.usage_bmlist = tbl_contents.usage_bmlist 
	LET frm_contents.language_code = tbl_contents.language_code 
	LET frm_contents.documentation = tbl_contents.documentation 
	LET frm_contents.mtime = tbl_contents.mtime 
	#@G00854
	RETURN frm_contents.* 
END FUNCTION ## set_form_recordz_table_documentation_mngr_f_dbschema_documentation 


################################################################################################
FUNCTION set_table_record_f_dbschema_documentation_table_documentation(sql_stmt,frm_contents) 
	## set_table_record_f_dbschema_documentation_table_documentation: assigns form fields value to table values
	DEFINE sql_stmt CHAR(1) # + => insert, # => UPDATE 
	DEFINE pky t_pky_table_documentation 
	DEFINE frm_contents t_frm_z_table_documentation_mngr 
	DEFINE tbl_contents t_tbl_z_table_documentation_mngr 

	INITIALIZE tbl_contents.* TO NULL 
	CASE sql_stmt 
		WHEN "+" # PREPARE RECORD FOR INSERT 
			LET tbl_contents.tabname = frm_contents.tabname 
			LET tbl_contents.tabtype = frm_contents.tabtype
			LET tbl_contents.usage_bmlist = frm_contents.usage_bmlist 
			LET tbl_contents.language_code = frm_contents.language_code 
			LET tbl_contents.documentation = frm_contents.documentation 
			LET tbl_contents.mtime = frm_contents.mtime 
			#@G00882
		WHEN "#" # PREPARE RECORD FOR UPDATE 
			LET tbl_contents.tabtype = frm_contents.tabtype 
			LET tbl_contents.usage_bmlist = frm_contents.usage_bmlist
			LET tbl_contents.documentation = frm_contents.documentation 
			LET tbl_contents.mtime = frm_contents.mtime 
			#@G00887
	END CASE 


	RETURN tbl_contents.* 
END FUNCTION ## set_table_recordf_dbschema_documentation_table_documentation 

FUNCTION insert_new_tables() 
	# tables that exist but are not documented in table_documentation
	DEFINE l_tabname LIKE systables.tabname 
	DEFINE nbr_tables,nbr_columns SMALLINT 
	DEFINE l_rec_column_documentation RECORD LIKE column_documentation.* 

	SELECT count(*) 
	INTO nbr_tables 
	FROM systables 
	WHERE tabname NOT in (SELECT tabname FROM table_documentation ) 
	AND tabid > 120 
	AND tabname NOT matches "sys*" 
	AND tabtype = "T" 

	IF nbr_tables > 0 THEN 
		DECLARE crs_undocumented_tables CURSOR FOR 
		SELECT tabname 
		FROM systables 
		WHERE tabname NOT in (SELECT tabname FROM table_documentation ) 
		AND tabid > 120 
		AND tabname NOT matches "sys*" 
		AND tabtype = "T" 

		LET nbr_tables = 0 
		FOREACH crs_undocumented_tables INTO l_tabname 
			LET nbr_tables = nbr_tables + 1 
			INSERT INTO table_documentation ( tabname,tabtype,language_code,documentation,mtime ) 
			VALUES (l_tabname,"table","ENU","documentation OF "||l_tabname,current ) 
		END FOREACH 
		FREE crs_undocumented_tables 
	END IF 

	DECLARE crs_undocumented_columns CURSOR FOR 
	SELECT t.tabname,c.colname,"ENU",c.colno,"documentation of " || c.colname,current 
	FROM syscolumns c,systables t 
	WHERE c.tabid=t.tabid 
	AND c.tabid > 120 
	AND t.tabname NOT matches "sys*" 
	AND t.tabtype = "T" 
	AND NOT exists ( SELECT 1 FROM column_documentation d WHERE t.tabname = d.tabname AND c.colname = d.colname ) 

	FOREACH crs_undocumented_columns INTO l_rec_column_documentation.* 
		LET nbr_columns = nbr_columns + 1 
		INSERT INTO column_documentation 
		VALUES (l_rec_column_documentation.*) 
	END FOREACH 
	FREE crs_undocumented_columns 


	RETURN nbr_tables,nbr_columns 

END FUNCTION 

FUNCTION insert_new_columns () 
END FUNCTION 


# this function looks for the explainations of the fields found in the FORMS, widgets 'comments'
# this table is filled by a perl utility called XXX
# Although not exact science, this allows to found some explaination to what this field (column) is expected to be filled with
# since the colum can appear in many forms, we take the first occurrence

FUNCTION fill_in_column_doc_from_translation () 
	DEFINE r_column_doc RECORD LIKE column_documentation.* 
	DEFINE r_table_doc RECORD LIKE table_documentation.* 
	DEFINE r_form_attributes RECORD LIKE form_attributes.* 
	DEFINE r_attributes_translation RECORD LIKE attributes_translation.* 
	DEFINE former_key,current_key,qry_stmt STRING 
	DEFINE a,total_messages INTEGER 

	# first search for columns that have been added but still have the generic description message
	# and insert into a temp table

	SELECT tabname,colname 
	FROM column_documentation 
	WHERE documentation matches "documentation for column*" 
	INTO temp t_undocumented_columns 

	# Then select tables/columns that have a comments in translation that have the "undocumented" description
	DECLARE crs_form_attributes CURSOR FOR 
	SELECT f.table_name,f.widget_id,t.translation,t.language,t.modif_timestamp 
	FROM form_attributes f,attributes_translation t,t_undocumented_columns u 
	WHERE t.attribute_id = f.attribute_id 
	AND table_name IS NOT NULL 
	AND table_name = u.tabname 
	AND f.widget_id = u.colname 
	AND lower(table_name) NOT matches "formonly" 
	AND f.attribute_type = "comment" 
	AND t.language = "ENU" 
	GROUP BY 1,2,3,4,5 
	ORDER BY 1,2,3 

	# only update if the field has not been described yet (i.e. still has the generic "documentation for column" description
	LET qry_stmt = "UPDATE column_documentation SET (col_documentation,mtime) = (?,?) WHERE tabname = ? and colname = ? ", 
	"and language_code = ? and col_documentation matches \"documentation FOR column*\"" 
	PREPARE p_upd_column_documentation FROM qry_stmt 

	LET former_key = "xxxxxxxxx" 
	FOREACH crs_form_attributes 
		INTO r_form_attributes.table_name,r_form_attributes.widget_id, 
		r_attributes_translation.translation,r_attributes_translation.language,r_attributes_translation.modif_timestamp 
		LET current_key = r_form_attributes.table_name CLIPPED,":",r_form_attributes.widget_id 
		IF current_key = former_key THEN 
			CONTINUE FOREACH 
		ELSE 
			LET former_key = current_key 
		END IF 
		CALL util.regex.replace(r_attributes_translation.translation,/^\s+|^\s*enter /i,"") RETURNING r_column_doc.col_documentation 
		LET r_column_doc.tabname = r_form_attributes.table_name 
		LET r_column_doc.colname = r_form_attributes.widget_id 
		LET r_column_doc.language_code = r_attributes_translation.language 
		LET r_column_doc.mtime = r_attributes_translation.modif_timestamp 

		DISPLAY r_column_doc.* 
		EXECUTE p_upd_column_documentation USING r_column_doc.col_documentation,r_column_doc.tabname,r_column_doc.colname,r_column_doc.language_code,r_column_doc.mtime 
		LET total_messages = total_messages + 1 
		LET a=1 
	END FOREACH 
	DISPLAY "TOtal MESSAGEs: ",total_MESSAGEs 
END FUNCTION 
