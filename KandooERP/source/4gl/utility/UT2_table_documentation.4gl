# module generated by KandooERP Ffg(c)
# Generated on 2019-11-05 19:55:27
# Main template I:\Users\BeGooden-IT\git\KandooERP\KandooERP\Resources\Utilities\Perl\Ffg/templates/module/parent-form-basic.mtplt


#@G00005
############################################################
# GLOBAL Scope Variables
############################################################
GLOBALS "../common/glob_GLOBALS.4gl" 
DEFINE m_program CHAR(30) 


#@G00009
DEFINE g_table_documentation RECORD LIKE table_documentation.* 


MAIN 
	#Initial UI Init
	CALL setModuleId("UT2") 
	CALL ui_init(0) #initial ui init 

	DEFER quit 
	DEFER interrupt 

	CALL authenticate(getmoduleid()) #authenticate 
	CALL init_u_ut() #init utility module 


	#@G00014
	# WHENEVER SQLERROR CALL error_mngmt
	# CALL ui_init(0)
	LET m_program="p_z_table_documentation_mngr_table_documentation" 


	CALL main_z_table_documentation_mngr_table_documentation() 


END MAIN 


##########################################################################
FUNCTION mc_z_table_documentation_mngr_sccs() 
	## definition variable sccs
	DEFINE sccs_var CHAR(70) 
	LET sccs_var="%W% %D%" 
END FUNCTION 
##########################################################################
FUNCTION main_z_table_documentation_mngr_table_documentation () 
	## this module's main function called by MAIN

	OPEN WINDOW f_dbschema_documentation with FORM "U801_table_documentation" 
	CALL windecoration_u("U802_table_documentation") #@g00034 


	CALL sql_prepare_queries_z_table_documentation_mngr_table_documentation () # INITIALIZE all cursors ON master TABLE 
	CALL sql_prepare_queries_z_table_documentation_mngr_column_documentation() 
	#@G00037


	CALL menu_z_table_documentation_mngr_table_documentation() 


	CLOSE WINDOW f_dbschema_documentation 


END FUNCTION 


######################################################################
FUNCTION menu_z_table_documentation_mngr_table_documentation () 
	## menu_z_table_documentation_mngr_table_documentation
	## the top level menu
	## input arguments: none
	## output arguments: none
	DEFINE nbsel_table_documentation INTEGER 
	DEFINE sql_stmt_status INTEGER 
	DEFINE record_num INTEGER 
	DEFINE ACTION SMALLINT 
	DEFINE xnumber SMALLINT 
	DEFINE arr_elem_num SMALLINT 
	DEFINE pky_table_documentation RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00058
	END RECORD 
	DEFINE frm_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00061
	END RECORD 


	DEFINE tbl_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00065
	END RECORD 


	DEFINE record_found INTEGER 
	DEFINE lookup_status INTEGER 


	LET nbsel_table_documentation = 0 
	MENU "table_documentation" 
		BEFORE MENU 
			HIDE option "INSERT","EDIT","DELETE" 
			HIDE option "Modify Table Doc","Next","Previous","View Columns","Edit Columns" 

		COMMAND "Query" "Query data with multiple criteria table_documentation" 
			#@G00075
			MESSAGE "" 
			INITIALIZE frm_z_table_documentation_mngr.* TO NULL 
			CLEAR FORM 
			DISPLAY BY NAME frm_z_table_documentation_mngr.* 
			HIDE option "Next","Previous" 


			CALL frm_query_z_table_documentation_mngr() RETURNING nbsel_table_documentation 
			IF nbsel_table_documentation > 0 THEN 
				CALL sql_nxtprev_table_documentation(1) RETURNING record_found, 
				pky_table_documentation.* 


				CASE 
					WHEN record_found = 1 
						LET record_num = 1 
						CALL sql_fetch_full_row_table_documentation (pky_table_documentation.*) 
						RETURNING record_found,frm_z_table_documentation_mngr.* 

						CALL frm_display_z_table_documentation_mngr(frm_z_table_documentation_mngr.*) 

						CALL initialize_array_column_documentation() 
						LET arr_elem_num = display_array_column_documentation (pky_table_documentation.*,false) 
						SHOW option "Modify Table Doc","View Columns","Edit Columns" 
						#@G00097
					WHEN record_found = -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
				END CASE 
				IF nbsel_table_documentation > 1 THEN 
					SHOW option "Next" 
					NEXT option "Next" 
				END IF 
			ELSE 
				ERROR "No row matches the criteria" 
				NEXT option "Query" 
			END IF 

		COMMAND "EDIT" "Modify current table documentation" #@g00191  
			#HELP 4000		                                                                                                              	#@G00192
			MESSAGE "" #@g00193 
			IF nbsel_table_documentation THEN #@g00194 
				IF sql_status_pk_table_documentation(pky_table_documentation.*) < 0 THEN #@g00195 
					ERROR "IS locked " #@g00196 
					NEXT option "Next" #@g00197 
				ELSE #@g00198 
					LET sql_stmt_status = frm_edit_z_table_documentation_mngr(pky_table_documentation.*) #@g00199 
				END IF #@g00200 
			ELSE #@g00201 
				ERROR " Please SET query criteria previously form_attributes " #@g00202 
				NEXT option "Query" #@g00203 
			END IF #@g00204 

		COMMAND "Check New Tables" "Check New Tables that are not documented" 
			LET record_found=1 

		COMMAND "Check New Columns" "Check New Columns that are not documented" 
			LET record_found=1 

		COMMAND KEY (tab) "View Columns" 
			CALL display_array_column_documentation (pky_table_documentation.*,true) 

		COMMAND KEY (shift-tab) "Edit Columns" 
			CALL frm_edit_array_column_documentation (pky_table_documentation.*,true) 

		COMMAND "Next" "Display Next record table_documentation" #@g00113 
			MESSAGE "" 
			CLEAR FORM 
			INITIALIZE frm_z_table_documentation_mngr.* TO NULL 


			IF record_num <= nbsel_table_documentation THEN 
				CALL sql_nxtprev_table_documentation(1) RETURNING record_found, 
				pky_table_documentation.* 


				CASE 
					WHEN record_found = 0 
						ERROR "fetch Last record of this selection table_documentation" 
					WHEN record_found = -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
					WHEN record_found = 1 
						LET record_num = record_num + 1 
						CALL sql_fetch_full_row_table_documentation (pky_table_documentation.*) 
						RETURNING record_found,frm_z_table_documentation_mngr.* 


						CALL frm_display_z_table_documentation_mngr(frm_z_table_documentation_mngr.*) 
						CALL initialize_array_column_documentation() 
						LET arr_elem_num = display_array_column_documentation (pky_table_documentation.*,false) 
						SHOW option "View Columns","Edit Columns" 
						#@G00135


						IF record_num >= nbsel_table_documentation THEN 
							HIDE option "Next" 
						END IF 
						IF record_num > 1 THEN 
							SHOW option "Previous" 
						ELSE 
							HIDE option "Previous" 
						END IF 
				END CASE 
			ELSE 
				ERROR " Please set query criteria previously table_documentation " 
				NEXT option "Query" 
			END IF 
			#@G00151
		COMMAND "Previous" "Display Previous Record table_documentation" 
			MESSAGE "" 
			CLEAR FORM 
			INITIALIZE frm_z_table_documentation_mngr.* TO NULL 


			IF record_num >= 1 THEN 
				CALL sql_nxtprev_table_documentation(-1) RETURNING record_found, 
				pky_table_documentation.* 
				CASE 
					WHEN record_found = 0 
						ERROR "fetch First record of this selection table_documentation" 
					WHEN record_found < -1 
						ERROR "This row is unreachable ",sqlca.sqlcode 
					WHEN record_found = 1 
						LET record_num = record_num - 1 
						CALL sql_fetch_full_row_table_documentation (pky_table_documentation.*) 
						RETURNING record_found,frm_z_table_documentation_mngr.* 


						CALL frm_display_z_table_documentation_mngr(frm_z_table_documentation_mngr.*) 
						CALL initialize_array_column_documentation() 
						LET arr_elem_num = display_array_column_documentation (pky_table_documentation.*,false) 
						SHOW option "View Columns","Edit Columns" 
						#@G00175
						IF record_num = 1 THEN 
							HIDE option "Previous" 
						END IF 
						IF record_num < nbsel_table_documentation THEN 
							SHOW option "Next" 
						ELSE 
							HIDE option "Next" 
						END IF 
				END CASE 
			ELSE 
				ERROR " Please set query criteria previously table_documentation " 
				NEXT option "Query" 
			END IF 

		COMMAND "Exit" "Exit program" 
			MESSAGE "" 
			EXIT MENU 
	END MENU 
END FUNCTION 


#######################################################################
FUNCTION frm_query_z_table_documentation_mngr() 
	## frm_Query_z_table_documentation_mngr_f_dbschema_documentation : Query By Example on table table_documentation
	## Input selection criteria,
	## prepare the query,
	## open the data set
	DEFINE rec_table_documentation,where_clause STRING 
	DEFINE xnumber,sql_stmt_status INTEGER 
	DEFINE l_pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00252
	END RECORD 
	DEFINE frm_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00255
	END RECORD 


	DEFINE reply CHAR(5) 
	LET xnumber = 0 
	MESSAGE "Please input query criteria" 
	# initialize record and display blank
	CLEAR FORM 
	INITIALIZE frm_z_table_documentation_mngr.* TO NULL 
	DISPLAY BY NAME frm_z_table_documentation_mngr.* 




	CONSTRUCT BY NAME where_clause ON table_documentation.tabname, 
	table_documentation.tabtype, 
	table_documentation.language_code, 
	table_documentation.documentation, 
	table_documentation.mtime 

	#@G00267


	#@G00268


	## Check whether criteria have been entered
		AFTER CONSTRUCT 
			IF NOT field_touched(table_documentation.*) AND NOT int_flag THEN 
				LET reply = fgl_winbutton("","Select all rows, are you sure?","Yes","Yes|No","question",0) 
				CASE 
					WHEN reply matches "Yes" 
						EXIT CONSTRUCT 
					OTHERWISE # saisie d'un critere de selection 
						ERROR "Please input a least one criteria" 
						CONTINUE CONSTRUCT 
				END CASE 
			END IF 
	END CONSTRUCT 


	IF int_flag = true THEN 
		MESSAGE "Quit with quit key" 
		LET int_flag=0 
	ELSE 
		LET xnumber = sql_get_qbe_count_table_documentation(where_clause) 
		IF xnumber > 0 THEN 
			LET sql_stmt_status = sql_opn_pky_scr_curs_table_documentation(where_clause) 
		ELSE 
			RETURN -1 
		END IF 


	END IF 
	RETURN xnumber 
END FUNCTION ## query_table_documentation 


#######################################################################
# frm_Display_z_table_documentation_mngr_f_dbschema_documentation : displays the form record after reading and displays lookup records if any
# inbound: Form record.*
FUNCTION frm_display_z_table_documentation_mngr(frm_z_table_documentation_mngr) 
	DEFINE frm_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
	END RECORD 
	DEFINE table_formonly RECORD 
		nrows INTEGER 
	END RECORD 

	# Fetch current number of rows in the table
	SELECT p.nrows INTO table_formonly.nrows 
	FROM sysmaster:sysptnhdr p,systables t 
	WHERE t.tabname = frm_z_table_documentation_mngr.tabname 
	AND hex(t.partnum) = p.partnum 

	CLEAR FORM 
	DISPLAY BY NAME frm_z_table_documentation_mngr.*, table_formonly.nrows 

END FUNCTION # frm_display_z_table_documentation_mngr_f_dbschema_documentation 




####################################################################
## frm_Insert_z_table_documentation_mngr_f_dbschema_documentation: add a new table_documentation row
FUNCTION frm_insert_z_table_documentation_mngr() 
	DEFINE sql_stmt_status SMALLINT 
	DEFINE rows_count SMALLINT 
	DEFINE nbre_table_documentation ,action SMALLINT 
	DEFINE frm_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00321
	END RECORD 


	DEFINE tbl_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00325
	END RECORD 


	#@G00327


	CLEAR FORM 
	INITIALIZE frm_z_table_documentation_mngr.* TO NULL 


	WHILE true 
		LET int_flag = false 
		INPUT BY NAME frm_z_table_documentation_mngr.tabname, 
		frm_z_table_documentation_mngr.tabtype, 
		frm_z_table_documentation_mngr.language_code, 
		frm_z_table_documentation_mngr.documentation, 
		frm_z_table_documentation_mngr.mtime 

		#@G00334
		WITHOUT DEFAULTS 
			AFTER FIELD tabname 
				IF frm_z_table_documentation_mngr.tabname IS NULL THEN 
					ERROR "This field is required" 
					NEXT FIELD tabname 
				END IF 
				IF sql_status_pk_table_documentation(frm_z_table_documentation_mngr.language_code,frm_z_table_documentation_mngr.tabname) THEN 
					ERROR "table_documentation: already exists" 
					NEXT FIELD tabname 
				END IF 
			AFTER FIELD language_code 
				IF frm_z_table_documentation_mngr.language_code IS NULL THEN 
					ERROR "This field is required" 
					NEXT FIELD language_code 
				END IF 
				IF sql_status_pk_table_documentation(frm_z_table_documentation_mngr.language_code,frm_z_table_documentation_mngr.tabname) THEN 
					ERROR "table_documentation: already exists" 
					NEXT FIELD language_code 
				END IF 
				#@G00353


				#@G00354
				#@G00354
		END INPUT 
		IF int_flag = true THEN 
			# Resign from input
			LET int_flag=false 
			DISPLAY BY NAME frm_z_table_documentation_mngr.* 
			MESSAGE "Quit with quit key Control-C" 
			EXIT WHILE 
		END IF 


		CALL confirm_operation(3,10,"Insert") RETURNING ACTION 
		CASE ACTION 
			WHEN 0 # i want TO edit the input, remains displayed 'as is' 
				CONTINUE WHILE # ON laisse tout affiche comme tel 


			WHEN 2 # ON valide la transaction 
				BEGIN WORK 
					#@G00370
					CALL set_table_record_f_dbschema_documentation_table_documentation('+',frm_z_table_documentation_mngr.*) 
					RETURNING tbl_z_table_documentation_mngr.* 
					CALL sql_insert_table_documentation(tbl_z_table_documentation_mngr.*) 
					RETURNING sql_stmt_status, tbl_z_table_documentation_mngr.tabname,tbl_z_table_documentation_mngr.language_code 
					#@G00374


					CASE 
						WHEN sql_stmt_status = 0 
							MESSAGE "Insert table_documentation Successful operation" 
						COMMIT WORK 
						#@G00379
						WHEN sql_stmt_status < 0 
							CALL display_error2("Insert table_documentation:failed ") 
							ROLLBACK WORK 
							#@G00382
					END CASE 
					EXIT WHILE 


			WHEN 0 
				ROLLBACK WORK 
				#@G00387
				EXIT WHILE 
		END CASE 
	END WHILE 
	# tbl_z_table_documentation_mngr
	RETURN sql_stmt_status, tbl_z_table_documentation_mngr.tabname,tbl_z_table_documentation_mngr.language_code 
	#@G00392
END FUNCTION ## frm_insert_z_table_documentation_mngr_f_dbschema_documentation 




#######################################################################
# frm_Edit_z_table_documentation_mngr_f_dbschema_documentation : Edit a table_documentation RECORD
# inbound: table primary key
FUNCTION frm_edit_z_table_documentation_mngr(pky,frm_z_table_documentation_mngr) 
	DEFINE ACTION SMALLINT 
	DEFINE sql_stmt_status,dummy SMALLINT 


	DEFINE tbl_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00404
	END RECORD 


	DEFINE frm_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00408
	END RECORD 


	DEFINE sav_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00412
	END RECORD 
	#@G00413
	DEFINE rows_count SMALLINT 
	DEFINE pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00416
	END RECORD 


	## check if record can be accessed
	WHILE true 
		LET int_flag = false 
		# Save Screen Record values before altering
		LET sav_z_table_documentation_mngr.* = frm_z_table_documentation_mngr.* 
		BEGIN WORK 
			EXECUTE immediate "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS" 
			WHENEVER SQLERROR CONTINUE 
			OPEN crs_upd_table_documentation USING pky.* 
			FETCH crs_upd_table_documentation INTO dummy 
			IF sqlca.sqlcode = -244 THEN ERROR "THIS ROW IS BEING MODIFIED" 
				ROLLBACK WORK EXIT WHILE END IF 
				WHENEVER SQLERROR stop 
				#@G00431
				INPUT BY NAME frm_z_table_documentation_mngr.documentation 
				#@G00432
				WITHOUT DEFAULTS 
				#@G00433
				#@G00435
				END INPUT 
				IF int_flag = true THEN 
					LET int_flag=false 
					# Restore previous value
					LET frm_z_table_documentation_mngr.* = sav_z_table_documentation_mngr.* 
					DISPLAY BY NAME frm_z_table_documentation_mngr.* 
					#@G00441
					EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
					ROLLBACK WORK 
					MESSAGE "$CancelCom Control-C" 
					EXIT WHILE 
				END IF 


				CALL confirm_operation(4,10,MODE_CLASSIC_EDIT) RETURNING ACTION 


				CASE 
					WHEN ACTION = 0 
						# Redo, leave values as modified
						CONTINUE WHILE 
					WHEN ACTION = 1 
						# Resign, restore original values
						LET frm_z_table_documentation_mngr.* = sav_z_table_documentation_mngr.* 
						DISPLAY BY NAME frm_z_table_documentation_mngr.* 
						EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
						ROLLBACK WORK 
						EXIT WHILE # CANCEL operation 


					WHEN ACTION = 2 
						# confirm update
						CALL set_table_record_f_dbschema_documentation_table_documentation("#",frm_z_table_documentation_mngr.*) 
						RETURNING tbl_z_table_documentation_mngr.* 


						# Perform the prepared update statement
						LET sql_stmt_status = sql_edit_table_documentation(pky.*,tbl_z_table_documentation_mngr.*) 
						CASE 
							WHEN sql_stmt_status = 0 
								MESSAGE "Edit table_documentation Successful operation" 
								EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
							COMMIT WORK 
							#@G00473
							WHEN sql_stmt_status < 0 
								CALL display_error2("Edit table_documentation:failed ") 
								EXECUTE immediate "SET ISOLATION TO COMMITTED READ" 
								ROLLBACK WORK 
								#@G00477
						END CASE 
						EXIT WHILE 
				END CASE 
			END WHILE 
			RETURN sql_stmt_status 
END FUNCTION ## frm_edit_z_table_documentation_mngr(pky) 




#######################################################################
# DELETE A table_documentation row
# inbound: table primary key
FUNCTION frm_delete_z_table_documentation_mngr(pky) 
	DEFINE ACTION SMALLINT 
	DEFINE dummy SMALLINT 
	DEFINE sql_stmt_status SMALLINT 
	DEFINE pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00494
	END RECORD 


	WHILE true 
		CALL confirm_operation(5,10,"Delete") RETURNING ACTION 
		BEGIN WORK 
			EXECUTE immediate "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS" 
			WHENEVER SQLERROR CONTINUE 
			OPEN crs_upd_table_documentation USING pky.* 
			FETCH crs_upd_table_documentation INTO dummy 
			IF sqlca.sqlcode = -244 THEN ERROR "THIS ROW IS BEING MODIFIED" 
				ROLLBACK WORK EXIT WHILE END IF 
				WHENEVER SQLERROR stop 
				#@G00506
				CASE 
					WHEN ACTION = 0 OR ACTION = 1 
						# can the delete operation
						EXIT WHILE 
					WHEN ACTION = 2 
						# Validate the delete operation
						CALL sql_delete_table_documentation(pky.*) RETURNING sql_stmt_status 
						CASE 
							WHEN sql_stmt_status = 0 
								MESSAGE "Delete table_documentation Successful operation" 
							COMMIT WORK 
							#@G00517


							WHEN sql_stmt_status < 0 
								CALL display_error2("Delete table_documentation:failed ") 
								ROLLBACK WORK 
								#@G00521
						END CASE 
						EXIT WHILE 
				END CASE 
			END WHILE 
			RETURN sql_stmt_status 
END FUNCTION ## frm_delete_z_table_documentation_mngr(pky) 


#########################################################################
#  Build, prepare, declare and initialize main queries and cursors
FUNCTION sql_prepare_queries_z_table_documentation_mngr_table_documentation () 
	DEFINE query_text STRING 


	# PREPARE cursor for full master table row contents, access by primary key
	LET query_text= 
	"SELECT tabname,tabtype,language_code,documentation,mtime 
	", #@G00536 
	" FROM table_documentation ", 
	"WHERE tabname = ? 
	AND language_code = ? " #@G00539 


	PREPARE sel_mrw_table_documentation FROM query_text 
	DECLARE crs_row_table_documentation CURSOR FOR sel_mrw_table_documentation 


	# PREPARE cursor for row test / check if locked
	LET query_text= "SELECT tabname,language_code 
	", #@G00545 
	" FROM table_documentation ", 
	" WHERE tabname = ? 
	AND language_code = ? " #@G00548 


	PREPARE sel_pky_table_documentation FROM query_text 
	DECLARE crs_pky_table_documentation CURSOR FOR sel_pky_table_documentation 


	# PREPARE cursor for SELECT FOR UPDATE
	LET query_text= "SELECT tabname,language_code 
	", #@G00554 
	" FROM table_documentation ", 
	" WHERE tabname = ? 
	AND language_code = ? ", #@G00557 
	" FOR UPDATE" 


	PREPARE sel_upd_table_documentation FROM query_text 
	DECLARE crs_upd_table_documentation CURSOR FOR sel_upd_table_documentation 


	# PREPARE INSERT statement
	LET query_text = 
	"INSERT INTO table_documentation ( tabname,tabtype,language_code,documentation,mtime 
	)", #@G00565 
	" VALUES ( ?,?,?,?,? 
	)" #@G00566 
	PREPARE pr_ins_table_documentation FROM query_text 


	# PREPARE UPDATE statement
	LET query_text= 
	"UPDATE table_documentation ", 
	"SET ( tabtype,documentation,mtime 
	)", #@G00572 
	" = ( ?,?,? 
	)", #@G00573 
	" WHERE tabname = ? 
	AND language_code = ? " #@G00575 
	PREPARE pr_upd_table_documentation FROM query_text 


	# PREPARE DELETE statement
	LET query_text= "DELETE FROM table_documentation ", 
	" WHERE tabname = ? 
	AND language_code = ? " #@G00581 


	PREPARE pr_del_table_documentation FROM query_text 


END FUNCTION ## sql_prepare_queries_z_table_documentation_mngr_table_documentation 




#########################################################
# Open the QBE cursor,
# counts returned rows_count,
# open the data set,
# fetch first row
# inbound parameter: query predicate
# outbound parameters: number of rows retried
FUNCTION sql_get_qbe_count_table_documentation(qry_stmt) 
	DEFINE qry_stmt STRING 
	DEFINE rec_table_documentation STRING 
	DEFINE rows_count INTEGER 
	DEFINE lsql_stmt_status INTEGER 


	# define primary_key record
	DEFINE l_pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00603
	END RECORD 


	LET rec_table_documentation = 
	"SELECT count(*) FROM table_documentation", 
	" WHERE ",qry_stmt clipped 




	PREPARE prp_cnt_table_documentation FROM rec_table_documentation 
	DECLARE crs_cnt_table_documentation CURSOR FOR prp_cnt_table_documentation 


	OPEN crs_cnt_table_documentation 
	SET ISOLATION TO dirty read 
	WHENEVER SQLERROR CONTINUE 
	FETCH crs_cnt_table_documentation INTO rows_count 
	WHENEVER SQLERROR CALL error_mngmt 
	SET ISOLATION TO committed read 


	# if FETCH fails, count = 0, the, get back to query
	IF sqlca.sqlcode OR rows_count = 0 THEN 
		LET rows_count =0 
	END IF 
	FREE crs_cnt_table_documentation 
	RETURN rows_count 
END FUNCTION ## sql_get_qbe_count_table_documentation 


#########################################################
FUNCTION sql_opn_pky_scr_curs_table_documentation(qry_stmt) 
	## Build the query generated by CONSTRUCT BY NAME,
	## Declare and open the cursor
	## inbound param: query predicate
	## outbound parameter: query status
	DEFINE qry_stmt STRING 
	DEFINE rec_table_documentation STRING 
	DEFINE rows_count INTEGER 
	DEFINE lsql_stmt_status INTEGER 


	# define primary_key record
	DEFINE l_pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00642
	END RECORD 


	# display the selected columns


	LET rec_table_documentation = "SELECT tabname,language_code 
	", #@G00647 
	" FROM table_documentation ", 
	"WHERE ",qry_stmt clipped, 
	" ORDER BY tabname,language_code 
	" #@G00650 


	PREPARE rech_crs_ FROM rec_table_documentation 


	# crs_scrl_crs_ : the first cursor selects all the primary keys (not all the table columns)


	DECLARE crs_scrl_crs_ SCROLL CURSOR with HOLD 
	FOR rech_crs_ #@g00656 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_scrl_crs_ 
	WHENEVER SQLERROR CALL error_mngmt 


	RETURN sqlca.sqlcode 
END FUNCTION ## sql_opn_pky_scr_curs_table_documentation 


#######################################################################
FUNCTION sql_nxtprev_table_documentation(offset) 
	## sql_nxtprev_table_documentation : FETCH NEXT OR PREVIOUS RECORD
	DEFINE offset SMALLINT 
	DEFINE lsql_stmt_status,record_found INTEGER 
	DEFINE pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00671
	END RECORD 
	DEFINE frm_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00674
	END RECORD 


	WHENEVER SQLERROR CONTINUE 
	FETCH relative offset crs_scrl_crs_ INTO pky.* 
	WHENEVER SQLERROR CALL error_mngmt 


	CASE 
		WHEN sqlca.sqlcode = 100 
			LET record_found = 0 


		WHEN sqlca.sqlcode < 0 
			LET record_found = -1 
		OTHERWISE 
			LET lsql_stmt_status = 1 
			LET record_found = 1 
			#CALL sql_fetch_full_row_table_documentation (pky.*)
			#RETURNING record_found,frm_z_table_documentation_mngr.*


	END CASE 
	RETURN record_found,pky.* 
END FUNCTION ## sql_nxtprev_table_documentation 


#########################################################################################
FUNCTION sql_fetch_full_row_table_documentation(pky_table_documentation) 
	# sql_fetch_full_row_table_documentation : read a complete row accessing by primary key
	# inbound parameter : primary key
	# outbound parameter: sql_stmt_status and row contents
	DEFINE sql_stmt_status SMALLINT 
	DEFINE pky_table_documentation RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00704
	END RECORD 
	DEFINE tbl_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00707
	END RECORD 
	DEFINE frm_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00710
	END RECORD 


	#@G00712


	# read the table, access on primary key
	WHENEVER SQLERROR CONTINUE 
	OPEN crs_row_table_documentation 
	USING pky_table_documentation.* 


	FETCH crs_row_table_documentation INTO tbl_z_table_documentation_mngr.* 


	WHENEVER SQLERROR CALL error_mngmt 
	CASE 
		WHEN sqlca.sqlcode = 100 
			LET sql_stmt_status = 0 
		WHEN sqlca.sqlcode < 0 
			LET sql_stmt_status = -1 
		OTHERWISE 
			LET sql_stmt_status = 1 
			CALL set_form_record_z_table_documentation_mngr(tbl_z_table_documentation_mngr.*) 
			RETURNING frm_z_table_documentation_mngr.* 
	END CASE 
	RETURN sql_stmt_status,frm_z_table_documentation_mngr.* 
END FUNCTION ## sql_fetch_full_row_table_documentation 


########################################################################
FUNCTION sql_insert_table_documentation(tbl_z_table_documentation_mngr) 
	## INSERT in table table_documentation
	DEFINE lsql_stmt_status INTEGER 
	DEFINE rows_count SMALLINT 
	DEFINE pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00741
	END RECORD 
	DEFINE tbl_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00744
	END RECORD 
	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_ins_table_documentation 
	USING tbl_z_table_documentation_mngr.tabname, 
	tbl_z_table_documentation_mngr.tabtype, 
	tbl_z_table_documentation_mngr.language_code, 
	tbl_z_table_documentation_mngr.documentation, 
	tbl_z_table_documentation_mngr.mtime 
	#@G00748
	WHENEVER SQLERROR CALL error_mngmt 


	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status = 0 
		#@G00755


	END IF 
	RETURN lsql_stmt_status,pky.* 
END FUNCTION ## sql_insert_table_documentation 


########################################################################
FUNCTION sql_edit_table_documentation(pky,tbl_z_table_documentation_mngr) 
	## sql_Edit_table_documentation :update table_documentation record
	DEFINE lsql_stmt_status INTEGER 
	DEFINE pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00766
	END RECORD 
	DEFINE tbl_z_table_documentation_mngr RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00769
	END RECORD 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_upd_table_documentation 
	USING tbl_z_table_documentation_mngr.tabtype, 
	tbl_z_table_documentation_mngr.documentation, 
	tbl_z_table_documentation_mngr.mtime 
	, #@g00774 
	pky.* 


	WHENEVER SQLERROR CALL error_mngmt 
	IF sqlca.sqlcode < 0 THEN 


		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status = 0 
	END IF 
	RETURN lsql_stmt_status 
END FUNCTION ## sql_edit_table_documentation 


##############################################################################################
FUNCTION sql_delete_table_documentation(pky) 
	## sql_Delete_table_documentation :delete current row in table table_documentation
	DEFINE lsql_stmt_status SMALLINT 
	DEFINE pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00792
	END RECORD 


	WHENEVER SQLERROR CONTINUE 
	EXECUTE pr_del_table_documentation 
	USING pky.* 


	WHENEVER SQLERROR CALL error_mngmt 
	IF sqlca.sqlcode < 0 THEN 
		LET lsql_stmt_status = -1 
	ELSE 
		LET lsql_stmt_status=0 
	END IF 
	RETURN lsql_stmt_status 
END FUNCTION ## sql_delete_table_documentation 


################################################################################
FUNCTION sql_status_pk_table_documentation(pky) 
	##   sql_status_pk_table_documentation : Check if primary key exists
	## inbound parameter : record of primary key
	## outbound parameter:  status > 0 if exists, 0 if no record, < 0 if error
	DEFINE pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00814
	END RECORD 
	DEFINE pk_status INTEGER 


	WHENEVER SQLERROR CONTINUE 
	OPEN crs_pky_table_documentation USING pky.* 
	FETCH crs_pky_table_documentation 
	WHENEVER SQLERROR CALL error_mngmt 


	CASE sqlca.sqlcode 
		WHEN 0 
			LET pk_status = 1 
		WHEN 100 
			LET pk_status = 0 
		WHEN sqlca.sqlerrd[2] = 104 
			LET pk_status = -1 # RECORD locked 
		WHEN sqlca.sqlcode < 0 
			LET pk_status = sqlca.sqlcode 
	END CASE 


	RETURN pk_status 
END FUNCTION ## sql_status_pk_table_documentation 


################################################################################################
FUNCTION set_form_record_z_table_documentation_mngr(tbl_contents) 
	## set_form_record_z_table_documentation_mngr_f_dbschema_documentation: assigns table values to form fields values
	DEFINE frm_contents RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00841
	END RECORD 


	DEFINE tbl_contents RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00845
	END RECORD 


	INITIALIZE frm_contents.* TO NULL 
	LET frm_contents.tabname = tbl_contents.tabname 
	LET frm_contents.tabtype = tbl_contents.tabtype 
	LET frm_contents.language_code = tbl_contents.language_code 
	LET frm_contents.documentation = tbl_contents.documentation 
	LET frm_contents.mtime = tbl_contents.mtime 
	#@G00854
	RETURN frm_contents.* 
END FUNCTION ## set_form_recordz_table_documentation_mngr_f_dbschema_documentation 


################################################################################################
FUNCTION set_table_record_f_dbschema_documentation_table_documentation(sql_stmt,frm_contents) 
	## set_table_record_f_dbschema_documentation_table_documentation: assigns form fields value to table values
	DEFINE sql_stmt CHAR(1) # + => insert, # => UPDATE 
	DEFINE pky RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		language_code LIKE table_documentation.language_code # char(3) 
		#@G00863
	END RECORD 


	DEFINE frm_contents RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00867
	END RECORD 


	DEFINE tbl_contents RECORD 
		tabname LIKE table_documentation.tabname, # varchar(128) 
		tabtype LIKE table_documentation.tabtype, # char(10) 
		language_code LIKE table_documentation.language_code, # char(3) 
		documentation LIKE table_documentation.documentation, # nvarchar(255) 
		mtime LIKE table_documentation.mtime # DATETIME year TO second 
		#@G00871
	END RECORD 


	INITIALIZE tbl_contents.* TO NULL 
	CASE sql_stmt 
		WHEN "+" # PREPARE RECORD FOR INSERT 
			LET tbl_contents.tabname = frm_contents.tabname 
			LET tbl_contents.tabtype = frm_contents.tabtype 
			LET tbl_contents.language_code = frm_contents.language_code 
			LET tbl_contents.documentation = frm_contents.documentation 
			LET tbl_contents.mtime = frm_contents.mtime 
			#@G00882
		WHEN "#" # PREPARE RECORD FOR UPDATE 
			LET tbl_contents.tabtype = frm_contents.tabtype 
			LET tbl_contents.documentation = frm_contents.documentation 
			LET tbl_contents.mtime = frm_contents.mtime 
			#@G00887
	END CASE 


	RETURN tbl_contents.* 
END FUNCTION ## set_table_recordf_dbschema_documentation_table_documentation 

FUNCTION check_new_tables_documented() 
	-- tables that exist but are not documented in table_documentation
	--select tabname
	--from systables
	--where tabname not in (SELECT tabname from table_documentation )
	--and tabid > 120
	--and tabname not matches "sys*"
	--and tabtype = "T" into temp existing_but_undocumented_tables ;

	-- columns from existing tables, but that are not documented
	--select t.tabname,c.colno,c.colname,"documentation for "||c.colname
	--from syscolumns c,systables t
	--where c.tabid=t.tabid
	--and t.tabname in (SELECT tabname from existing_but_undocumented_tables )
	--and c.tabid > 120
	--and t.tabname not matches "sys*"
	--and t.tabtype = "T" ;


	--select t.tabname,c.colname as tabcol
	--from syscolumns c,systables t
	--where c.tabid=t.tabid
	--and c.tabid > 120
	--and t.tabname not matches "sys*"
	--and t.tabtype = "T"
	--and  t.tabname||c.colname not in ( select t.tabname||c.colname from column_documentation )

END FUNCTION 
