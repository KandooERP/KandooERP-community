# module  generated by Querix Ffg(c) 		                                                                                    	#@G00001
# Generated on 2017-10-03 08:09:51		                                                                                       	#@G00002
# template E:\Users\BeGooden-IT\Projects\QuerixTools\Ffg/templates/child_standard.mtplt 		                                 	#@G00003
############################################################
# GLOBAL Scope Variables
############################################################
GLOBALS "../common/glob_GLOBALS.4gl"
DEFINE sr_events_pky_array DYNAMIC ARRAY OF RECORD
	evnt_num LIKE sr_events.evnt_num # BIGSERIAL
END RECORD

DEFINE sr_events_sr_array DYNAMIC ARRAY OF RECORD
	evnt_date LIKE sr_events.evnt_date, # DATETIME
	evnt_type LIKE sr_events.evnt_type, # CHAR(10)
	abstract LIKE sr_events.abstract, # CHAR(80)
	evnt_status LIKE sr_events.evnt_status, # CHAR(8)
	rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
	rcvd_from_id LIKE sr_events.rcvd_from_id # varchar(64)
END RECORD

DEFINE sr_events_status_array DYNAMIC ARRAY OF SMALLINT

DEFINE tbl_sr_events RECORD
	evnt_num LIKE sr_events.evnt_num, # BIGSERIAL
	sr_seed LIKE sr_events.sr_seed, # BIGINT
	evnt_type LIKE sr_events.evnt_type, # CHAR(10)
	sent_to_id LIKE sr_events.sent_to_id, # varchar(64)
	sent_to_channel LIKE sr_events.sent_to_channel, # CHAR(6)
	evnt_date LIKE sr_events.evnt_date, # DATETIME
	abstract LIKE sr_events.abstract, # CHAR(80)
	evnt_status LIKE sr_events.evnt_status, # CHAR(8)
	rcvd_from_id LIKE sr_events.rcvd_from_id, # varchar(64)
	rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
	next_step LIKE sr_events.next_step, # CHAR(20)
	next_step_schedule LIKE sr_events.next_step_schedule, # DATETIME
	long_desc LIKE sr_events.long_desc # lvarchar(32000)
END RECORD

#################################################################################################		                        	#@G00019
FUNCTION prepare_queries_srvr_rqst_sr_events ()
	# this function INITIALIZEs all cursors AND prepared statements for the sr_events AND lookups		                            	#@G00021
	#################################################################################################		                        	#@G00022
	DEFINE query_text STRING
	# Prepare the CURSOR TO display the sr_events array		                                                                     	#@G00024
	# using foreign key pointing TO service_request		                                                                         	#@G00025

	LET query_text = "SELECT sr_events.evnt_num ,",
	"sr_events.evnt_date,",
	"sr_events.evnt_type,",
	"sr_events.abstract,",
	"sr_events.evnt_status,",
	"sr_events.rcvd_from_channel,",
	"sr_events.rcvd_from_id",
	#@G00034
	" FROM service_request, ",
	"sr_events ",
	"WHERE sr_events.sr_seed = service_request.sr_seed ",
	#@G00035
	" AND sr_events.sr_seed = ? ",
	" ORDER BY sr_events.evnt_num "
	PREPARE pr_child_sr_events FROM query_text
	DECLARE crs_child_sr_events CURSOR FOR pr_child_sr_events

	# PREPARE INSERT statement		                                                                                              	#@G00041
	LET query_text =
	"INSERT INTO sr_events ( evnt_num,sr_seed,evnt_type,sent_to_id,sent_to_channel,evnt_date,abstract,evnt_status,rcvd_from_id,rcvd_from_channel,next_step,next_step_schedule,long_desc )",
	" VALUES ( ?,?,?,?,?,?,?,?,?,?,?,?,? )"
	PREPARE pr_ins_sr_events FROM query_text

	# PREPARE UPDATE statement		                                                                                              	#@G00047
	LET query_text=
	"UPDATE sr_events ",
	"SET ( sr_seed,evnt_type,sent_to_id,sent_to_channel,evnt_date,abstract,evnt_status,rcvd_from_id,rcvd_from_channel,next_step,next_step_schedule,long_desc )",
	" = ( ?,?,?,?,?,?,?,?,?,?,?,? )",
	" WHERE evnt_num = ? "
	PREPARE pr_upd_sr_events FROM query_text

	# PREPARE DELETE statement		                                                                                              	#@G00055
	LET query_text= "DELETE FROM sr_events ",
	" WHERE evnt_num = ? "
	PREPARE pr_del_sr_events FROM query_text

END FUNCTION

#######################################################################		                                                  	#@G00062
FUNCTION open_array_crs_sr_events_sr_array(fky)
	# This function opens the main CURSOR for the table sr_events		                                                            	#@G00064
	#######################################################################		                                                  	#@G00065
	DEFINE lsql_ok INTEGER
	DEFINE fky RECORD
		sr_seed LIKE sr_events.sr_seed # BIGINT
	END RECORD

	WHENEVER ERROR CONTINUE
	OPEN crs_child_sr_events USING fky.*

	WHENEVER ERROR CALL error_mngmt
	CASE
		WHEN sqlca.sqlcode = 100
			LET lsql_ok = 0
		WHEN sqlca.sqlcode < 0
			LET lsql_ok = -1
		OTHERWISE
			LET lsql_ok = 1
	END CASE
	RETURN lsql_ok
END FUNCTION

########################################################################		                                                 	#@G00086
## INSERT in table sr_events 		                                                                                            	#@G00087
########################################################################		                                                 	#@G00088
FUNCTION sql_insert_sr_events(lr_sr_events)
	DEFINE lr_sr_events RECORD
		evnt_num LIKE sr_events.evnt_num, # BIGSERIAL
		sr_seed LIKE sr_events.sr_seed, # BIGINT
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		sent_to_id LIKE sr_events.sent_to_id, # varchar(64)
		sent_to_channel LIKE sr_events.sent_to_channel, # CHAR(6)
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_id LIKE sr_events.rcvd_from_id, # varchar(64)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		next_step LIKE sr_events.next_step, # CHAR(20)
		next_step_schedule LIKE sr_events.next_step_schedule, # DATETIME
		long_desc LIKE sr_events.long_desc # lvarchar(32000)
	END RECORD

	DEFINE lsql_stmt_status INTEGER
	DEFINE lookup_status INTEGER
	DEFINE nb_deleted_rows INTEGER

	WHENEVER ERROR CONTINUE
	EXECUTE pr_ins_sr_events
	USING lr_sr_events.evnt_num,
	lr_sr_events.sr_seed,
	lr_sr_events.evnt_type,
	lr_sr_events.sent_to_id,
	lr_sr_events.sent_to_channel,
	lr_sr_events.evnt_date,
	lr_sr_events.abstract,
	lr_sr_events.evnt_status,
	lr_sr_events.rcvd_from_id,
	lr_sr_events.rcvd_from_channel,
	lr_sr_events.next_step,
	lr_sr_events.next_step_schedule,
	lr_sr_events.long_desc #
	WHENEVER ERROR CALL error_mngmt

	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status = 0
		WHEN sqlca.sqlcode < 0
			CALL display_eric_error("sql_insert sr_events:failed ")
			LET lsql_stmt_status = -1
	END CASE
	RETURN lsql_stmt_status
END FUNCTION

########################################################################		                                                 	#@G00113
## sql_update_sr_events :UPDATE current sr_events record		                                                                 	#@G00114
########################################################################		                                                 	#@G00115
FUNCTION sql_update_sr_events(pky,lr_sr_events)
	DEFINE lr_sr_events RECORD
		evnt_num LIKE sr_events.evnt_num, # BIGSERIAL
		sr_seed LIKE sr_events.sr_seed, # BIGINT
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		sent_to_id LIKE sr_events.sent_to_id, # varchar(64)
		sent_to_channel LIKE sr_events.sent_to_channel, # CHAR(6)
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_id LIKE sr_events.rcvd_from_id, # varchar(64)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		next_step LIKE sr_events.next_step, # CHAR(20)
		next_step_schedule LIKE sr_events.next_step_schedule, # DATETIME
		long_desc LIKE sr_events.long_desc # lvarchar(32000)
	END RECORD
	DEFINE lsql_stmt_status INTEGER
	DEFINE nb_modified_rows INTEGER
	DEFINE pky RECORD
		evnt_num LIKE sr_events.evnt_num # BIGSERIAL
	END RECORD

	WHENEVER ERROR CONTINUE
	EXECUTE pr_upd_sr_events
	USING lr_sr_events.sr_seed,
	lr_sr_events.evnt_type,
	lr_sr_events.sent_to_id,
	lr_sr_events.sent_to_channel,
	lr_sr_events.evnt_date,
	lr_sr_events.abstract,
	lr_sr_events.evnt_status,
	lr_sr_events.rcvd_from_id,
	lr_sr_events.rcvd_from_channel,
	lr_sr_events.next_step,
	lr_sr_events.next_step_schedule,
	lr_sr_events.long_desc ,
	pky.*

	WHENEVER ERROR CALL error_mngmt
	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status = 0
			LET nb_modified_rows = sqlca.sqlerrd[3]
		WHEN sqlca.sqlcode < 0
			CALL display_eric_error("sql_update sr_events:failed ")
			LET lsql_stmt_status = -1
			LET nb_modified_rows = 0
	END CASE
	RETURN lsql_stmt_status,nb_modified_rows
END FUNCTION

########################################################################		                                                 	#@G00144
## delete_sr_events :delete Selected row in table sr_events 		                                                             	#@G00145
########################################################################		                                                 	#@G00146
FUNCTION sql_delete_sr_events(pky)
	DEFINE lsql_stmt_status SMALLINT
	DEFINE nb_deleted_rows INTEGER
	DEFINE pky RECORD
		evnt_num LIKE sr_events.evnt_num # BIGSERIAL
	END RECORD

	WHENEVER ERROR CONTINUE
	EXECUTE pr_del_sr_events USING pky.*

	WHENEVER ERROR CALL error_mngmt
	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status=0
			LET nb_deleted_rows = sqlca.sqlerrd[3]
		WHEN sqlca.sqlcode < 0
			CALL display_eric_error("sql_delete sr_events:failed ")
			LET lsql_stmt_status = -1
	END CASE

	RETURN lsql_stmt_status,nb_deleted_rows
END FUNCTION

################################################################################		                                         	#@G00170
FUNCTION status_pksr_events(pky)
	# This function Checks if primary key exists		                                                                             	#@G00172
	# inbound parameter : record of primary key		                                                                              	#@G00173
	# outbound parameter:  STATUS > 0  if exists, 0 if no record, < 0 if error		                                               	#@G00174
	################################################################################		                                         	#@G00175
	DEFINE pky RECORD
		evnt_num LIKE sr_events.evnt_num # BIGSERIAL
	END RECORD
	DEFINE pk_status INTEGER

	WHENEVER ERROR CONTINUE
	OPEN crs_pky_mservice_request USING pky.*
	FETCH crs_pky_mservice_request
	WHENEVER ERROR CALL error_mngmt

	CASE sqlca.sqlcode
		WHEN 0
			LET pk_status = 1
		WHEN 100
			LET pk_status = 0
		WHEN sqlca.sqlerrd[2] = 104
			LET pk_status = -1 # RECORD locked
		WHEN sqlca.sqlcode < 0
			LET pk_status = sqlca.sqlcode
	END CASE
	RETURN pk_status
END FUNCTION

#@G00199

#######################################################################		                                                  	#@G00201
FUNCTION initialize_array_sr_events()
	#######################################################################		                                                  	#@G00203
	# INITIALIZEs arrays		                                                                                                    	#@G00204
	CALL sr_events_sr_array.clear()
	CALL sr_events_pky_array.clear()
	CALL sr_events_status_array.clear()
END FUNCTION

######################################################################################################################################################			#@G00210
FUNCTION display_array_sr_events (fky,browse)
	# This function displays the array data (sr_events_sr_array) based on the foreign key 		                                   	#@G00212
	# browse: FALSE means that the array IS displayed without possibility of browsing inside (just show array AND skip TO next parent row)			#@G00213
	######################################################################################################################################################			#@G00214
	DEFINE elem_num,choice,xpos,ypos INTEGER
	DEFINE arrcurr,srcline INTEGER
	DEFINE sql_ok INTEGER
	DEFINE qbe_stmt STRING
	DEFINE browse boolean
	DEFINE where_clause STRING
	DEFINE fky RECORD
		sr_seed LIKE sr_events.sr_seed # BIGINT
	END RECORD
	DEFINE sql_stmt_status INTEGER

	IF browse = false THEN
		# opening array CURSOR AND FETCH data only when reading the parent row		                                                 	#@G00227
		LET sql_ok = open_array_crs_sr_events_sr_array(fky.*)
		LET elem_num = 1
		FOREACH crs_child_sr_events INTO sr_events_pky_array[elem_num].evnt_num,sr_events_sr_array[elem_num].*
			LET sr_events_status_array[elem_num] = 0 # elements exists
			LET elem_num = elem_num + 1
		END FOREACH
		IF elem_num > 1 THEN
			CALL sr_events_sr_array.deleteelement(elem_num)
		END IF
	END IF

	DISPLAY ARRAY sr_events_sr_array
	TO scrrec_sr_events.*
		BEFORE DISPLAY
			IF browse = false THEN
				EXIT DISPLAY
			END IF
	END DISPLAY

	RETURN elem_num-1
END FUNCTION

###########################################################################################################		              	#@G00250
FUNCTION edit_array_sr_events (pky_service_request,p_do_browse)
	# This function calls the INPUT array function (input_array_sr_events) TO edit the array data		                            	#@G00252
	# then, accordingly, the SQL statement functions (array_bulk_update_)		                                                    	#@G00253
	# it IS generally called FROM another module		                                                                             	#@G00254
	###########################################################################################################		              	#@G00255
	DEFINE srcline INTEGER
	DEFINE arrcurr INTEGER
	DEFINE bulk_update_status SMALLINT
	DEFINE nbr_edited_rows INTEGER
	DEFINE sql_action SMALLINT
	DEFINE i SMALLINT
	DEFINE pky_service_request RECORD
		sr_seed LIKE service_request.sr_seed # BIGSERIAL # OR IS it the foreign KEY here?
	END RECORD 
	DEFINE p_do_browse BOOLEAN

	BEGIN WORK
		#@G00265
		WHILE true
			CALL input_array_sr_events (pky_service_request.*) RETURNING nbr_edited_rows,sql_action
			#@G00266
			IF nbr_edited_rows > 0 THEN
				CASE
					WHEN sql_action = 2
						LET bulk_update_status = array_bulk_update_sr_events (pky_service_request)
						IF bulk_update_status < 0 THEN
							ROLLBACK WORK
							#@G00271
							ERROR "input_array_ failed"
						ELSE
							ERROR "input_array_ Successful operation"
						COMMIT WORK
						#@G00274
						EXIT WHILE
					END IF
					WHEN sql_action = 1
						# No		                                                                                                                 	#@G00278
						ERROR "Please INPUT ARRAY AGAIN"
					WHEN sql_action = 0
						# Cancel		                                                                                                             	#@G00281
						MESSAGE "Cancelled, EXIT INPUT ARRAY"
						EXIT WHILE
				END CASE
			ELSE
				# Nothing		                                                                                                             	#@G00286
				MESSAGE "Nothing has been changed"
				EXIT WHILE
			END IF
		END WHILE

END FUNCTION

####################################################################################################################		     	#@G00294
FUNCTION input_array_sr_events (pky_service_request)
	## this function operates INPUT ARRAY for the table sr_events		                                                            	#@G00296
	# it handles 3 arrays:		                                                                                                   	#@G00297
	# 1) The STATUS array  (sr_events_status_array) contains the STATUS for each element: 		                                   	#@G00298
	#    NULL=>no data, 0=>elements NOT touched, 1=>element TO INSERT, 2=>element TO UPDATE, -1=>element TO DELETE		           	#@G00299
	# 2) the Input Data Array (sr_events_sr_array) will contain the data input by the user		                                   	#@G00300
	# 3) the primary key array (pky_service_request) contains the primary key VALUES of each element		                         	#@G00301
	###################################################################################################################		      	#@G00302
	DEFINE arrcnt INTEGER
	DEFINE srcline INTEGER
	DEFINE arrcurr INTEGER
	DEFINE last_element INTEGER
	DEFINE lookup_status INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE nbr_edited_rows INTEGER
	DEFINE sql_action SMALLINT
	DEFINE ins_key SMALLINT
	DEFINE pky_service_request RECORD
		sr_seed LIKE service_request.sr_seed # BIGSERIAL
	END RECORD
	DEFINE sav_sr_events_sr_array RECORD
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		rcvd_from_id LIKE sr_events.rcvd_from_id # varchar(64)
	END RECORD
	DEFINE sql_ok SMALLINT
	LET nbr_edited_rows = 0

	LET int_flag = false
	LET ins_key = false

	INPUT ARRAY sr_events_sr_array WITHOUT DEFAULTS
	FROM scrrec_sr_events.*
	attribute(normal)
		ON KEY (INTERRUPT)
			# Cancel FROM input		                                                                                                    	#@G00328
			LET int_flag=false
			LET arrcurr = arr_curr()
			LET srcline = scr_line ()
			LET sr_events_sr_array[arrcurr].* = sav_sr_events_sr_array.*
			DISPLAY sr_events_sr_array[arrcurr].* TO scrrec_sr_events[srcline].*
			MESSAGE "Quit with quit key Control-C"
			ROLLBACK WORK
			#@G00334
			EXIT INPUT

		BEFORE INSERT
			# INSERT a row in pky_array		                                                                                            	#@G00338
			CALL sr_events_pky_array.insert(arrcurr)
			INITIALIZE sr_events_pky_array[arrcurr].* TO NULL
			# INSERT a row in status_array		                                                                                         	#@G00341
			CALL sr_events_status_array.insert(arrcurr)
			LET sr_events_status_array[arrcurr] = NULL

		AFTER DELETE
			IF sr_events_status_array[arrcurr] IS NOT NULL THEN
				LET last_element = sr_events_status_array.getsize()
				# The deleted element becomes the last element of status_array AND flagged -1		                                         	#@G00348
				# The pky IS also copied TO the last element		                                                                          	#@G00349
				LET sr_events_status_array[last_element] = -1 # TO be deleted
				LET sr_events_pky_array[last_element].* = sr_events_pky_array[arrcurr].*
				LET nbr_edited_rows = nbr_edited_rows + 1
			END IF

		BEFORE ROW
			LET srcline = scr_line()
			LET arrcurr = arr_curr()
			LET sav_sr_events_sr_array.* = sr_events_sr_array[arrcurr].*

			#@G00360

			#@G00361

		AFTER ROW
			IF field_touched (scrrec_sr_events[srcline].*) THEN
				LET nbr_edited_rows = nbr_edited_rows + 1
				CASE
					WHEN sr_events_status_array[arrcurr] = 0 # existing
						LET sr_events_status_array[arrcurr] = 2 # TO be modified
						#@G00369

					WHEN sr_events_status_array[arrcurr] IS NULL # new
						LET sr_events_status_array[arrcurr] = 1 # TO be inserted
						#@G00373
				END CASE
				IF status_pksr_events(sr_events_pky_array[arrcurr].evnt_num) THEN
					ERROR "sr_events: already exists"
					NEXT FIELD rcvd_from_id
				END IF
				#@G00379
			END IF

		AFTER INPUT
			IF int_flag THEN
				LET int_flag = false
				ERROR " Cancel sr_events"
				LET nbr_edited_rows = 0
				LET sql_action = 0
			ELSE
				LET sql_action = confirm_operation(5,10,"input_array_ ")
				IF sql_action = 1 THEN
					CONTINUE INPUT
				END IF
			END IF
	END INPUT
	RETURN nbr_edited_rows,sql_action
END FUNCTION

######################################################################################################		                   	#@G00398
FUNCTION set_form_record_srvr_rqst_scrrec_sr_events(tbl_contents)
	# This function assigns the VALUES FROM the table ScrRec_sr_events TO the form record frm_contents		                              	#@G00400
	######################################################################################################		                   	#@G00401
	DEFINE fgl_status SMALLINT
	DEFINE frm_contents RECORD
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		rcvd_from_id LIKE sr_events.rcvd_from_id # varchar(64)
	END RECORD

	DEFINE tbl_contents RECORD
		evnt_num LIKE sr_events.evnt_num, # BIGSERIAL
		sr_seed LIKE sr_events.sr_seed, # BIGINT
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		sent_to_id LIKE sr_events.sent_to_id, # varchar(64)
		sent_to_channel LIKE sr_events.sent_to_channel, # CHAR(6)
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_id LIKE sr_events.rcvd_from_id, # varchar(64)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		next_step LIKE sr_events.next_step, # CHAR(20)
		next_step_schedule LIKE sr_events.next_step_schedule, # DATETIME
		long_desc LIKE sr_events.long_desc # lvarchar(32000)
	END RECORD

	INITIALIZE frm_contents.* TO NULL
	LET frm_contents.evnt_date = tbl_sr_events.evnt_date
	LET frm_contents.evnt_type = tbl_sr_events.evnt_type
	LET frm_contents.abstract = tbl_sr_events.abstract
	LET frm_contents.evnt_status = tbl_sr_events.evnt_status
	LET frm_contents.rcvd_from_channel = tbl_sr_events.rcvd_from_channel
	LET frm_contents.rcvd_from_id = tbl_sr_events.rcvd_from_id
	#@G00418
	CASE
		WHEN status = 0
			LET fgl_status = 1
		WHEN status < 0
			LET fgl_status = status
		OTHERWISE
			LET fgl_status = status
	END CASE
	RETURN fgl_status,frm_contents.*
END FUNCTION

######################################################################################################		                   	#@G00430
FUNCTION set_table_record_srvr_rqst_sr_events(fky,sql_stmt,pky,element_contents)
	# This function assigns the VALUES FROM the array element(element_contents) TO the table record (tbl_contents)		           	#@G00432
	# It distinguishes the primary key (pky) of the table sr_eventsand the foreign key (fky) point TO the parent table (service_request)			#@G00433
	######################################################################################################		                   	#@G00434
	DEFINE sql_stmt SMALLINT
	DEFINE fgl_status SMALLINT
	DEFINE element_contents RECORD
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		rcvd_from_id LIKE sr_events.rcvd_from_id # varchar(64)
	END RECORD
	DEFINE fky RECORD
		sr_seed LIKE sr_events.sr_seed # BIGINT
	END RECORD
	DEFINE pky RECORD
		evnt_num LIKE sr_events.evnt_num # BIGSERIAL
	END RECORD
	DEFINE tbl_contents RECORD
		evnt_num LIKE sr_events.evnt_num, # BIGSERIAL
		sr_seed LIKE sr_events.sr_seed, # BIGINT
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		sent_to_id LIKE sr_events.sent_to_id, # varchar(64)
		sent_to_channel LIKE sr_events.sent_to_channel, # CHAR(6)
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_id LIKE sr_events.rcvd_from_id, # varchar(64)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		next_step LIKE sr_events.next_step, # CHAR(20)
		next_step_schedule LIKE sr_events.next_step_schedule, # DATETIME
		long_desc LIKE sr_events.long_desc # lvarchar(32000)
	END RECORD

	#WHENEVER ERROR CONTINUE		                                                                                                	#@G00450
	INITIALIZE tbl_contents.* TO NULL
	IF sql_stmt = 1 THEN
		LET tbl_contents.evnt_num = 0
	END IF
	LET tbl_contents.sr_seed = fky.sr_seed
	LET tbl_contents.evnt_type = element_contents.evnt_type
	# LET tbl_contents.sent_to_id = your value		                                                                               	#@G00457
	# LET tbl_contents.sent_to_channel = your value		                                                                          	#@G00458
	LET tbl_contents.evnt_date = element_contents.evnt_date
	LET tbl_contents.abstract = element_contents.abstract
	LET tbl_contents.evnt_status = element_contents.evnt_status
	LET tbl_contents.rcvd_from_id = element_contents.rcvd_from_id
	LET tbl_contents.rcvd_from_channel = element_contents.rcvd_from_channel
	# LET tbl_contents.next_step = your value		                                                                                	#@G00464
	# LET tbl_contents.next_step_schedule = your value		                                                                       	#@G00465
	# LET tbl_contents.long_desc = your value		                                                                                	#@G00466
	#@G00467
	WHENEVER ERROR CALL error_mngmt
	CASE
		WHEN status = 0
			LET fgl_status = 1
		WHEN status < 0
			LET fgl_status = status
		OTHERWISE
			LET fgl_status = status
	END CASE
	RETURN fgl_status,tbl_contents.*
END FUNCTION

#############################################################################################################		            	#@G00480
FUNCTION array_bulk_update_sr_events (fky)
	## This functions browses the STATUS array sr_events_status_array,		                                                       	#@G00482
	# copies the element VALUES TO table VALUES (sr_events)		                                                                  	#@G00483
	# AND executes the request SQL operation requested for each element		                                                      	#@G00484
	#############################################################################################################		            	#@G00485
	DEFINE idx,arr_size INTEGER
	DEFINE updarr_status,fgl_status,global_status INTEGER
	DEFINE fky RECORD
		sr_seed LIKE sr_events.sr_seed # BIGINT
	END RECORD

	DEFINE elements_contents RECORD
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		rcvd_from_id LIKE sr_events.rcvd_from_id # varchar(64)
	END RECORD
	DEFINE l_sr_events RECORD
		evnt_num LIKE sr_events.evnt_num, # BIGSERIAL
		sr_seed LIKE sr_events.sr_seed, # BIGINT
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		sent_to_id LIKE sr_events.sent_to_id, # varchar(64)
		sent_to_channel LIKE sr_events.sent_to_channel, # CHAR(6)
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_id LIKE sr_events.rcvd_from_id, # varchar(64)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		next_step LIKE sr_events.next_step, # CHAR(20)
		next_step_schedule LIKE sr_events.next_step_schedule, # DATETIME
		long_desc LIKE sr_events.long_desc # lvarchar(32000)
	END RECORD
	LET global_status = 0
	LET arr_size = sr_events_status_array.getsize()
	FOR idx = 1 TO arr_size
		CASE
			WHEN sr_events_status_array[idx] IS NULL OR sr_events_status_array[idx] = 0
				CONTINUE FOR
			WHEN sr_events_status_array[idx] > 0
				LET elements_contents.* = sr_events_sr_array[idx].*
				CALL set_table_record_srvr_rqst_sr_events(fky.*,sr_events_status_array[idx],sr_events_pky_array[idx].*,sr_events_sr_array[idx].*)
				RETURNING fgl_status,l_sr_events.*
		END CASE
		LET updarr_status = update_one_element_sr_events(idx,l_sr_events.*)
		IF updarr_status < 0 THEN
			ERROR "Error on element # ",idx
			LET global_status = global_status + 1
		END IF
	END FOR
	RETURN global_status
END FUNCTION

###############################################################################		                                          	#@G00518
# This function executes the SQL statement for each element		                                                              	#@G00519
# accord the TO STATUS array value of this element		                                                                       	#@G00520
###############################################################################		                                          	#@G00521
FUNCTION update_one_element_sr_events(idx,lr_sr_events)
	DEFINE st SMALLINT
	DEFINE arrcnt SMALLINT
	DEFINE idx SMALLINT
	DEFINE statut SMALLINT
	DEFINE lr_sr_events RECORD
		evnt_num LIKE sr_events.evnt_num, # BIGSERIAL
		sr_seed LIKE sr_events.sr_seed, # BIGINT
		evnt_type LIKE sr_events.evnt_type, # CHAR(10)
		sent_to_id LIKE sr_events.sent_to_id, # varchar(64)
		sent_to_channel LIKE sr_events.sent_to_channel, # CHAR(6)
		evnt_date LIKE sr_events.evnt_date, # DATETIME
		abstract LIKE sr_events.abstract, # CHAR(80)
		evnt_status LIKE sr_events.evnt_status, # CHAR(8)
		rcvd_from_id LIKE sr_events.rcvd_from_id, # varchar(64)
		rcvd_from_channel LIKE sr_events.rcvd_from_channel, # CHAR(6)
		next_step LIKE sr_events.next_step, # CHAR(20)
		next_step_schedule LIKE sr_events.next_step_schedule, # DATETIME
		long_desc LIKE sr_events.long_desc # lvarchar(32000)
	END RECORD
	LET st = 0
	CASE sr_events_status_array[idx]
		WHEN 2 # must be updated
			LET statut = sql_update_sr_events(sr_events_pky_array[idx].*,lr_sr_events.*)
		WHEN 1
			LET statut = sql_insert_sr_events(lr_sr_events.*)
		WHEN -1
			LET statut = sql_delete_sr_events(sr_events_pky_array[idx].*)
	END CASE
	RETURN statut
END FUNCTION
