<Script:our $ChildSRArray=${SRArrayPrefix} . ${ChildTable}  :Script>noprint
<Script:our $ChildPkyArray= ${PkyArrayPrefix} . ${ChildTable} :Script>noprint
<Script:our $ChildActArray=${ActArrayPrefix} . ${ChildTable}  :Script>noprint
<Script:our $ChlTableRec=${TblPrfx} . ${ChildTable} :Script>noprint
<Script:our $ChlSavFormRec=${SRSavPrfx} . ${ChildSRArray} :Script>noprint
# module  generated by Kandoo Ffg(c) 
# Generated on ${GenerationTS}
# template ${TemplateFile} 
GLOBALS "common/glob_GLOBALS.4gl"

# Define types to be reused in functions
DEFINE ${TypePrefix}${PrmryKeyPrefix}${ChildTable} TYPE AS RECORD         # Define Primary Key Type of Child Table
	<Script:define_PK_columns ($SRCHANDLE,${ChildTable},"pky",$DefineStyle):Script>
END RECORD

DEFINE ${TypePrefix}${JoinKeyPrefix}${ChildTable} TYPE AS RECORD         # Define Foreign Key type -> ${ParentTable}
	<Script: define_FK_columns ($SRCHANDLE,${ChildTable},${ParentTable},"fky",$DefineStyle,"joinchild"):Script> 
END RECORD

DEFINE ${TypePrefix}ArrElemChild_${FormName} TYPE AS RECORD      # Define Screen Record Array Type
	<Script:define_form_fields($SRCHANDLE,$MainFormName,".*","child",".*","true|false","all","","\t\t")  :Script>
END RECORD

DEFINE ${TypePrefix}${ChildActArray} TYPE AS CHAR(1)    # Define Action Array Type

DEFINE ${TypePrefix}FullRec_${ChildTable} TYPE AS RECORD                            # Define full record of child table
	<Script:define_table_columns ($SRCHANDLE,${ChildTable},"child+","","all","record",$MstTableRec,"    "):Script>
END RECORD

# Define module scope variables and arrays
# Cursors
DEFINE ${ArrCursorPrefix}_fgnkey_child_${ChildTable} CURSOR

#Prepared statements
DEFINE ${PrepStmtPrefix}insert_${ChildTable} PREPARED
DEFINE ${PrepStmtPrefix}update_${ChildTable} PREPARED
DEFINE ${PrepStmtPrefix}delete_${ChildTable} PREPARED


FUNCTION ${SqlPrepareQueriesFct}_${ModuleName}_child ()
# this function initializes all cursors and prepared statements for the ${ChildTable} and lookups

DEFINE ${PrepareStmtVariable} STRING 
	# Prepare the cursor to display the ${ChildTable} array
	# using foreign key pointing to ${ParentTable}
	
	LET ${PrepareStmtVariable} = "SELECT '=',<Script:print_table_columns($SRCHANDLE,$ChildTable,"child",".*","","pkey","",$ChildTable,"flat","    "); :Script>,",
	<Script:print_form_fields ($SRCHANDLE,$FormName,".*","child",".*","false|true",".*","TblName","\t\t\t","quoteskip","","reset"):Script>
	<Script:bld_scrrec_join($SRCHANDLE,$FormName,$ChildScreenRecord,$ParentTable,$ChildTable,".*", ".*",".*","tabname","","quoteskip",""); :Script>
	" ORDER BY <Script:print_table_columns($SRCHANDLE,$ChildTable,"child",".*","","pkey","",$ChildTable,"flat","    "); :Script>"
	CALL ${ArrCursorPrefix}_fgnkey_child_${ChildTable}.Declare(${PrepareStmtVariable})

	# PREPARE INSERT statement
	LET ${PrepareStmtVariable} =
	"INSERT INTO ${ChildTable} (<Script:print_table_columns($SRCHANDLE,${ChildTable},"child+","","","all","","","flat","",""):Script>)",
	" VALUES (                  <Script:print_table_columns($SRCHANDLE,${ChildTable},"child+","","","all","placeholders","","flat","",1); :Script>)" 
	CALL ${PrepStmtPrefix}insert_${ChildTable}.Prepare(${PrepareStmtVariable})

	# PREPARE UPDATE statement
	let ${PrepareStmtVariable} =
	"UPDATE ${ChildTable} ",
	"SET ( <Script:print_table_columns($SRCHANDLE,${ChildTable},"child","","","attr","","","flat","",""):Script>)",
	" = ( <Script:print_table_columns ($SRCHANDLE,${ChildTable},"child","","attr","","placeholders","","flat","",""); :Script>)",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ChildTable},${KeyMode},"?","","    ") ;:Script>" 
	CALL ${PrepStmtPrefix}update_${ChildTable}.Prepare(${PrepareStmtVariable})

	# PREPARE DELETE statement
	let ${PrepareStmtVariable} = "DELETE FROM ${ChildTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ChildTable},${KeyMode},"?","","    ") ;:Script>" 
	CALL ${PrepStmtPrefix}delete_${ChildTable}.Prepare(${PrepareStmtVariable})
	
END FUNCTION   # ${SqlPrepareQueriesFct}_${ModuleName}_${ChildTable}

FUNCTION ${SqlInsertFct}_${ChildTable}(${ArgumentPrefix}${RecordPrefix}${ChildTable})
## INSERT in table ${ChildTable} 
	DEFINE ${ArgumentPrefix}${RecordPrefix}${ChildTable} ${TypePrefix}FullRec_${ChildTable}
	DEFINE lsql_stmt_status INTEGER
	DEFINE lookup_status INTEGER
	DEFINE nb_deleted_rows INTEGER

	WHENEVER SQLERROR CONTINUE
	CALL ${PrepStmtPrefix}insert_${ChildTable}.Execute(
	<Script:print_table_columns($SRCHANDLE,${ChildTable},"child+","","","all","","${ArgumentPrefix}${RecordPrefix}${ChildTable}","","    ",""):Script>)
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status = 0
		WHEN sqlca.sqlcode < 0
			CALL display_error("${SqlInsertFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
			LET lsql_stmt_status = -1
	END CASE
	RETURN lsql_stmt_status
END FUNCTION   # ${SqlInsertFct}_${ChildTable}

FUNCTION ${SqlUpdateFct}_${ChildTable}(${ArgumentPrefix}prykey,${ArgumentPrefix}${RecordPrefix}${ChildTable})
## ${SqlUpdateFct}_${ChildTable} :update current ${ChildTable} record
	DEFINE ${ArgumentPrefix}prykey ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE ${ArgumentPrefix}${RecordPrefix}${ChildTable} ${TypePrefix}FullRec_${ChildTable}
	DEFINE lsql_stmt_status INTEGER
	DEFINE nb_modified_rows INTEGER
	
	WHENEVER SQLERROR CONTINUE
	CALL ${PrepStmtPrefix}update_${ChildTable}.Execute(<Script:print_table_columns($SRCHANDLE,${ChildTable},"child","","","attr","","${ArgumentPrefix}${RecordPrefix}${ChildTable}","","    ",""):Script>,
	${ArgumentPrefix}prykey.*)

	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status = 0
			LET nb_modified_rows = sqlca.sqlerrd[3]
		WHEN sqlca.sqlcode < 0
			CALL display_error("${SqlUpdateFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
			LET lsql_stmt_status = -1
			LET nb_modified_rows = 0
	END CASE
	RETURN lsql_stmt_status,nb_modified_rows
END FUNCTION  # ${SqlUpdateFct}_${ChildTable}

FUNCTION ${SqlDeleteFct}_${ChildTable}(${ArgumentPrefix}prykey)
## delete_${ChildTable} :delete Selected row in table ${ChildTable} 
	DEFINE ${ArgumentPrefix}prykey ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE lsql_stmt_status smallint
	DEFINE nb_deleted_rows INTEGER

	WHENEVER SQLERROR CONTINUE
	CALL ${PrepStmtPrefix}delete_${ChildTable}.Execute(${ArgumentPrefix}prykey.*)
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	CASE
		WHEN sqlca.sqlcode = 0
			LET lsql_stmt_status=0
			LET nb_deleted_rows = sqlca.sqlerrd[3]
		WHEN sqlca.sqlcode < 0 
			CALL display_error("${SqlDeleteFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
			LET lsql_stmt_status = -1
	END CASE
	RETURN lsql_stmt_status,nb_deleted_rows
END FUNCTION        # ${SqlDeleteFct}_${ChildTable}

################################################################################
FUNCTION ${SqlCheckPrimaryKeyFct}_${ChildTable}(${ArgumentPrefix}prykey)  
#"# This function Checks if primary key exists
## inbound parameter : record of primary key
## outbound parameter:  status > 0  if exists, 0 if no record, < 0 if error
################################################################################
	DEFINE ${ArgumentPrefix}prykey ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE pk_status INTEGER

	WHENEVER SQLERROR CONTINUE
	OPEN crs_${PrmryKeyPrefix}_${CursorSufx} USING  ${ArgumentPrefix}prykey.*
	FETCH crs_${PrmryKeyPrefix}_${CursorSufx} 
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	CASE sqlca.sqlcode
		WHEN 0 
			LET pk_status = 1
		WHEN 100
			LET pk_status = 0
		WHEN sqlca.sqlerrd[2] = 104
			LET pk_status = -1		# record locked
		WHEN sqlca.sqlcode < 0
			LET pk_status = sqlca.sqlcode
	END CASE
	RETURN pk_status
END FUNCTION   #  ${SqlCheckPrimaryKeyFct}_${ChildTable}

<Script: if ($ChildLookupTables > 0 ) {
	#bld_lookup_queries ( $ChildTable );
}:Script>

######################################################################################################################################################
FUNCTION ${FillArrayFromFgnKeyFct}${ChildTable} (${ArgumentPrefix}fgnkey,${ArgumentPrefix}mode)
# This function opens the array cursor , fetches the data to populate the 3 arrays
# inbound params: foreign key,
#                 read mode: VIEW -> default isolation, EDIT -> REPEATABLE READ
# outbound params: the 3 arrays
	DEFINE ${ArgumentPrefix}fgnkey ${TypePrefix}${JoinKeyPrefix}${ChildTable}
	define ${ArgumentPrefix}mode CHAR(5)
	DEFINE ${LocalVarPrefix}${ChildSRArray} DYNAMIC ARRAY OF ${TypePrefix}ArrElemChild_${FormName}
	DEFINE ${LocalVarPrefix}${ChildPkyArray} DYNAMIC ARRAY OF ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE ${LocalVarPrefix}${ChildActArray} DYNAMIC ARRAY OF ${TypePrefix}${ChildActArray}
	DEFINE elem_num INTEGER
	DEFINE sql_ok INTEGER

	# initializes arrays
	CALL ${LocalVarPrefix}${ChildSRArray}.clear()
	CALL ${LocalVarPrefix}${ChildPkyArray}.clear()
    CALL ${LocalVarPrefix}${ChildActArray}.clear()
	IF ${ArgumentPrefix}mode = "EDIT" THEN
		SET ISOLATION TO REPEATABLE READ
		# If we plan to edit records, all records will received a RR lock to protect the data set from being modified
	END IF

	WHENEVER SQLERROR CONTINUE
	CALL ${ArrCursorPrefix}_fgnkey_child_${ChildTable}.Open(${ArgumentPrefix}fgnkey.*)
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	LET elem_num = 1
	WHILE ${ArrCursorPrefix}_fgnkey_child_${ChildTable}.FetchNext (${LocalVarPrefix}${ChildActArray}[elem_num],${LocalVarPrefix}${ChildPkyArray}[elem_num].*,${LocalVarPrefix}${ChildSRArray}[elem_num].*) = 0
		LET elem_num = elem_num + 1
	END WHILE

	CASE
		WHEN sqlca.sqlcode = 100  # we have passed the last element, this element must be deleted
			# elem_num is 1 beyond real number of element, must delete last element
			CALL  ${LocalVarPrefix}${ChildSRArray}.deleteElement(elem_num)
			CALL ${LocalVarPrefix}${ChildPkyArray}.deleteElement(elem_num)
			CALL ${LocalVarPrefix}${ChildActArray}.deleteElement(elem_num)
			LET elem_num = elem_num - 1
		WHEN sqlca.sqlcode < 0
			LET elem_num = 0
	END CASE
	RETURN sqlca.sqlcode,elem_num,${LocalVarPrefix}${ChildActArray},${LocalVarPrefix}${ChildPkyArray},${LocalVarPrefix}${ChildSRArray}
END FUNCTION # ${FillArrayFromFgnKeyFct}${ChildTable} 

######################################################################################################################################################
FUNCTION ${DisplayArrayFct}${ChildTable} (${ArgumentPrefix}fgnkey,${ArgumentPrefix}browse)
# This function displays the array data (${ChildSRArray}) based on the foreign key 
# browse: False means that the array is displayed without possibility of browsing inside (just show array and skip to next parent row)
######################################################################################################################################################
	DEFINE ${ArgumentPrefix}fgnkey ${TypePrefix}${JoinKeyPrefix}${ChildTable}
	DEFINE ${ArgumentPrefix}browse BOOLEAN
	DEFINE ${LocalVarPrefix}${ChildSRArray} DYNAMIC ARRAY OF ${TypePrefix}ArrElemChild_${FormName}
	DEFINE ${LocalVarPrefix}${ChildPkyArray} DYNAMIC ARRAY OF ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE ${LocalVarPrefix}${ChildActArray} DYNAMIC ARRAY OF ${TypePrefix}${ChildActArray}
	DEFINE elem_num,choice INTEGER
	DEFINE ${ArrCurrVar},${ScrLineVar} INTEGER
	DEFINE sql_ok INTEGER
	DEFINE ${QbeStmtVariable} STRING
	DEFINE browse BOOLEAN
	DEFINE sql_stmt_status INTEGER

	CALL ${FillArrayFromFgnKeyFct}${ChildTable} (${ArgumentPrefix}fgnkey.*,"VIEW") 
	RETURNING sql_ok,elem_num,${LocalVarPrefix}${ChildActArray},${LocalVarPrefix}${ChildPkyArray},${LocalVarPrefix}${ChildSRArray}

	DISPLAY ARRAY ${LocalVarPrefix}${ChildSRArray}
	TO ${ChildScreenRecord}.*
		BEFORE DISPLAY
			IF browse = FALSE THEN
				# just display in the array without entering it
				EXIT DISPLAY
			END IF
	END DISPLAY

	RETURN elem_num
END FUNCTION    # ${DisplayArrayFct}${ChildTable}

###########################################################################################################
FUNCTION ${EditArrayFct}${ChildScreenRecord} (${ArgumentPrefix}fgnkey)
# This function calls the INPUT array function (${InputArrayFct}${ChildScreenRecord}) to edit the array data
# then, accordingly, the SQL statement functions (${ArrayBulkUpdFct})
# it is generally called from another module
###########################################################################################################
	DEFINE ${ArgumentPrefix}fgnkey ${TypePrefix}${JoinKeyPrefix}${ChildTable}
	DEFINE ${LocalVarPrefix}${ChildSRArray} DYNAMIC ARRAY OF ${TypePrefix}ArrElemChild_${FormName}
	DEFINE ${LocalVarPrefix}${ChildPkyArray} DYNAMIC ARRAY OF ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE ${LocalVarPrefix}${ChildActArray} DYNAMIC ARRAY OF ${TypePrefix}${ChildActArray}
	DEFINE ${ScrLineVar} INTEGER
	DEFINE ${ArrCurrVar} INTEGER
	DEFINE bulk_update_status SMALLINT
	DEFINE nbr_edited_rows INTEGER
	DEFINE sql_action SMALLINT
	DEFINE i smallint

	BEGIN WORK
	WHILE TRUE
		CALL ${InputArrayFct}${ChildScreenRecord} (${ArgumentPrefix}fgnkey.*) 
		RETURNING nbr_edited_rows,sql_action,${LocalVarPrefix}${ChildActArray},${LocalVarPrefix}${ChildPkyArray},${LocalVarPrefix}${ChildSRArray}
		IF nbr_edited_rows > 0 THEN
			CASE 
				WHEN  sql_action = 2
					CALL ${ArrayBulkUpdFct}${ChildTable} (${ArgumentPrefix}fgnkey.*,${LocalVarPrefix}${ChildActArray},${LocalVarPrefix}${ChildPkyArray},${LocalVarPrefix}${ChildSRArray}) 
					RETURNING bulk_update_status
					IF bulk_update_status > 0 THEN
							ROLLBACK WORK
						ERROR "${InputArrayFct} ${Failed}"
					ELSE
						ERROR "${InputArrayFct} ${Successful}"
						COMMIT WORK
						EXIT WHILE
					END IF
				WHEN sql_action = 1
					# No
					ERROR "Please INPUT ARRAY AGAIN"
				WHEN sql_action = 0
					# Cancel
					MESSAGE "Cancelled, exit INPUT ARRAY"
					EXIT WHILE
			END CASE
		ELSE
			# Nothing
			MESSAGE "Nothing has been changed"
			EXIT WHILE
		END IF
	END WHILE

END FUNCTION   # ${EditArrayFct}${ChildScreenRecord}

####################################################################################################################
FUNCTION ${InputArrayFct}${ChildScreenRecord} (${ArgumentPrefix}fgnkey)
## this function operates INPUT ARRAY for the table ${ChildTable}
# it handles 2 arrays:
# 1) the Input Data Array (${ChildSRArray}) will contain the data input by the user
# 2) the primary key array (${PrmryKeyPrefix}_${ParentTable}) contains the status for each element: 
#    NULL=>no data, 0=>elements not touched, 1=>element to INSERT, 2=>element to UPDATE, -1=>element to DELETE
#    and also contains the primary key values of each element
###################################################################################################################
	DEFINE ${ArgumentPrefix}fgnkey ${TypePrefix}${JoinKeyPrefix}${ChildTable}
	DEFINE ${LocalVarPrefix}${ChildSRArray} DYNAMIC ARRAY OF ${TypePrefix}ArrElemChild_${FormName}
	DEFINE ${LocalVarPrefix}${ChildPkyArray} DYNAMIC ARRAY OF ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE ${LocalVarPrefix}${ChildActArray} DYNAMIC ARRAY OF ${TypePrefix}${ChildActArray}
	DEFINE elem_num INTEGER
	DEFINE arrcnt INTEGER
	DEFINE ${ScrLineVar} INTEGER
	DEFINE ${ArrCurrVar} INTEGER
	DEFINE last_element INTEGER
	DEFINE lookup_status INTEGER
	DEFINE fky_exists BOOLEAN
	DEFINE sql_stmt_status INTEGER
	DEFINE nbr_edited_rows INTEGER
	DEFINE sql_action smallint
	DEFINE ins_key smallint
	DEFINE ${ChlSavFormRec} ${TypePrefix}ArrElemChild_${FormName}								# used to save the current element
	DEFINE sql_ok SMALLINT

	LET nbr_edited_rows = 0
	LET int_flag = FALSE
	LET ins_key = FALSE

	CALL ${FillArrayFromFgnKeyFct}${ChildTable} (${ArgumentPrefix}fgnkey.*,"EDIT") 
	RETURNING sql_ok,elem_num,${LocalVarPrefix}${ChildActArray},${LocalVarPrefix}${ChildPkyArray},${LocalVarPrefix}${ChildSRArray}

	INPUT ARRAY ${LocalVarPrefix}${ChildSRArray} WITHOUT DEFAULTS
	FROM ${ChildScreenRecord}.*

		ON ACTION "CANCEL"
			# Cancel from input
			LET int_flag=false
			LET ${ArrCurrVar} = arr_curr()
			LET ${ScrLineVar} = scr_line ()
			LET  ${LocalVarPrefix}${ChildSRArray}[${ArrCurrVar}].* = ${ChlSavFormRec}.*
			DISPLAY ${LocalVarPrefix}${ChildSRArray}[${ArrCurrVar}].* TO ${ChildScreenRecord}[${ScrLineVar}].*
			MESSAGE "${CancelCom} ${CancelKey}"
			ROLLBACK WORK
			EXIT INPUT

		BEFORE DELETE
			# save the element
			LET  ${ChlSavFormRec}.* = ${LocalVarPrefix}${ChildSRArray}[${ArrCurrVar}].*

		BEFORE INSERT
			# insert a row in ${LocalVarPrefix}${ChildPkyArray} and ${LocalVarPrefix}${ChildActArray}
			LET ${ArrCurrVar} = arr_curr()
			LET ${ScrLineVar} = scr_line ()
			CALL ${LocalVarPrefix}${ChildPkyArray}.insert(${ArrCurrVar})
			CALL ${LocalVarPrefix}${ChildActArray}.insert(${ArrCurrVar})
			INITIALIZE ${LocalVarPrefix}${ChildPkyArray}[${ArrCurrVar}].* TO NULL
			LET ${LocalVarPrefix}${ChildActArray}[${ArrCurrVar}] = "I" 

		BEFORE ROW
			LET ${ScrLineVar} = scr_line()
			LET ${ArrCurrVar} = arr_curr()
			LET ${ChlSavFormRec}.* = ${LocalVarPrefix}${ChildSRArray}[${ArrCurrVar}].*		# save the current row

		<Script: 
			print_input_events($SRCHANDLE,$MainFormName,${ChildTable},"child","pkey|fkey","${LocalVarPrefix}${ChildSRArray}","       ","${ArgumentPrefix}fgnkey" );
		:Script>

		<Script: if ($DoPickListWindows eq 'true' && $ChildLookupTables > 0 ) { 
			bld_picklist_calls($ChildTable) ;
		}:Script>

		AFTER ROW
			IF field_touched (${ChildScreenRecord}[${ScrLineVar}].*) THEN
				LET nbr_edited_rows = nbr_edited_rows + 1
				IF ${LocalVarPrefix}${ChildActArray}[${ArrCurrVar}] = "=" THEN	# existing row that has been modified
					LET ${LocalVarPrefix}${ChildActArray}[${ArrCurrVar}] = "U"	# to be modified
					<Script: set_pk_values($SRCHANDLE,$MainFormName,$ChildScreenRecord,"${LocalVarPrefix}${ChildSRArray}","${LocalVarPrefix}${ChildPkyArray}",$ParentTable,$ChildTable,"${ArgumentPrefix}fgnkey","update") :Script>
				END IF
			ELSE
				IF ${LocalVarPrefix}${ChildActArray}[${ArrCurrVar}] = "I" THEN	# do Nothing
					LET ${LocalVarPrefix}${ChildActArray}[${ArrCurrVar}] = NULL	# to be left as is
				END IF
			END IF

		AFTER INSERT
			IF field_touched (${ChildScreenRecord}[${ScrLineVar}].*) THEN
				LET ${LocalVarPrefix}${ChildActArray}[${ArrCurrVar}] = "I"	# to be inserted
				<Script: set_pk_values($SRCHANDLE,$MainFormName,$ChildScreenRecord,"${LocalVarPrefix}${ChildSRArray}","${LocalVarPrefix}${ChildPkyArray}",$ParentTable,$ChildTable,"${ArgumentPrefix}fgnkey","insert") :Script>
			END IF

		AFTER DELETE                    
			IF ${LocalVarPrefix}${ChildActArray}[${ArrCurrVar}] IS NOT NULL THEN
				#  General idea: the ${LocalVarPrefix}${ChildActArray} current element is deleted by the DELETE action,
				# then the  ${LocalVarPrefix}${ChildPkyArray} and ${LocalVarPrefix}${ChildActArray} current elements are moved 
				# to the bottom of the array so that the element can be deleted without impacting the order of other elements
				# 1) proceed for ${LocalVarPrefix}${ChildPkyArray}
				CALL ${LocalVarPrefix}${ChildPkyArray}.AppendElement()   			# append one element at the end that will contain deleted element data
				LET last_element = ${LocalVarPrefix}${ChildPkyArray}.getsize()		# check the new array size
				LET ${LocalVarPrefix}${ChildPkyArray}[last_element].* = ${LocalVarPrefix}${ChildPkyArray}[${ArrCurrVar}].*
				CALL ${LocalVarPrefix}${ChildPkyArray}.DeleteElement(${ArrCurrVar})	# finally delete the current element
				# 2) then same action for action array
				CALL ${LocalVarPrefix}${ChildActArray}.AppendElement()
				LET ${LocalVarPrefix}${ChildActArray}[last_element] = "D" 			  # to be Deleted
				CALL ${LocalVarPrefix}${ChildActArray}.DeleteElement(${ArrCurrVar})
				LET nbr_edited_rows = nbr_edited_rows + 1
			END IF
			

		AFTER INPUT
			IF int_flag THEN
				LET int_flag = FALSE
				ERROR " ${Cancel} ${ChildTable}"
				LET nbr_edited_rows = 0
				LET sql_action = 0
			ELSE
				LET sql_action = confirm_operation(5,10,"${InputArrayFct} ") 
				IF sql_action = 1 THEN
					CONTINUE INPUT
				END IF
			END IF
	END INPUT
	RETURN nbr_edited_rows,sql_action,${LocalVarPrefix}${ChildActArray},${LocalVarPrefix}${ChildPkyArray},${LocalVarPrefix}${ChildSRArray}
END FUNCTION    # ${InputArrayFct}${ChildScreenRecord}

######################################################################################################
FUNCTION ${SetTableRecordFct}_${ChildScreenRecord}_${ChildTable}(p_sql_stmt_type,${ArgumentPrefix}fgnkey,${ArgumentPrefix}prykey,${ArgumentPrefix}element_contents)
# This function assigns the values from the array element(${ArgumentPrefix}element_contents) to the table record (${LocalVarPrefix}table_contents)
# It distinguishes the primary key (${ArgumentPrefix}prykey) of the table ${ChildTable}and the foreign key (${ArgumentPrefix}fgnkey) point to the parent table (${ParentTable})
######################################################################################################
	DEFINE p_sql_stmt_type CHAR(1)			-- "I" => INSERT   "U" => UPDATE
	DEFINE ${ArgumentPrefix}fgnkey ${TypePrefix}${JoinKeyPrefix}${ChildTable}
	DEFINE ${ArgumentPrefix}prykey ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE ${ArgumentPrefix}element_contents ${TypePrefix}ArrElemChild_${FormName}      # One element of the Screen Record Array
	DEFINE fgl_status SMALLINT
	DEFINE ${LocalVarPrefix}table_contents ${TypePrefix}FullRec_${ChildTable}
	
	#WHENEVER SQLERROR CONTINUE
	INITIALIZE ${LocalVarPrefix}table_contents.* TO NULL
	CASE p_sql_stmt_type
	WHEN "I"		-- set table record to insert row
		<Script:set_table_record ($SRCHANDLE,$ChildTable,$FormName,"child","${ArgumentPrefix}element_contents","${LocalVarPrefix}table_contents","I",$ChildScreenRecord,"${ArgumentPrefix}fgnkey") :Script>
	
	WHEN "U"		-- set table record to update row
		<Script:set_table_record ($SRCHANDLE,$ChildTable,$FormName,"child","${ArgumentPrefix}element_contents","${LocalVarPrefix}table_contents","U",$ChildScreenRecord,"${ArgumentPrefix}fgnkey") :Script>
	END CASE
	
	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
        WHEN status = 0
            LET fgl_status = 1
        WHEN status < 0
            LET fgl_status = status
    	OTHERWISE
	    	LET fgl_status = status
	END CASE
	RETURN fgl_status,${LocalVarPrefix}table_contents.*
END FUNCTION        # ${SetTableRecordFct}_${ChildScreenRecord}_${ChildTable}

#############################################################################################################
FUNCTION ${ArrayBulkUpdFct}${ChildTable} (${ArgumentPrefix}fgnkey,${ArgumentPrefix}${ChildActArray},${ArgumentPrefix}${ChildPkyArray},${ArgumentPrefix}${ChildSRArray})
## This functions browses the action array ${ArgumentPrefix}${ChildActArray}},
# copies the element values to table values (${ChildTable})
# and executes the request SQL operation requested for each element
#############################################################################################################
	DEFINE ${ArgumentPrefix}fgnkey ${TypePrefix}${JoinKeyPrefix}${ChildTable}
	DEFINE ${ArgumentPrefix}${ChildSRArray} DYNAMIC ARRAY OF ${TypePrefix}ArrElemChild_${FormName}
	DEFINE ${ArgumentPrefix}${ChildPkyArray} DYNAMIC ARRAY OF ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE ${ArgumentPrefix}${ChildActArray} DYNAMIC ARRAY OF ${TypePrefix}${ChildActArray}
	DEFINE idx,arr_size INTEGER
	DEFINE updarr_status,fgl_status,global_status INTEGER
	DEFINE parent_fky ${TypePrefix}${JoinKeyPrefix}${ChildTable}      # foreign key pointing to parent table
	DEFINE elements_contents ${TypePrefix}ArrElemChild_${FormName}         # One element of the Screen Record Array
	DEFINE l_${ChildTable} ${TypePrefix}FullRec_${ChildTable}

	LET global_status = 0
	LET arr_size = ${ArgumentPrefix}${ChildPkyArray}.getsize()
	FOR idx = 1 TO arr_size
		CASE
            WHEN ${ArgumentPrefix}${ChildActArray}[idx] = "="
                CONTINUE FOR
            WHEN ${ArgumentPrefix}${ChildActArray}[idx] MATCHES "[IU]"		# Insert,delete or update
                CALL ${SetTableRecordFct}_${ChildScreenRecord}_${ChildTable} (${ArgumentPrefix}${ChildActArray}[idx],${ArgumentPrefix}fgnkey.*,${ArgumentPrefix}${ChildPkyArray}[idx].*,${ArgumentPrefix}${ChildSRArray}[idx].*)
                RETURNING fgl_status,l_${ChildTable}.*
		END CASE
		CALL ${SqlArrayUpdateOneElemFct}${ChildTable}(${ArgumentPrefix}fgnkey.*,${ArgumentPrefix}${ChildActArray}[idx],${ArgumentPrefix}${ChildPkyArray}[idx].*,l_${ChildTable}.*) 
		RETURNING updarr_status 
		IF updarr_status < 0 THEN
			ERROR "Error on element # ",idx
			LET global_status = global_status + 1
		END IF
	END FOR
	RETURN global_status
END FUNCTION 

###############################################################################
FUNCTION ${SqlArrayUpdateOneElemFct}${ChildTable} (${ArgumentPrefix}fgnkey,${ArgumentPrefix}Action,${ArgumentPrefix}prykey,${ArgumentPrefix}${RecordPrefix}${ChildTable})
## This function executes the SQL statement for each element
## accord the to status array value of this element
###############################################################################
	DEFINE ${ArgumentPrefix}fgnkey ${TypePrefix}${JoinKeyPrefix}${ChildTable}
	DEFINE ${ArgumentPrefix}prykey ${TypePrefix}${PrmryKeyPrefix}${ChildTable}
	DEFINE ${ArgumentPrefix}Action CHAR(1)
	DEFINE ${ArgumentPrefix}${RecordPrefix}${ChildTable} ${TypePrefix}FullRec_${ChildTable}
	DEFINE st SMALLINT
	DEFINE arrcnt SMALLINT
	DEFINE idx SMALLINT 
	DEFINE statut SMALLINT

	LET st = 0
		CASE ${ArgumentPrefix}Action
			WHEN "U"	# must be updated
				CALL ${SqlUpdateFct}_${ChildTable}(${ArgumentPrefix}prykey.*,${ArgumentPrefix}${RecordPrefix}${ChildTable}.*) RETURNING statut
		WHEN "I"	# must be inserted
				CALL ${SqlInsertFct}_${ChildTable}(${ArgumentPrefix}${RecordPrefix}${ChildTable}.*) RETURNING statut
		WHEN "D"	# must be deleted
				CALL ${SqlDeleteFct}_${ChildTable}(${ArgumentPrefix}prykey.*) RETURNING statut
		END CASE
	return statut
END FUNCTION

<Script: if ($ChildLookupTables > 0 ) {
	if (defined($GenerateLookupFunctions)) {
		bld_lookup_functions ( ${MainFormName},$ChildTable,"child","input" );
	}
}:Script>

<Script: if ( $QxWidgetsCount > 0 ) { 
	bld_populate_widgets_calls_function($SRCHANDLE,$MainFormName,".*","child") ;
	if (defined($GenerateWidgetPopulateFunctions)) {
		bld_populate_widgets_functions($SRCHANDLE,$MainFormName,".*","child") ;
	}
}  :Script>

<Script: intersect_and_union() :Script>