<Script:our $FormShortName=$FormName; $FormShortName=~ s/^f_//; :Script>noprint
<Script:our $MstTableRec=${TblPrfx} . ${RecordPrefix} . ${ParentTable} :Script>noprint}
<Script:our $LocalMstTableRec=${LocalVarPrefix} . ${TblPrfx} . ${RecordPrefix} . ${ParentTable} :Script>noprint}
<Script:our $InboundMstTableRec=${ArgumentPrefix} . ${TblPrfx} . ${RecordPrefix} . ${ParentTable} :Script>noprint}
<Script:our $MstInpFormRec=${FrmPrfx} . ${RecordPrefix} . ${FormShortName} :Script>noprint
<Script:our $LocalMstInpFormRec=${LocalVarPrefix} . ${FrmPrfx} . ${RecordPrefix} . ${FormShortName} :Script>noprint
<Script:our $InboundMstInpFormRec=${ArgumentPrefix} . ${FrmPrfx} . ${RecordPrefix} . ${FormShortName} :Script>noprint
<Script:our $MstSavFormRec=sav_${RecordPrefix} . ${FormShortName} :Script>noprint
<Script:our $MstLkUpRec=${SRLUpPrfx} . ${ModuleName} :Script> noprint
<Script:our $GlobalReferenceTable="kandoouser" :Script> noprint
<Script:our $GlobalReferenceRecord=${GlobalVarPrefix} . ${RecordPrefix} . ${GlobalReferenceTable} :Script> noprint
<Script:our $ListTable=${ParentTable} :Script> noprint
<Script:our $BMLetter=substr(${ModuleName},0,1) :Script> noprint
<Script:our $BMCode=substr(${ModuleName},0,2) :Script> noprint
@GlobalDef
@ModuleDef
<AddRqrmnt:lib::lib_tool:AddRqrmnt> 
<AddRqrmnt:lib::lib_tool_db:AddRqrmnt> 
<AddRqrmnt:lib::lib_tool_windecoration:AddRqrmnt> 
<AddRqrmnt:lib::lib_tool_${BMLetter}_${BMCode}:AddRqrmnt> 

# module  generated by KandooERP Ffg(c)
# Generated on ${GenerationTS}
# Main template ${MainModuleTemplate} 

GLOBALS "common/glob_GLOBALS.4gl"
	<Script: $QxWidgetsCount=define_Widgets ($SRCHANDLE,$MainFormName,".*",".*")  :Script> 
	DEFINE ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} TYPE AS RECORD 		# This is the TYPE for form image record
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"ParentFormonly","parent",".*",".*","all","","\t\t")  :Script>
	END RECORD
	
	DEFINE ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} TYPE AS RECORD 			# This is the TYPE for table image record
		<Script:define_table_columns ($SRCHANDLE,${ParentTable},"parent+","","all","record",$MstTableRec,"    "):Script>
	END RECORD
	
	DEFINE ${TypeDataPrefix}prykey_${ParentTable} TYPE AS RECORD 						# This is the TYPE for the primary key
		<Script: define_PK_columns ($SRCHANDLE,${ParentTable},"pky",$DefineStyle);
		our $ParentPryKeyColList=$TablesList{$ParentTable}->{PrimaryKey};
		:Script>
	END RECORD

	<Script: if ( $ParentLookupTables > 0 ) { 
		define_lookup_fields ($MainFormName,"parent","astype",$Tabul,$WriteMode,$isRecord) 
	}:Script>

	CONSTANT CLASSIC_MODE_EDIT  = "EDIT"
	CONSTANT CLASSIC_MODE_ADD  = "ADD"
	DEFINE ${ModuleVarPrefix}program CHAR(30)

	# Define cursors and prepared statements
	DEFINE crs_row_${ParentTable} CURSOR
	DEFINE crs_pky_${ParentTable} CURSOR
	DEFINE crs_upd_${ParentTable} CURSOR
	DEFINE crs_cnt_${ParentTable} CURSOR
	DEFINE crs_scrl_pky_${ParentTable} CURSOR
	DEFINE pr_ins_${ParentTable} PREPARED
	DEFINE pr_upd_${ParentTable} PREPARED
	DEFINE pr_del_${ParentTable} PREPARED
	
MAIN
	DEFER INTERRUPT
	
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	CALL setModuleId("ProgramName")			# put program name here (1 letter 2 or 3 digits)
	CALL ui_init(0)		#Initial UI Init
	DEFER QUIT
	DEFER INTERRUPT

	CALL main_${ModuleName}()

END MAIN

##########################################################################
FUNCTION main_${ModuleName} ()
## this module's main function called by MAIN

	CALL security(getModuleId()) #authenticate
	--CALL init_${BMLetter}_${BMCode}()      #init utility module	# put Business module letter + 2 letters
	CALL ${SqlPrepareQueriesFct}_parent_${ModuleName} () # initialize all cursors on master table
	<Script: if ( $ChildTable ne "" ) { 
		print "CALL ${SqlPrepareQueriesFct}_${ModuleName}_child\()     # initialize allcursors on Child table" ;
	}:Script>

	OPEN WINDOW ${MainFormName} WITH FORM "${MainFormName}"
	<Script: if (defined(ThisModuleInitWidgetsFct)) {
		print "CALL ${ThisModuleInitWidgetsFct}()";
	}:Script>

	CALL menu_${ModuleName}_parent()      

	CLOSE WINDOW ${MainFormName}

END FUNCTION	# main_${ModuleName}

######################################################################
FUNCTION menu_${ModuleName}_parent ()
## menu_${ModuleName}_parent
## the top level menu 
## input arguments: none
## output arguments: none
	DEFINE nbsel_${ParentTable} INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE record_num INTEGER
	DEFINE action smallint
	DEFINE xnumber smallint
	DEFINE arr_elem_num smallint
	DEFINE l_prykey_${ParentTable} ${TypeDataPrefix}prykey_${ParentTable} 					# Primary key record
	DEFINE ${LocalMstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record
	DEFINE ${LocalMstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	DEFINE where_clause STRING
	DEFINE record_found INTEGER
	DEFINE lookup_status INTEGER

	LET nbsel_${ParentTable} = 0
	MENU "${ParentTable}"
	BEFORE MENU
		<Script:
		$line="HIDE OPTION \"${NextOption}\",\"${PreviousOption}\",\"${EditOption}\",\"${SuppressOption}\"";
		printNoLF $line;
		if ( defined($ChildTable) ) { 
			$line=",\"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
			print $line;
		} :Script>
		
	COMMAND "${QueryOption}" "${QueryCom} ${ParentTable}"
		MESSAGE ""
		INITIALIZE ${LocalMstInpFormRec}.* TO NULL
		CLEAR FORM
		DISPLAY BY NAME ${LocalMstInpFormRec}.*
		HIDE OPTION "${NextOption}","${PreviousOption}"

		# Build the QBE where clause
		CALL ${FrmConstructDatasetFct}_parent_${ModuleName}() RETURNING where_clause   
		IF where_clause IS NOT NULL THEN
			# Call the function that counts matching rows and opens the scroll cursor on primary key
			CALL ${SqlDeclarePkyScrCrsFct}_parent_${ModuleName}(where_clause)
			RETURNING nbsel_${ParentTable},sql_stmt_status
			WHENEVER SQLERROR CONTINUE
			CALL crs_scrl_pky_${ParentTable}.Open()
			WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
			
			IF nbsel_${ParentTable} > 0 THEN 
				CALL ${SqlNextPrevFct}_parent_${ModuleName}(1) RETURNING record_found,
				l_prykey_${ParentTable}.*

				CASE
					WHEN record_found = 1
						LET record_num = 1
						CALL ${SqlFetchFullRowFct}_parent_${ModuleName} (l_prykey_${ParentTable}.*)
						RETURNING record_found,${LocalMstInpFormRec}.*
						CALL ${FrmDisplayRecordFct}_parent_${ModuleName}_${MainFormName}(${LocalMstInpFormRec}.*)
						<Script: if ( defined($ChildTable) ) {
							print "CALL ${DisplayArrayFct}${ChildTable} (l_prykey_${ParentTable}.*,TRUE) RETURNING arr_elem_num ";
							print "IF arr_elem_num > 0 THEN";
							$line="\tSHOW OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
							print $line;
							print "ELSE";
							$line="\tHIDE OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
							print $line;
							print "END IF";
						} :Script>
					WHEN record_found = -1 
						ERROR "${Unreachable} ",sqlca.sqlcode
				END CASE
				IF nbsel_${ParentTable} > 1 THEN
					SHOW OPTION "${NextOption}"
					NEXT OPTION "${NextOption}"
				END IF
				SHOW OPTION "${EditOption}","${SuppressOption}"
			ELSE 
				ERROR "${NorowsSelected}"
				NEXT OPTION "${QueryOption}"
			END IF
		END IF
		
	COMMAND "${NextOption}" "${NextCom} ${ParentTable}"
		MESSAGE ""
		CLEAR FORM
		INITIALIZE ${LocalMstInpFormRec}.* TO NULL

		IF record_num <= nbsel_${ParentTable} THEN
			CALL ${SqlNextPrevFct}_parent_${ModuleName}(1) RETURNING record_found,
			l_prykey_${ParentTable}.*

			CASE 
			WHEN record_found = 0 
				ERROR "${Lastrow} ${ParentTable}"
			WHEN record_found = -1 
				ERROR "${Unreachable} ",sqlca.sqlcode
			WHEN record_found = 1
				LET record_num = record_num + 1
				CALL ${SqlFetchFullRowFct}_parent_${ModuleName} (l_prykey_${ParentTable}.*)
				RETURNING record_found,${LocalMstInpFormRec}.*
				CALL ${FrmDisplayRecordFct}_parent_${ModuleName}_${MainFormName}(${LocalMstInpFormRec}.*)
				<Script: if ( defined($ChildTable) ) {
					print "CALL ${DisplayArrayFct}${ChildTable} (l_prykey_${ParentTable}.*,TRUE) RETURNING arr_elem_num ";
					print "IF arr_elem_num > 0 THEN";
					$line="\tSHOW OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
					print $line;
					print "ELSE";
					$line="\tHIDE OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
					print $line;
					print "END IF";
				} :Script>

				IF record_num >= nbsel_${ParentTable} THEN
				   HIDE OPTION "${NextOption}"
				END IF
                IF record_num > 1 THEN
                	SHOW OPTION "${PreviousOption}"
                ELSE
                	HIDE OPTION "${PreviousOption}"
				END IF
			END CASE
		ELSE
			ERROR " ${SelectFirst}  ${ParentTable} "
			NEXT OPTION "${QueryOption}" 
		END IF

	COMMAND "${PreviousOption}" "${PreviousCom} ${ParentTable}"
		MESSAGE ""
		CLEAR FORM
		INITIALIZE ${LocalMstInpFormRec}.* TO NULL

		IF record_num >= 1  THEN
			CALL ${SqlNextPrevFct}_parent_${ModuleName}(-1) RETURNING record_found,
			l_prykey_${ParentTable}.*
			CASE 
			WHEN record_found = 0
				ERROR "${FirstRow} ${ParentTable}"
			WHEN record_found < -1
				ERROR "${Unreachable} ",sqlca.sqlcode
			WHEN record_found = 1
				LET record_num = record_num - 1
				CALL ${SqlFetchFullRowFct}_parent_${ModuleName} (l_prykey_${ParentTable}.*)
				RETURNING record_found,${LocalMstInpFormRec}.*
				
				CALL ${FrmDisplayRecordFct}_parent_${ModuleName}_${MainFormName}(${LocalMstInpFormRec}.*)
				<Script: if ( defined($ChildTable) ) { 
					print "CALL ${DisplayArrayFct}${ChildTable} (l_prykey_${ParentTable}.*,TRUE) RETURNING arr_elem_num ";
					print "IF arr_elem_num > 0 THEN";
					$line="\tSHOW OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
					print $line;
					print "ELSE";
					$line="\tHIDE OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
					print $line;
					print "END IF";
				} :Script>

				IF record_num = 1  THEN
				   HIDE OPTION "${PreviousOption}"
				END IF
                IF record_num < nbsel_${ParentTable} THEN
                	SHOW OPTION "${NextOption}"
                ELSE
                	HIDE OPTION "${NextOption}"
				END IF
			END CASE
		ELSE
			ERROR " ${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

	COMMAND "${AddOption}" "${InsertCom} ${ParentTable}"
		MESSAGE ""
		CALL ${FrmInputRecordFct}_parent_${ModuleName}(MODE_CLASSIC_ADD,l_prykey_${ParentTable}.*,${LocalMstInpFormRec}.*) 
		RETURNING sql_stmt_status,l_prykey_${ParentTable}.*
		MESSAGE ""
		<Script: if ( defined($ChildTable) ) {
			print "SHOW OPTION \"${EditArrayMessage}${ChildTable}\"";
#			print "CALL ${FillArrayFromFgnKeyFct}${ChildTable} (l_prykey_${ParentTable}.*)" ;
		} :Script>

	COMMAND "${EditOption}" "${UpdateCom} ${ParentTable}"
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF ${SqlCheckPrimaryKeyFct}_${ParentTable}(l_prykey_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${NextOption}"
			ELSE
				CALL ${FrmInputRecordFct}_parent_${ModuleName}(MODE_CLASSIC_EDIT,l_prykey_${ParentTable}.*,${LocalMstInpFormRec}.*) 
				RETURNING sql_stmt_status,l_prykey_${ParentTable}.*
			END IF
		ELSE
			ERROR " ${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

   COMMAND "${SuppressOption}" "${DeleteCom} ${ParentTable}"
		<Script: if ($DoHelp eq 'true') {
			print "		HELP 6000";
		} :Script>
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF ${SqlCheckPrimaryKeyFct}_${ParentTable}(l_prykey_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${NextOption}"
			END IF
			WHILE TRUE
				CALL confirm_operation(5,10,"${SuppressOption}") RETURNING action
				CASE 
				WHEN action = 0 OR action = 1 
					EXIT WHILE  # degage abandon
				WHEN action = 2   
					CALL ${FrmSuppressRecordFct}_parent_${ModuleName}(l_prykey_${ParentTable}.*)
					RETURNING sql_stmt_status
					EXIT WHILE
				END CASE
			END WHILE
		ELSE
			ERROR "${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

	<Script: if ( defined($ChildTable) ) { 
		print "ON ACTION \"${ViewArrayOption}\"";
		print "\tCALL ${DisplayArrayFct}${ChildTable} (l_prykey_${ParentTable}.*,False)"; 
		print "ON ACTION \"${EditArrayOption}\"";
		print "\tCALL ${EditArrayFct}${ChildScreenRecord} (l_prykey_${ParentTable}.*)";
	} :Script>
	
	COMMAND "${Quit}" "${QuitCom}"
		MESSAGE ""
		EXIT MENU
	END MENU
END FUNCTION		# menu_${ModuleName}_parent ()

#######################################################################
FUNCTION ${FrmConstructDatasetFct}_parent_${ModuleName}()
## ${FrmConstructDatasetFct}_parent_${ModuleName}_${MainFormName} : Query By Example on table ${ParentTable}
## Input selection criteria,
## prepare the query,
## open the data set
	DEFINE qbe_statement,where_clause STRING
	DEFINE xnumber,sql_stmt_status INTEGER
	DEFINE l_prykey ${TypeDataPrefix}prykey_${ParentTable} 

	DEFINE ${LocalMstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record

	DEFINE reply CHAR(5)
	LET xnumber = 0
	MESSAGE "${InputCriteria}"
	# initialize record and display blank
	CLEAR FORM
	INITIALIZE ${LocalMstInpFormRec}.* TO NULL
	DISPLAY BY NAME ${LocalMstInpFormRec}.* 

	CONSTRUCT BY NAME where_clause ON <Script: print_form_fields ($SRCHANDLE,$MainFormName,$ParentTable,"parent",".*","false",".*","TblName","\t\t","","","reset"):Script>

	## Check whether criteria have been entered
	AFTER CONSTRUCT 
		IF NOT field_touched(<Script: print_form_fields ($SRCHANDLE,$MainFormName,$ParentTable,"parent",".*","false",".*","TblName","\t\t","","","reset"):Script>)
		AND NOT int_flag THEN
			LET reply = fgl_winbutton("","${SelectAllRows}","${Yes}","${Yes}|${No}","question",0)
			CASE 
			WHEN reply MATCHES "${Yes}"
				EXIT CONSTRUCT 
			OTHERWISE                  # Saisie d'un critere de selection
				ERROR "${Oneatleast}"
				CONTINUE CONSTRUCT
			END CASE
		END IF
	END CONSTRUCT

	IF int_flag = TRUE THEN
		LET where_clause = NULL
		MESSAGE "${CancelCom}"
		LET int_flag=0
	END IF
	RETURN where_clause
END FUNCTION		## ${FrmConstructDatasetFct}_parent_${ModuleName}

<:Include Kandoo-parent-common-functions.mtplt :Include>