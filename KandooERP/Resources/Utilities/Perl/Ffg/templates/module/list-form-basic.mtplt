<Script:our $ListFormRec=${FrmPrfx}${RecordPrefix}${FormShortName} :Script>noprint
# module  generated by KandooERP Ffg(c)
# Generated on ${GenerationTS}
# Main template ${ListModuleTemplate} 
DATABASE ${DatabaseName}
	DEFINE ${TypeDataPrefix}frm_list_${FormName} TYPE AS RECORD 		# This is the TYPE for form image record
		<Script:define_form_fields($SRCHANDLE,$FormName,${ListTable},    "list",      "list",  "false", "all",  "","\t\t")  :Script>
	END RECORD

	DEFINE ${TypeDataPrefix}${PrmryKeyPrefix}_${ListTable} TYPE AS RECORD 
		<Script:define_PK_columns ($SRCHANDLE,${ListTable},"pky",$DefineStyle):Script>
	END RECORD

#######################################################################
FUNCTION ${FrmFctPrefix}_${QueryOption}_${ModuleName}_${FormName}()
## ${FrmFctPrefix}_${QueryOption}_${ModuleName}_${FormName}: Query By Example on table ${ListTable}
## Input selection criteria,
## prepare the query,
## open the data set
	DEFINE ${QbeStmtVariable},${WhereClauseVariable} STRING
	DEFINE xnumber,${SqlStmtStatus} INTEGER
	DEFINE l_pky ${TypeDataPrefix}${PrmryKeyPrefix}_${ListTable} 

	DEFINE ${ListFormRec} ${TypeDataPrefix}frm_list_${FormName} 	# Form image record

	DEFINE reply CHAR(5)
	LET xnumber = 0
	MESSAGE "${InputCriteria}"
	# initialize record and display blank
	CLEAR FORM
	INITIALIZE ${ListFormRec}.* TO NULL

	--CONSTRUCT BY NAME ${WhereClauseVariable} ON <Script: print_form_fields ($SRCHANDLE,$FormName,$ListTable,"parent",".*","false",".*",${ListTable},"\t\t\t","","","reset"):Script>
	CONSTRUCT BY NAME where_clause ON <Script: print_form_fields ($SRCHANDLE,$FormName,$ListTable,"list",".*",".*","false","TblName","\t\t\t","","","reset"):Script>
		<Script: if (defined($do_build_help) ) {  
			print "ON KEY (\"$Helpkey\")";
			print "\tCALL help_${ListTable}()";
		 }:Script>

	## Check whether criteria have been entered
	AFTER CONSTRUCT 
		IF NOT field_touched(${PickListScreenRecord}.*) AND NOT int_flag THEN
			LET reply = fgl_winbutton("","${SelectAllRows}","${Yes}","${Yes}|${No}","question",0)
			CASE 
			WHEN reply MATCHES "${Yes}"
				EXIT CONSTRUCT 
			OTHERWISE                  # Saisie d'un critere de selection
				ERROR "${Oneatleast}"
				CONTINUE CONSTRUCT
			END CASE
		END IF
	END CONSTRUCT

	IF int_flag = TRUE THEN
		LET ${WhereClauseVariable} = NULL
		MESSAGE "${CancelCom}"
		LET int_flag=0
	END IF
	RETURN ${WhereClauseVariable}
END FUNCTION		## ${FrmFctPrefix}_${QueryOption}_${ModuleName}_${FormName}

FUNCTION ${ListRecordsFct}_${ModuleName}(p_${WhereClauseVariable})
	DEFINE idx,choice INTEGER
	DEFINE ${ArrCurrVar},${ScrLineVar} INTEGER
	DEFINE ${ElementIsPicked} SMALLINT
	DEFINE ${QbeStmtVariable} STRING
	DEFINE p_${WhereClauseVariable} STRING

	DEFINE ${PLWPrefix}${PrmryKeyPrefix}_array DYNAMIC ARRAY OF ${TypeDataPrefix}${PrmryKeyPrefix}_${ListTable}				# Keep all the primary keys of the list table to return

	DEFINE ${PLWPrefix}attr_array DYNAMIC ARRAY OF ${TypeDataPrefix}frm_list_${FormName}

	--OPEN WINDOW ${PLWPrefix}${ListTable}
	--WITH FORM "${FormName}" ATTRIBUTES(border)

	SET ISOLATION TO DIRTY READ

	# Prepare cursor with primary key + columns of the display array form
	LET ${QbeStmtVariable} = "SELECT <Script:print_table_columns($SRCHANDLE,${ListTable},"","","","pkey","record","","flat","    "); :Script>,",
	"<Script:print_form_fields ($SRCHANDLE,${FormName},${ListTable},"list",".*","false",".*","","\t\t","","","reset"):Script> ",
	" FROM ${ListTable} ",
	"WHERE ",p_${WhereClauseVariable} clipped,
	" ORDER BY <Script:print_table_columns($SRCHANDLE,${ListTable},"","","",pkey,"","","","flat","",$endline,1); :Script>"

	PREPARE prp_lst_${ListTable} FROM ${QbeStmtVariable}

	# crs_scrl_${PrmryKeyPrefix}_${ListTable} : the first cursor selects all the primary keys (not all the table columns)
	DECLARE ${LstCursorPrefix}${ListTable} CURSOR
	FOR prp_lst_${ListTable}

	SET ISOLATION TO ${LooseIsolationLevel}

	LET idx=1
	FOREACH ${LstCursorPrefix}${ListTable} INTO ${PLWPrefix}${PrmryKeyPrefix}_array[idx].*,${PLWPrefix}attr_array[idx].*
		LET idx = idx + 1
	END FOREACH
	SET ISOLATION TO ${DefaultIsolationLevel}
	CALL  ${PLWPrefix}attr_array.deleteElement(idx)

	LET idx=idx - 1

MESSAGE "${PLMessage} for ${ListTable} :${PLWAcceptKey}" 
DISPLAY ARRAY ${PLWPrefix}attr_array 
TO ${PickListScreenRecord}.*
	BEFORE ROW
		LET ${ArrCurrVar}=arr_curr()
		LET ${ScrLineVar}=scr_line()

	AFTER ROW
		LET ${ArrCurrVar}=arr_curr()
		LET ${ScrLineVar}=scr_line()
	AFTER DISPLAY
		if int_flag THEN
			LET ${ElementIsPicked}=0
		ELSE
			LET ${ElementIsPicked}=1
		END IF
		
END DISPLAY
--CLOSE WINDOW ${PLWPrefix}${ListTable}

SET ISOLATION TO COMMITTED READ

RETURN ${ElementIsPicked},idx,<Script:print_table_columns($SRCHANDLE,${ListTable},"","","","pkey","record","${PLWPrefix}${PrmryKeyPrefix}_array[${ArrCurrVar}]","flat","    "); :Script>
END FUNCTION