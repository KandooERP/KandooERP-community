<Script:our $CursorSufx="m".${ParentTable} :Script>noprint
<Script:our $MstTableRec=${TblPrfx} . ${ModuleName} :Script>noprint}
<Script:our $MstInpFormRec=${SRInpPrfx} . ${ModuleName} :Script>noprint
<Script:our $MstSavFormRec=${SRSavPrfx} . ${ModuleName} :Script>noprint
<Script:our $MstLkUpRec=${SRLUpPrfx} . ${ModuleName} :Script> noprint
@GlobalDef
@ModuleDef
<AddRqrmnt:fgl::generic_functions.4gl:AddRqrmnt> 
# module  generated by Kandoo Ffg(c) 
# Generated on ${GenerationTS}

# template ${TemplateFile} 

<Script: $QxWidgetsCount=define_Widgets ($SRCHANDLE,$MainFormName,".*",".*") :Script> 
DATABASE ${DatabaseName}
	DEFINE ${ModuleVarPrefix}program CHAR(30)
	DEFINE ${MstTableRec} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>

	END RECORD
	DEFINE ${MstInpFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",".*","all","false","","\t\t")  :Script>
	END RECORD
	DEFINE ${MstSavFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",".*","all","false","","\t\t")  :Script>
	END RECORD

<Script: if ( $ParentLookupTables > 0 ) { 
	$IndentLevel=1;
	$OutLineNum=ffg_print($SRCHANDLE,"DEFINE ${MstLkUpRec} RECORD",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
	$IndentLevel++;
	define_form_fields($SRCHANDLE,$MainFormName,".*","lookup",".*","all","true","","\t\t");  
	$OutLineNum=ffg_print($SRCHANDLE,"\n\tEND RECORD",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 	
}:Script>

FUNCTION mc_${ModuleName}_sccs()
## definition variable sccs
	DEFINE sccs_var CHAR(70)
LET sccs_var="%W% %D%"
END FUNCTION

FUNCTION ${ViewEditRecordFct}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable})
## ${ViewEditRecordFct}_${ParentTable}

## This function is called by view_list, it will handle the record selected from the list 
## input arguments: ${PrmryKeyPrefix}_${ParentTable}
## output arguments: none
	DEFINE nbsel_${ParentTable} INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE record_found SMALLINT
	DEFINE record_num INTEGER
	DEFINE action smallint
	DEFINE xnumber smallint
	DEFINE arr_elem_num smallint
	DEFINE ${PrmryKeyPrefix}_${ParentTable} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD
	DEFINE ${MstInpFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",${ParentTable},"all","false","","\t\t")  :Script>
	END RECORD

	DEFINE ${MstTableRec} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD
	
	DEFINE record_found INTEGER
	DEFINE lookup_status INTEGER

	OPEN WINDOW ${MainFormName} WITH FORM "${MainFormName}"
	<Script: 
	$line=sprintf "CALL %s_%s()\n",${InitWidgetsFct},$ModuleName;
	$OutLineNum=ffg_print($SRCHANDLE,$line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
	:Script>

	CALL ${SqlFetchFullRowFct}_${ParentTable} (${PrmryKeyPrefix}_${ParentTable}.*) 
	RETURNING record_found,${MstInpFormRec}.*
	
	CALL ${FrmDisplayRecordFct}_${ModuleName}_${MainFormName}(${MstInpFormRec}.*)

	MENU "${ParentTable}"
	BEFORE MENU
	COMMAND "${EditOption}" "${UpdateCom} ${ParentTable}"
		HELP 4000
		MESSAGE ""
		LET sql_stmt_status = ${FrmEditRecordFct}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*)

	COMMAND "${AddOption}" "${InsertCom} ${ParentTable}"
		HELP 3000
		MESSAGE ""
		CALL ${FrmAddRecordFct}_${ParentTable}() RETURNING sql_stmt_status,${PrmryKeyPrefix}_${ParentTable}.*
		MESSAGE ""

	COMMAND "${SuppressOption}" "${DeleteCom} ${ParentTable}"
		HELP 5000
		MESSAGE ""
		IF ${SqlCheckPrimaryKeyFct}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*) < 0 THEN
			ERROR "${Islock} "
			NEXT OPTION "${NextOption}"
		END IF
		WHILE TRUE
			CALL confirm_operation(5,10,"${SuppressOption}") RETURNING action
			CASE 
			WHEN action = 0 OR action = 1 
				EXIT WHILE  # degage abandon
			WHEN action = 2   
				CALL ${FrmSuppressRecordFct}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*)
				RETURNING sql_stmt_status
				EXIT WHILE
			END CASE
		END WHILE
	COMMAND "Return to List" "${QuitCom}"
		HELP 9000
		MESSAGE ""
		EXIT MENU
	END MENU
	CLOSE WINDOW ${MainFormName}
END FUNCTION

#######################################################################

# ${FrmDisplayRecordFct}_${ModuleName}_${MainFormName} : displays the form record after reading and displays lookup records if any
# inbound: Form record.*
FUNCTION ${FrmDisplayRecordFct}_${ModuleName}_${MainFormName}(${MstInpFormRec})
	DEFINE ${MstInpFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",${ParentTable},"all","false","","\t\t")  :Script>
	END RECORD

	<Script: if ( $ParentLookupTables > 0 ) { 
		$IndentLevel=1;
		$OutLineNum=ffg_print($SRCHANDLE,"DEFINE lookup_status INTEGER\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		define_lookup_fields ($MainFormName,"parent",$Prefix,$Tabul,$WriteMode,$isRecord) ;
	}:Script>
	CLEAR FORM
	DISPLAY BY NAME ${MstInpFormRec}.*

	<Script: if ( $ParentLookupTables > 0 ) {
		$IndentLevel=0;
		bld_lookup_calls ($ParentTable,$MstInpFormRec);
		$IndentLevel=1;
		$Line = sprintf "\nDISPLAY BY NAME " ;
		$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE,0,0) ;
		print_form_fields ($SRCHANDLE,$MainFormName,"parent",".*","lookup",".*",".*",${SRLUpPrfx}."tabname","",'skip') ;
	}:Script>

END FUNCTION		# ${FrmDisplayRecordFct}_${ModuleName}_${MainFormName}


####################################################################
## ${FrmAddRecordFct}_${ModuleName}_${MainFormName}: add a new ${ParentTable} row
FUNCTION ${FrmAddRecordFct}_${ModuleName}_${MainFormName}()
	DEFINE sql_stmt_status SMALLINT
	DEFINE rows_count SMALLINT
	DEFINE nbre_${ParentTable} ,action SMALLINT
	DEFINE ${MstInpFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",${ParentTable},"all","false","","\t\t")  :Script>
	END RECORD

	DEFINE ${MstTableRec} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD
	
	<Script: if ( $ParentLookupTables > 0 ) { 
		$IndentLevel=1;
		$OutLineNum=ffg_print($SRCHANDLE,"DEFINE lookup_status INTEGER\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		define_lookup_fields ($MainFormName,"parent",$Prefix,$Tabul,$WriteMode,$isRecord) ;
	}:Script>

	CLEAR FORM
	INITIALIZE ${MstInpFormRec}.* TO NULL

	WHILE true
		LET int_flag = false
		INPUT BY NAME <Script: print_form_fields ($SRCHANDLE,$MainFormName,"parent",".*",".*",".*","false",${MstInpFormRec},"\t\t\t")  :Script>
		WITHOUT DEFAULTS
		<Script: print_input_events($SRCHANDLE,$MainFormName,${ParentTable},${KeyMode},"master","       " ):Script>
		<Script: if ( $ParentLookupTables > 0 ) {
			print_input_events($SRCHANDLE,$MainFormName,${ParentTable},"fkey","master","       " )
		}:Script>
		
		<Script: if ($DoPickListWindows eq 'true' && $ParentLookupTables > 0 ) { 
			bld_picklist_calls($ParentTable) ;
		}:Script>
		<Script: if (defined($do_build_help) ) {  
			$Line=sprintf "ON KEY (\"$Helpkey\")  # Call online help\n" ;
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$Line=sprintf "\tCALL help_${ParentTable}()\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		} :Script>
		END INPUT
		IF int_flag = TRUE THEN
			# Resign from input
			LET int_flag=false
			DISPLAY BY NAME ${MstInpFormRec}.*
			MESSAGE "${CancelCom} ${CancelKey}"
			EXIT WHILE
		END IF 

		CALL confirm_operation(3,10,"${AddOption}") RETURNING action
		CASE action
		WHEN 1            # I want to edit the input, remains displayed 'as is'
			CONTINUE WHILE   # On laisse tout affiche comme tel
			
		WHEN 2            # On valide la transaction
			<Script:if ( $DoTransactions eq 'true' ) {
				$OutLineNum=ffg_print($SRCHANDLE,"BEGIN WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			}:Script>
			CALL ${SetTableRecordFct}_${MainFormName}_${ParentTable}(1,${MstInpFormRec}.*)
			RETURNING ${MstTableRec}.*
			CALL ${SqlInsertFct}_${ParentTable}(${MstTableRec}.*) 
			returning sql_stmt_status,<Script:print_table_columns($SRCHANDLE,${ParentTable},"pkey","",$MstTableRec,"flat","",""); :Script>

			CASE 
			WHEN sql_stmt_status = 0
				MESSAGE "${AddOption} ${ParentTable} ${Successful}"
				<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"COMMIT WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			WHEN sql_stmt_status < 0
				CALL display_error("${AddOption} ${ParentTable}:${Failed} ")
				<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			END CASE
			EXIT WHILE

		WHEN 0
			<Script:if ( $DoTransactions eq 'true' ) {
				$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			}:Script>
			EXIT WHILE
		END CASE
	END WHILE
	# ${MstTableRec}
	RETURN sql_stmt_status,<Script:print_table_columns($SRCHANDLE,${ParentTable},"pkey","",$MstTableRec,"flat","",""); :Script>
END FUNCTION		## ${FrmAddRecordFct}_${ModuleName}_${MainFormName}


#######################################################################
# ${FrmEditRecordFct}_${ModuleName}_${MainFormName} : Edit a ${ParentTable} RECORD
# inbound: table primary key
FUNCTION ${FrmEditRecordFct}_${ModuleName}_${MainFormName}(pky,${MstInpFormRec})
	DEFINE action SMALLINT  
	DEFINE sql_stmt_status,dummy SMALLINT

	DEFINE ${MstTableRec} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD

	DEFINE ${MstInpFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",${ParentTable},"all","false","","\t\t")  :Script>
	END RECORD

	DEFINE ${MstSavFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",${ParentTable},"all","false","","\t\t")  :Script>
	END RECORD
	<Script: if ( $ParentLookupTables > 0 ) {
		$OutLineNum=ffg_print($SRCHANDLE,"DEFINE lookup_status INTEGER\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
	}:Script>
	DEFINE rows_count SMALLINT
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD

	## check if record can be accessed
	WHILE true
		LET int_flag = false
		# Save Screen Record values before altering
		LET ${MstSavFormRec}.* = ${MstInpFormRec}.* 
		<Script:if ( $DoTransactions eq 'true' ) {
			$OutLineNum=ffg_print($SRCHANDLE,"BEGIN WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$OutLineNum=ffg_print($SRCHANDLE,"EXECUTE IMMEDIATE \"SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS\"\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$OutLineNum=ffg_print($SRCHANDLE,"WHENEVER ERROR CONTINUE\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			my $Line=sprintf "OPEN crs_upd_%s USING pky.*",${ParentTable};
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			my $Line=sprintf "FETCH crs_upd_%s INTO dummy",${ParentTable};
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$OutLineNum=ffg_print($SRCHANDLE,"IF sqlca.sqlcode = -244 THEN\n\t\t\tERROR \"THIS ROW IS BEING MODIFIED\"\n\t\t\tROLLBACK WORK\n\t\t\tEXIT WHILE\n\t\tEND IF",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$OutLineNum=ffg_print($SRCHANDLE,"WHENEVER ERROR STOP\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		}:Script>
		
		INPUT BY NAME <Script: print_form_fields ($SRCHANDLE,$MainFormName,"parent",".*",".*","attr","false",${MstInpFormRec},"         ")  :Script>
		WITHOUT DEFAULTS
		<Script: if ( $ParentLookupTables > 0 ) {
			print_input_events($SRCHANDLE,$MainFormName,${ParentTable},"fkey","master","       " )
		}:Script>

		<Script: if ($DoPickListWindows eq 'true' && $ParentLookupTables > 0 ) { 
			bld_picklist_calls($ParentTable) ;
		}:Script>
					
		<Script: if (defined($do_build_help) ) {  
			$Line=sprintf "ON KEY (\"$Helpkey\")\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) ;
			$Line=sprintf "\tCALL help_${ParentTable}()\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE,0,0) ;
		}:Script>
		END INPUT
		IF int_flag = TRUE THEN
			LET int_flag=false
			# Restore previous value
			LET ${MstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY BY NAME ${MstInpFormRec}.*
			<Script: if ( $ParentLookupTables > 0 ) {
					bld_lookup_calls ($ParentTable,$MstInpFormRec);
					$Line = sprintf "DISPLAY BY NAME " ;
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE,0,0) ;
					print_form_fields ($SRCHANDLE,$MainFormName,"parent",".*","lookup",".*",".*",${SRLUpPrfx}."tabname","",'skip') ;
			}:Script>
			EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
			ROLLBACK WORK
			MESSAGE "$CancelCom ${CancelKey}"
			EXIT WHILE
		END IF 

		CALL confirm_operation(4,10,"${EditOption}") RETURNING action

		CASE 
		WHEN action = 0 
			# Resign, restore previous values
			LET ${MstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY BY NAME ${MstInpFormRec}.*
			EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
			ROLLBACK WORK
			EXIT WHILE   # Cancel operation

		WHEN action = 1 
			# Redo
			CONTINUE WHILE

		WHEN action = 2   
			# confirm update
			CALL ${SetTableRecordFct}_${MainFormName}_${ParentTable}(2,${MstInpFormRec}.*)
			RETURNING ${MstTableRec}.*
			
			# Perform the prepared update statement
			LET sql_stmt_status = ${SqlUpdateFct}_${ParentTable}(pky.*,${MstTableRec}.*) 
			CASE 
			WHEN sql_stmt_status = 0
				MESSAGE "${EditOption} ${ParentTable} ${Successful}"
				<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"EXECUTE IMMEDIATE \"SET ISOLATION TO COMMITTED READ\"\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
					$OutLineNum=ffg_print($SRCHANDLE,"COMMIT WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			WHEN sql_stmt_status < 0
				CALL display_error("${EditOption} ${ParentTable}:${Failed} ")
				<Script:if ( $DoTransactions eq 'true' ) {
						$OutLineNum=ffg_print($SRCHANDLE,"EXECUTE IMMEDIATE \"SET ISOLATION TO COMMITTED READ\"\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
						$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			END CASE
			EXIT WHILE
		END CASE
	END WHILE
	RETURN sql_stmt_status
END FUNCTION		## ${FrmEditRecordFct}_${ModuleName}_${MainFormName}(pky)


#######################################################################
# DELETE A ${ParentTable} row
# inbound: table primary key
FUNCTION ${FrmSuppressRecordFct}_${ModuleName}_${MainFormName}(pky)
	DEFINE action SMALLINT
	DEFINE dummy SMALLINT
	DEFINE sql_stmt_status SMALLINT
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD

	WHILE TRUE
		CALL confirm_operation(5,10,"${SuppressOption}") RETURNING action
		<Script:if ( $DoTransactions eq 'true' ) {
			$OutLineNum=ffg_print($SRCHANDLE,"BEGIN WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$OutLineNum=ffg_print($SRCHANDLE,"EXECUTE IMMEDIATE \"SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS\"\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$OutLineNum=ffg_print($SRCHANDLE,"WHENEVER ERROR CONTINUE\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			my $Line=sprintf "OPEN crs_upd_%s USING pky.*",${ParentTable};
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			my $Line=sprintf "FETCH crs_upd_%s INTO dummy",${ParentTable};
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$OutLineNum=ffg_print($SRCHANDLE,"IF sqlca.sqlcode = -244 THEN\n\t\t\tERROR \"THIS ROW IS BEING MODIFIED\"\n\t\t\tROLLBACK WORK\n\t\t\tEXIT WHILE\n\t\tEND IF",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$OutLineNum=ffg_print($SRCHANDLE,"WHENEVER ERROR STOP\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		}:Script>
		CASE 
		WHEN action = 0 OR action = 1 
			EXIT WHILE  # degage abandon
		WHEN action = 2   
			CALL ${SqlDeleteFct}_${ParentTable}(pky.*) RETURNING sql_stmt_status
			CASE 
			WHEN sql_stmt_status = 0
				MESSAGE "${SuppressOption} ${ParentTable} ${Successful}"
				<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"COMMIT WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>

			WHEN sql_stmt_status < 0
				CALL display_error("${SuppressOption} ${ParentTable}:${Failed} ")
				<Script:if ( $DoTransactions eq 'true' ) {
						$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			END CASE
			EXIT WHILE
		END CASE
	END WHILE
	RETURN sql_stmt_status
END FUNCTION		## ${FrmSuppressRecordFct}_${ModuleName}_${MainFormName}(pky)

#########################################################################
#  Build, prepare, declare and initialize main queries and cursors
FUNCTION ${SqlPrepareQueriesFct}_${ModuleName}_${ParentTable} ()
	DEFINE query_text STRING

	# PREPARE cursor for full master table row contents, access by primary key
	LET query_text=
	"SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},"all","","","flat","",""):Script>",
	" FROM ${ParentTable} ",
	"WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>"
	PREPARE sel_mrw_${ParentTable} FROM query_text
	DECLARE crs_row_${ParentTable} CURSOR FOR sel_mrw_${ParentTable}

	# PREPARE cursor for row test / check if locked
	let query_text= "SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},${KeyMode},"","","flat","",""); :Script>",
	" FROM ${ParentTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>"
	PREPARE sel_${PrmryKeyPrefix}_${ParentTable} FROM query_text
	DECLARE crs_${PrmryKeyPrefix}_${ParentTable} CURSOR FOR sel_${PrmryKeyPrefix}_${ParentTable}
	
	# PREPARE cursor for SELECT FOR UPDATE
	let query_text= "SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},${KeyMode},"","","flat","",""); :Script>",
	" FROM ${ParentTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>",
	" FOR UPDATE"
	PREPARE sel_upd_${ParentTable} FROM query_text
	DECLARE crs_upd_${ParentTable} CURSOR FOR sel_upd_${ParentTable}

	# PREPARE INSERT statement
	LET query_text =
	"INSERT INTO ${ParentTable} (<Script:print_table_columns($SRCHANDLE,${ParentTable},"all","","","flat","",""):Script>)",
	" VALUES ( <Script:print_table_columns($SRCHANDLE,${ParentTable},"all","placeholders","","flat","",1); :Script>)" 
	PREPARE pr_ins_${ParentTable} FROM query_text

	# PREPARE UPDATE statement
	let query_text=
	"UPDATE ${ParentTable} ",
	"SET ( <Script:print_table_columns($SRCHANDLE,${ParentTable},"attr","","","flat","",""); :Script>)",
	" = ( <Script:print_table_columns ($SRCHANDLE,${ParentTable},"attr","placeholders","","flat","",""); :Script>)",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>" 
	PREPARE pr_upd_${ParentTable} FROM query_text

	# PREPARE DELETE statement
	let query_text= "DELETE FROM ${ParentTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>" 

	PREPARE pr_del_${ParentTable} FROM query_text

END FUNCTION		## ${SqlPrepareQueriesFct}_${ModuleName}_${ParentTable}

#########################################################################################
FUNCTION ${SqlFetchFullRowFct}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable})
# ${SqlFetchFullRowFct}_${ParentTable} : read a complete row accessing by primary key
# inbound parameter : primary key
# outbound parameter: sql_stmt_status and row contents
	DEFINE sql_stmt_status smallint
	DEFINE ${PrmryKeyPrefix}_${ParentTable} RECORD 
	<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD
	DEFINE ${MstTableRec} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD
	DEFINE ${MstInpFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",${ParentTable},"all","false","","\t\t")  :Script>
	END RECORD

	<Script: if ( $ParentLookupTables > 0 ) { 
		$IndentLevel=1;
		$OutLineNum=ffg_print($SRCHANDLE,"DEFINE lookup_status INTEGER\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		define_lookup_fields ($MainFormName,"parent",$Prefix,$Tabul,$WriteMode,$isRecord) ;
	}:Script>

	# read the table, access on primary key
WHENEVER ERROR CONTINUE
	OPEN crs_row_${ParentTable} 
	USING ${PrmryKeyPrefix}_${ParentTable}.*

	FETCH crs_row_${ParentTable}  INTO ${MstTableRec}.*

WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN  sqlca.sqlcode = 100 
		LET sql_stmt_status = 0
	WHEN  sqlca.sqlcode < 0 
		LET sql_stmt_status = -1
	OTHERWISE
		LET sql_stmt_status = 1
		CALL ${SetFormRecordFct}_${ModuleName}_${MainFormName}(${MstTableRec}.*)
		RETURNING ${MstInpFormRec}.*
	END CASE
	RETURN sql_stmt_status,${MstInpFormRec}.*
END FUNCTION		## ${SqlFetchFullRowFct}_${ParentTable}

########################################################################
FUNCTION ${SqlInsertFct}_${ParentTable}(${MstTableRec})
## INSERT in table ${ParentTable} 
	DEFINE lsql_stmt_status integer
	DEFINE rows_count SMALLINT
	DEFINE pky RECORD
		 <Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD
	DEFINE ${MstTableRec} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD
WHENEVER ERROR CONTINUE
	EXECUTE pr_ins_${ParentTable} 
	USING <Script:print_table_columns($SRCHANDLE,${ParentTable},"all","",${MstTableRec},"","    ",""):Script>
WHENEVER ERROR CALL ${ErrorMngmtFunction}

	IF sqlca.sqlcode < 0 THEN   
		LET lsql_stmt_status = -1
	ELSE 
		LET lsql_stmt_status = 0
		<Script:catch_last_serial_value($SRCHANDLE,${ParentTable},"pky"):Script>
		
	END IF
	RETURN lsql_stmt_status,pky.*
END FUNCTION		## ${SqlInsertFct}_${ParentTable}

########################################################################
FUNCTION ${SqlUpdateFct}_${ParentTable}(pky,${MstTableRec})
## ${SqlUpdateFct}_${ParentTable} :update ${ParentTable} record
	DEFINE lsql_stmt_status integer
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD
	DEFINE ${MstTableRec} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD

WHENEVER ERROR CONTINUE
	EXECUTE pr_upd_${ParentTable} 
	USING <Script:print_table_columns($SRCHANDLE,${ParentTable},"attr","",${MstTableRec},"","    ",$endline,1):Script>,
	pky.*

WHENEVER ERROR CALL ${ErrorMngmtFunction}
	IF sqlca.sqlcode < 0 THEN   
		
		LET lsql_stmt_status = -1
	ELSE 
		LET lsql_stmt_status = 0
	END IF
	RETURN lsql_stmt_status
END FUNCTION		## ${SqlUpdateFct}_${ParentTable}

##############################################################################################
FUNCTION ${SqlDeleteFct}_${ParentTable}(pky)
## ${SqlDeleteFct}_${ParentTable} :delete current row in table ${ParentTable} 
	DEFINE lsql_stmt_status smallint
	DEFINE pky RECORD 
	<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
END RECORD

WHENEVER ERROR CONTINUE
   EXECUTE pr_del_${ParentTable} 
   USING pky.*

WHENEVER ERROR CALL ${ErrorMngmtFunction}
	IF sqlca.sqlcode < 0 THEN   
		LET lsql_stmt_status = -1
	ELSE
		LET lsql_stmt_status=0
	END IF
	RETURN lsql_stmt_status
END FUNCTION		## ${SqlDeleteFct}_${ParentTable}

################################################################################
FUNCTION ${SqlCheckPrimaryKeyFct}_${ParentTable}(pky)  
##   ${SqlCheckPrimaryKeyFct}_${ParentTable} : Check if primary key exists
## inbound parameter : record of primary key
## outbound parameter:  status > 0  if exists, 0 if no record, < 0 if error
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD
	DEFINE pk_status INTEGER

WHENEVER ERROR CONTINUE
	OPEN crs_${PrmryKeyPrefix}_${ParentTable} USING  pky.*
	FETCH crs_${PrmryKeyPrefix}_${ParentTable} 
WHENEVER ERROR CALL ${ErrorMngmtFunction}

	CASE sqlca.sqlcode
	WHEN 0 
		let pk_status = 1
	WHEN 100
		let pk_status = 0
	WHEN sqlca.sqlerrd[2] = 104
		let pk_status = -1		# record locked
	WHEN sqlca.sqlcode < 0
		let pk_status = sqlca.sqlcode
	END CASE

	RETURN pk_status
END FUNCTION		## ${SqlCheckPrimaryKeyFct}_${ParentTable}

################################################################################################
FUNCTION ${SetFormRecordFct}_${ModuleName}_${MainFormName}(tbl_contents)
## ${SetFormRecordFct}_${ModuleName}_${MainFormName}: assigns table values to form fields values
	DEFINE frm_contents RECORD
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",".*","all","false","","\t\t")  :Script>
	END RECORD

	DEFINE tbl_contents RECORD
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD

	INITIALIZE frm_contents.* TO NULL
	<Script:set_form_record ($SRCHANDLE,${ParentTable},${MainFormName},"frm_contents","tbl_contents") :Script>
	RETURN frm_contents.*
END FUNCTION		## ${SetFormRecordFct}${ModuleName}_${MainFormName}

################################################################################################
FUNCTION ${SetTableRecordFct}_${MainFormName}_${ParentTable}(sql_stmt,frm_contents)
## ${SetTableRecordFct}_${MainFormName}_${ParentTable}: assigns form fields value to table values
	DEFINE sql_stmt SMALLINT					# 1 => Insert, 2 => Update
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD
	
	DEFINE frm_contents RECORD
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent","parent",".*","all","false","","\t\t")  :Script>
	END RECORD

	DEFINE tbl_contents RECORD
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD

	INITIALIZE tbl_contents.* TO NULL
	<Script:set_table_record ($SRCHANDLE,${ParentTable},${MainFormName},"frm_contents","tbl_contents") :Script>

	RETURN tbl_contents.*
END FUNCTION		## ${SetTableRecordFct}${MainFormName}_${ParentTable}

<Script: if ($ParentLookupTables > 0 ) {
	bld_lookup_functions ( $ParentTable );
}:Script>

<Script: if ( $QxWidgetsCount > 0 ) { 
	bld_populate_widgets_calls_function($SRCHANDLE,$MainFormName,".*",".*") ;
	bld_populate_widgets_functions($SRCHANDLE,$MainFormName,".*",".*") ;
}  :Script>

<Script: if ( $ParentLookupTables > 0 && $DoPickListWindows eq "true" ) { 
	bld_picklist_windows($ModuleName) ;
} :Script>

<Script: if ($DoHelp eq 'true') {
	build_fct_Help(${MainFormName},${ParentTable});
   build_doc_Help(${MainFormName},$mstr_clnt_module)

}:Script>
