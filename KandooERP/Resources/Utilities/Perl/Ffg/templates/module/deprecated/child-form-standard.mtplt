<Script:our $ChildSRArray=${ChildTable} . ${SRArraySuffix} :Script>noprint
<Script:our $ChildPkyArray=${ChildTable} . "_${PrmryKeyPrefix}_array" :Script>noprint
<Script:our $ChildStatusArray=${ChildTable} . "_status_array" :Script>noprint
<Script:our $ChlTableRec=${TblPrfx} . ${ChildTable} :Script>noprint
<Script:our $ChlSavFormRec=${SRSavPrfx} . ${ChildSRArray} :Script>noprint
# module  generated by Kandoo Ffg(c) 
# Generated on ${GenerationTS}
# template ${TemplateFile} 
database ${DatabaseName}
DEFINE ${ChildPkyArray} DYNAMIC ARRAY OF RECORD
	<Script: define_table_variables ($SRCHANDLE,${ChildTable},"pkey","record","pky","    "):Script>
END RECORD

DEFINE ${ChildSRArray} DYNAMIC ARRAY OF RECORD
	<Script: define_scr${RecordPrefix}fields($SRCHANDLE,$FormName,$ChildScreenRecord,".*","all",".*","","\t\t") :Script>
	
END RECORD

DEFINE ${ChildStatusArray} DYNAMIC ARRAY OF SMALLINT

DEFINE ${ChlTableRec} RECORD
	<Script: define_table_variables ($SRCHANDLE,${ChildTable},"all","record","","    "):Script>
END RECORD


FUNCTION ${SqlPrepareQueriesFct}_${ModuleName}_${ChildTable} ()
# this function initializes all cursors and prepared statements for the ${ChildTable} and lookups

DEFINE query_text STRING 
	# Prepare the cursor to display the ${ChildTable} array
	# using foreign key pointing to ${ParentTable}
	
	LET query_text = "SELECT <Script:print_table_columns($SRCHANDLE,${ChildTable},"pkey","",${ChildTable},"flat","    "); :Script>,",
	<Script:print_form_fields ($SRCHANDLE,$FormName,"child",".*",".*",".*",".*","tabname","",'quoteskip') ;:Script>
	<Script:bld_scr${RecordPrefix}join($SRCHANDLE,$FormName,$ChildScreenRecord,$ParentTable,$ChildTable,".*", ".*",".*","tabname","","quoteskip",""); :Script>
	" AND <Script: bld_where_clause($SRCHANDLE,${ChildTable},"fkey:${ParentTable}","?","","    ") ;:Script>",
	" ORDER BY <Script:print_table_columns($SRCHANDLE,${ChildTable},"pkey","",${ChildTable},"flat","    "); :Script>"
	PREPARE ${PrepStmtPrefix}child_${ChildTable} FROM query_text
	DECLARE ${CursorPrefix}child_${ChildTable} CURSOR FOR ${PrepStmtPrefix}child_${ChildTable}

	# PREPARE INSERT statement
	LET query_text =
	"INSERT INTO ${ChildTable} (<Script:print_table_columns($SRCHANDLE,${ChildTable},"all","","","flat","",""):Script>)",
	" VALUES ( <Script:print_table_columns($SRCHANDLE,${ChildTable},"all","placeholders","","flat","",1); :Script>)" 
	PREPARE ${PrepStmtPrefix}ins_${ChildTable} FROM query_text

	# PREPARE UPDATE statement
	let query_text=
	"UPDATE ${ChildTable} ",
	"SET ( <Script:print_table_columns($SRCHANDLE,${ChildTable},"attr","","","flat","",1); :Script>)",
	" = ( <Script:print_table_columns ($SRCHANDLE,${ChildTable},"attr","placeholders","","flat","",1); :Script>)",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ChildTable},"pkey","?","","    ") ;:Script>" 
	PREPARE ${PrepStmtPrefix}upd_${ChildTable} FROM query_text

	# PREPARE DELETE statement
	let query_text= "DELETE FROM ${ChildTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ChildTable},"pkey","?","","    ") ;:Script>" 
	PREPARE ${PrepStmtPrefix}del_${ChildTable} FROM query_text
	
END FUNCTION

FUNCTION ${OpenArrayCursorFct}_${ChildSRArray}(fky)
## This function opens the main cursor for the table ${ChildTable}

	define lsql_ok integer
	DEFINE fky RECORD
		<Script: define_table_variables ($SRCHANDLE,${ChildTable},"fkey:${ParentTable}","record","fky","    "):Script> 
	END RECORD

	WHENEVER ERROR CONTINUE
	OPEN ${CursorPrefix}child_${ChildTable} USING fky.*

	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE 
	WHEN sqlca.sqlcode = 100   
		LET lsql_ok = 0
	WHEN sqlca.sqlcode < 0 
		LET lsql_ok = -1
	OTHERWISE
		LET lsql_ok = 1
	END CASE
	RETURN lsql_ok
END FUNCTION

FUNCTION ${SqlInsertFct}_${ChildTable}(lr_${ChildTable})
## INSERT in table ${ChildTable} 
	DEFINE lr_${ChildTable} RECORD
		<Script: define_table_variables ($SRCHANDLE,${ChildTable},"all","record","","    "):Script>
	END RECORD
		
	DEFINE lsql_stmt_status INTEGER
	DEFINE lookup_status INTEGER
	DEFINE nb_deleted_rows INTEGER

	WHENEVER ERROR CONTINUE
	EXECUTE ${PrepStmtPrefix}ins_${ChildTable}
	USING <Script:print_table_columns($SRCHANDLE,$ChildTable,"all","",lr_${ChildTable},"","    ",""):Script> # 
	WHENEVER ERROR CALL ${ErrorMngmtFunction}

	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status = 0
	WHEN sqlca.sqlcode < 0
		CALL display_error("${SqlInsertFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
	END CASE
	RETURN lsql_stmt_status
END FUNCTION

FUNCTION ${SqlUpdateFct}_${ChildTable}(pky,lr_${ChildTable})
## ${SqlUpdateFct}_${ChildTable} :update current ${ChildTable} record
	DEFINE lr_${ChildTable} RECORD
		<Script: define_table_variables ($SRCHANDLE,${ChildTable},"all","record","","    "):Script>
	END RECORD
	DEFINE lsql_stmt_status INTEGER
	DEFINE nb_modified_rows INTEGER
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ChildTable},"pkey","record","pky","    "):Script>
	END RECORD

	WHENEVER ERROR CONTINUE
	EXECUTE ${PrepStmtPrefix}upd_${ChildTable} 
	USING <Script:print_table_columns($SRCHANDLE,${ChildTable},"attr","","lr_${ChildTable}","","    ",$endline,1):Script>,
	pky.*

	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status = 0
		LET nb_modified_rows = sqlca.sqlerrd[3]
	WHEN sqlca.sqlcode < 0
		CALL display_error("${SqlUpdateFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
		LET nb_modified_rows = 0
	END CASE
	RETURN lsql_stmt_status,nb_modified_rows
END FUNCTION

FUNCTION ${SqlDeleteFct}_${ChildTable}(pky)
## delete_${ChildTable} :delete Selected row in table ${ChildTable} 
	DEFINE lsql_stmt_status smallint
	DEFINE nb_deleted_rows INTEGER
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ChildTable},"pkey","record","pky","    "):Script>
	END RECORD

	WHENEVER ERROR CONTINUE
	EXECUTE ${PrepStmtPrefix}del_${ChildTable} USING pky.*

	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status=0
		LET nb_deleted_rows = sqlca.sqlerrd[3]
	WHEN sqlca.sqlcode < 0 
		CALL display_error("${SqlDeleteFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
	END CASE
	
	RETURN lsql_stmt_status,nb_deleted_rows
END FUNCTION

################################################################################
FUNCTION ${SqlCheckPrimaryKeyFct}_${ChildTable}(pky)  
#"# This function Checks if primary key exists
## inbound parameter : record of primary key
## outbound parameter:  status > 0  if exists, 0 if no record, < 0 if error
################################################################################
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ChildTable},"pkey","record","pky","    "):Script>
	END RECORD
	DEFINE pk_status INTEGER

	WHENEVER ERROR CONTINUE
	OPEN crs_${PrmryKeyPrefix}_${CursorSufx} USING  pky.*
	FETCH crs_${PrmryKeyPrefix}_${CursorSufx} 
	WHENEVER ERROR CALL ${ErrorMngmtFunction}

	CASE sqlca.sqlcode
	WHEN 0 
		let pk_status = 1
	WHEN 100
	let pk_status = 0
	WHEN sqlca.sqlerrd[2] = 104
		let pk_status = -1		# record locked
	WHEN sqlca.sqlcode < 0
		let pk_status = sqlca.sqlcode
	END CASE
	RETURN pk_status
END FUNCTION

<Script: if ($ChildLookupTables > 0 ) {
	#bld_lookup_queries ( $ChildTable );
}:Script>

#######################################################################
FUNCTION ${InitializeArrayFct}_${ChildTable}()
#######################################################################
	# initializes arrays
	CALL ${ChildSRArray}.clear()
	CALL ${ChildPkyArray}.clear()
	CALL ${ChildStatusArray}.clear()
END FUNCTION

######################################################################################################################################################
FUNCTION ${DisplayArrayFct}${ChildTable} (fky,browse)
# This function displays the array data (${ChildSRArray}) based on the foreign key 
# browse: False means that the array is displayed without possibility of browsing inside (just show array and skip to next parent row)
######################################################################################################################################################
	DEFINE elem_num,choice,xpos,ypos INTEGER
	DEFINE ${ArrCurrVar},${ScrLineVar} INTEGER
	DEFINE sql_ok INTEGER
	DEFINE ${QbeStmtVariable} STRING
	DEFINE browse BOOLEAN
	DEFINE where_clause STRING
	DEFINE fky RECORD
		<Script: define_table_variables ($SRCHANDLE,${ChildTable},"fkey:${ParentTable}","record","fky","    "):Script> 
	END RECORD
	DEFINE sql_stmt_status INTEGER

	IF browse = false THEN
		# opening array cursor and fetch data only when reading the parent row
		LET sql_ok = ${OpenArrayCursorFct}_${ChildSRArray}(fky.*)
		LET elem_num = 1
		FOREACH ${CursorPrefix}child_${ChildTable} INTO ${ChildPkyArray}[elem_num].*,${ChildSRArray}[elem_num].*
			LET ${ChildStatusArray}[elem_num] = 0			# elements exists
			LET elem_num = elem_num + 1
		END FOREACH
		IF elem_num > 1 THEN
			CALL  ${ChildSRArray}.deleteElement(elem_num)
		END IF
	END IF

	DISPLAY ARRAY ${ChildSRArray}
	TO ${ChildScreenRecord}.*
	BEFORE DISPLAY
		IF browse = FALSE THEN
			EXIT DISPLAY
		END IF
	END DISPLAY

	RETURN elem_num-1
END FUNCTION

###########################################################################################################
FUNCTION ${EditArrayFct}${ChildTable} (${PrmryKeyPrefix}_${ParentTable})
# This function calls the INPUT array function (${InputArrayFct}_${ChildTable}) to edit the array data
# then, accordingly, the SQL statement functions (${ArrayBulkUpdFct})
# it is generally called from another module
###########################################################################################################
	DEFINE ${ScrLineVar} INTEGER
	DEFINE ${ArrCurrVar} INTEGER
	DEFINE bulk_update_status SMALLINT
	DEFINE nbr_edited_rows INTEGER
	DEFINE sql_action SMALLINT
	DEFINE i smallint
	DEFINE ${PrmryKeyPrefix}_${ParentTable} RECORD
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script># or is it the foreign key here?
	END RECORD

	<Script:if ( $DoTransactions eq 'true' ) {
		$OutLineNum=ffg_print($SRCHANDLE,"BEGIN WORK",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
	}:Script>
	WHILE TRUE
		<Script:
			$Line=sprintf "CALL ${InputArrayFct}_${ChildTable} (${PrmryKeyPrefix}_${ParentTable}.*) RETURNING nbr_edited_rows,sql_action"; 
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		:Script>
		IF nbr_edited_rows > 0 THEN
			CASE 
			WHEN  sql_action = 2
				LET bulk_update_status = ${ArrayBulkUpdFct}${ChildTable} (${PrmryKeyPrefix}_${ParentTable})
				IF bulk_update_status > 0 THEN
					<Script:if ( $DoTransactions eq 'true' ) {
						$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
					}:Script>
					ERROR "${InputArrayFct} ${Failed}"
				ELSE
					ERROR "${InputArrayFct} ${Successful}"
					<Script:if ( $DoTransactions eq 'true' ) {
						$OutLineNum=ffg_print($SRCHANDLE,"COMMIT WORK",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
					}:Script>
					EXIT WHILE
				END IF
			WHEN sql_action = 1
				# No
				ERROR "Please INPUT ARRAY AGAIN"
			WHEN sql_action = 0
				# Cancel
				MESSAGE "Cancelled, exit INPUT ARRAY"
				EXIT WHILE
			END CASE
		ELSE
			# Nothing
			MESSAGE "Nothing has been changed"
			EXIT WHILE
		END IF
	END WHILE

END FUNCTION

####################################################################################################################
FUNCTION ${InputArrayFct}_${ChildTable} (${PrmryKeyPrefix}_${ParentTable})
## this function operates INPUT ARRAY for the table ${ChildTable}
# it handles 3 arrays:
# 1) The status array  (${ChildStatusArray}) contains the status for each element: 
#    NULL=>no data, 0=>elements not touched, 1=>element to INSERT, 2=>element to UPDATE, -1=>element to DELETE
# 2) the Input Data Array (${ChildSRArray}) will contain the data input by the user
# 3) the primary key array (${PrmryKeyPrefix}_${ParentTable}) contains the primary key values of each element
###################################################################################################################
	DEFINE arrcnt INTEGER
	DEFINE ${ScrLineVar} INTEGER
	DEFINE ${ArrCurrVar} INTEGER
	DEFINE last_element INTEGER
	DEFINE lookup_status INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE nbr_edited_rows INTEGER
	DEFINE sql_action smallint
	DEFINE ins_key smallint
	DEFINE ${PrmryKeyPrefix}_${ParentTable} RECORD
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD
	DEFINE ${ChlSavFormRec} RECORD
		<Script: define_scr${RecordPrefix}fields($SRCHANDLE,$FormName,$ChildScreenRecord,".*","all",".*","","\t\t") :Script>
	END RECORD
	DEFINE sql_ok SMALLINT
	LET nbr_edited_rows = 0

	LET int_flag = FALSE
	LET ins_key = FALSE

	INPUT ARRAY ${ChildSRArray} WITHOUT DEFAULTS
	FROM ${ChildScreenRecord}.*
	ATTRIBUTE(normal)
	ON KEY (INTERRUPT)
		# Cancel from input
		LET int_flag=false
		LET ${ArrCurrVar} = arr_curr()
		LET ${ScrLineVar} = scr_line ()
		LET  ${ChildSRArray}[${ArrCurrVar}].* = ${ChlSavFormRec}.*
		DISPLAY ${ChildSRArray}[${ArrCurrVar}].* TO ${ChildScreenRecord}[${ScrLineVar}].*
		MESSAGE "${CancelCom} ${CancelKey}"
		<Script:if ( $DoTransactions eq 'true' ) {
			$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		}:Script>
		EXIT INPUT

	BEFORE INSERT
		# insert a row in ${PrmryKeyPrefix}_array
		CALL ${ChildPkyArray}.insert(${ArrCurrVar})
		INITIALIZE ${ChildPkyArray}[${ArrCurrVar}].* TO NULL
		# insert a row in status_array
		CALL ${ChildStatusArray}.insert(${ArrCurrVar})
		LET ${ChildStatusArray}[${ArrCurrVar}] = NULL


	BEFORE ROW
		LET ${ScrLineVar} = scr_line()
		LET ${ArrCurrVar} = arr_curr()
		LET ${ChlSavFormRec}.* = ${ChildSRArray}[${ArrCurrVar}].*

	<Script: #print_inputarray_events($SRCHANDLE,$MainFormName,$ChildScreenRecord,$ChildSRArray,${ChildTable},"all","child","       " ) 
		print_input_events($SRCHANDLE,$MainFormName,${ChildTable},"child","pkey|fkey","       " );
	:Script>

	<Script: if ($DoPickListWindows eq 'true' && $ChildLookupTables > 0 ) { 
		bld_picklist_calls($ChildTable) ;
	}:Script>

	AFTER DELETE
		IF ${ChildStatusArray}[${ArrCurrVar}] IS NOT NULL THEN
			LET last_element = ${ChildStatusArray}.getsize()
			# The deleted element becomes the last element of status_array and flagged -1
			# The pky is also copied to the last element
			LET ${ChildStatusArray}[last_element] = -1  # to be Deleted
			LET ${ChildPkyArray}[last_element].* = ${ChildPkyArray}[${ArrCurrVar}].*
			LET nbr_edited_rows = nbr_edited_rows + 1
		END IF

	AFTER ROW
		IF field_touched (${ChildScreenRecord}[${ScrLineVar}].*) THEN
			LET nbr_edited_rows = nbr_edited_rows + 1
			CASE
			WHEN ${ChildStatusArray}[${ArrCurrVar}] = 0		# existing
				LET ${ChildStatusArray}[${ArrCurrVar}] = 2	# to be modified
				<Script: set_pk_values($SRCHANDLE,$MainFormName,$ChildScreenRecord,$ChildSRArray,$ChildPkyArray,$ParentTable,$ChildTable,"update") :Script>

			WHEN ${ChildStatusArray}[${ArrCurrVar}] IS NULL	# new
				LET ${ChildStatusArray}[${ArrCurrVar}] = 1	# to be inserted
				<Script: set_pk_values($SRCHANDLE,$MainFormName,$ChildScreenRecord,$ChildSRArray,$ChildPkyArray,$ParentTable,$ChildTable,"insert") :Script>
			END CASE
			<Script: bld_ck_pk_value($ChildTable,$ChildPkyArray .'[' . ${ArrCurrVar} . ']') :Script>
		END IF

	AFTER INPUT
		IF int_flag THEN
			LET int_flag = FALSE
			ERROR " ${Cancel} ${ChildTable}"
			LET nbr_edited_rows = 0
			LET sql_action = 0
		ELSE
			LET sql_action = confirm_operation(5,10,"${InputArrayFct} ") 
			IF sql_action = 1 THEN
				CONTINUE INPUT
			END IF
		END IF
END INPUT
RETURN nbr_edited_rows,sql_action
END FUNCTION

######################################################################################################
FUNCTION ${SetFormRecordFct}_${ModuleName}_${ChildScreenRecord}(tbl_contents)
# This function assigns the values from the table ${ChildScreenRecord} to the form record frm_contents
######################################################################################################
	DEFINE fgl_status SMALLINT
	DEFINE frm_contents RECORD
		<Script: define_scr${RecordPrefix}fields($SRCHANDLE,$FormName,$ChildScreenRecord,$ChildTable,"all",".*","","\t\t") :Script>
	END RECORD
	
	DEFINE tbl_contents RECORD
		<Script: define_table_variables ($SRCHANDLE,$ChildTable,"all","record","","    "):Script>
	END RECORD

	INITIALIZE frm_contents.* TO NULL
	<Script:set_form_record ($SRCHANDLE,$ChildTable,$FormName,"frm_contents",$ChlTableRec,$ChildScreenRecord) :Script>
	CASE
	WHEN status = 0
		LET fgl_status = 1
	WHEN status < 0
		LET fgl_status = status
	OTHERWISE
		LET fgl_status = status
	END CASE
	RETURN fgl_status,frm_contents.*
END FUNCTION

######################################################################################################
FUNCTION ${SetTableRecordFct}_${ModuleName}_${ChildTable}(fky,sql_stmt,pky,element_contents)
# This function assigns the values from the array element(element_contents) to the table record (tbl_contents)
# It distinguishes the primary key (pky) of the table ${ChildTable}and the foreign key (fky) point to the parent table (${ParentTable})
######################################################################################################
	DEFINE sql_stmt SMALLINT
	DEFINE fgl_status SMALLINT
	DEFINE element_contents RECORD
		<Script: define_scr${RecordPrefix}fields($SRCHANDLE,$FormName,$ChildScreenRecord,".*","all",".*","","\t\t") :Script>
	END RECORD
	DEFINE fky RECORD
		<Script:define_table_variables ($SRCHANDLE,${ChildTable},"fkey:${ParentTable}","record","pky","    "):Script># or is it the foreign key here?
	END RECORD
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ChildTable},"pkey","record","pky","    "):Script>
	END RECORD
	DEFINE tbl_contents RECORD
		<Script: define_table_variables ($SRCHANDLE,$ChildTable,"all","record","","    "):Script>
	END RECORD
	
	#WHENEVER ERROR CONTINUE
	INITIALIZE tbl_contents.* TO NULL
	<Script:set_table_record ($SRCHANDLE,$ChildTable,$FormName,"element_contents","tbl_contents",$ChildScreenRecord) :Script>
	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN status = 0
		LET fgl_status = 1
	WHEN status < 0
		LET fgl_status = status
	OTHERWISE
		LET fgl_status = status
	END CASE
	RETURN fgl_status,tbl_contents.*
END FUNCTION

#############################################################################################################
FUNCTION ${ArrayBulkUpdFct}${ChildTable} (parent_fky)
## This functions browses the status array ${ChildStatusArray},
# copies the element values to table values (${ChildTable})
# and executes the request SQL operation requested for each element
#############################################################################################################
	DEFINE idx,arr_size INTEGER
	DEFINE updarr_status,fgl_status,global_status INTEGER
	DEFINE parent_fky RECORD
		<Script:define_table_variables ($SRCHANDLE,${ChildTable},"fkey:orders","record","pky","    "):Script>
	END RECORD
	
	DEFINE elements_contents RECORD
		<Script: define_scr${RecordPrefix}fields($SRCHANDLE,$FormName,$ChildScreenRecord,".*","all",".*","","\t\t") :Script>
	END RECORD
	DEFINE l_${ChildTable} RECORD
		<Script: define_table_variables ($SRCHANDLE,$ChildTable,"all","record","","    "):Script>
	END RECORD
	LET global_status = 0
	LET arr_size = ${ChildStatusArray}.getsize()
	FOR idx = 1 TO arr_size
		CASE
		WHEN ${ChildStatusArray}[idx] IS NULL OR ${ChildStatusArray}[idx] = 0
			CONTINUE FOR
		WHEN ${ChildStatusArray}[idx] > 0
			LET elements_contents.* = ${ChildSRArray}[idx].*
			CALL ${SetTableRecordFct}_${ModuleName}_${ChildTable}(parent_fky.*,${ChildStatusArray}[idx],${ChildPkyArray}[idx].*,${ChildSRArray}[idx].*)
			RETURNING fgl_status,l_${ChildTable}.*
		END CASE
		LET updarr_status = ${SqlArrayUpdateOneElemFct}_${ChildTable}(idx,l_${ChildTable}.*)
		IF updarr_status < 0 THEN
			ERROR "Error on element # ",idx
			LET global_status = global_status + 1
		END IF
	END FOR
	RETURN global_status
END FUNCTION 


###############################################################################
FUNCTION ${SqlArrayUpdateOneElemFct}_${ChildTable}(idx,lr_${ChildTable})
## This function executes the SQL statement for each element
## accord the to status array value of this element
###############################################################################
DEFINE st SMALLINT
DEFINE arrcnt SMALLINT
DEFINE idx SMALLINT 
DEFINE statut SMALLINT
DEFINE lr_${ChildTable} RECORD
	<Script: define_table_variables ($SRCHANDLE,$ChildTable,"all","record","","    "):Script>
END RECORD
LET st = 0
	CASE ${ChildStatusArray}[idx] 
	WHEN 2					# must be updated
		LET statut = ${SqlUpdateFct}_${ChildTable}(${ChildPkyArray}[idx].*,lr_${ChildTable}.*)
	WHEN 1
		LET statut = ${SqlInsertFct}_${ChildTable}(lr_${ChildTable}.*)
	WHEN -1
		LET statut = ${SqlDeleteFct}_${ChildTable}(${ChildPkyArray}[idx].*)
	END CASE
return statut
END FUNCTION

<Script: if ($ChildLookupTables > 0 ) {
	bld_lookup_functions (${MainFormName},$ChildTable,"child" );
}:Script>
