<Script:our $CursorSufx="m".${ParentTable} :Script>noprint
<Script:our $MstTableRec=${TblPrfx} . ${ModuleName} :Script>noprint
<Script:our $MstInpFormRec=${SRInpPrfx} . ${ModuleName} :Script>noprint
<Script:our $MstSavFormRec=${SRSavPrfx} . ${ModuleName} :Script>noprint
<Script:our $MstLkUpRec=${SRLUpPrfx} . ${ModuleName} :Script> noprint
@GlobalDef
@ModuleDef

# module  generated by Querix Ffg(c) 
# Generated on ${GenerationTS}
# template ${TemplateFile} 

DATABASE ${DatabaseName}

DEFINE ${ModuleVarPrefix}program CHAR(30)

DEFINE ${PrmryKeyPrefix}_${ParentTable} RECORD 
	<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
END RECORD

DEFINE ${MstTableRec} RECORD 
	<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
END RECORD

DEFINE ${MstInpFormRec} RECORD 
	<Script:define_form_fields($SRCHANDLE,$MainFormName,".*",".*","all","false","","\t\t")  :Script>
END RECORD

DEFINE ${MstSavFormRec} RECORD 
	<Script:define_form_fields($SRCHANDLE,$MainFormName,".*",".*","all","false","","\t\t")  :Script>
END RECORD

<Script: if ( $ParentLookupTables > 0 ) { 
	$IndentLevel=0;
	$OutLineNum=ffg_print($SRCHANDLE,"DEFINE ${MstLkUpRec} RECORD",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
	$IndentLevel++;
	define_form_fields($SRCHANDLE,$MainFormName,".*",".*","all","true","","\t\t");  
	$IndentLevel--;
	$OutLineNum=ffg_print($SRCHANDLE,"\nEND RECORD",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 	
}:Script>

MAIN
@Define
@Init
	DEFER INTERRUPT
	OPTIONS prompt line ${PromptLine},
	MESSAGE line ${MessageLine},
	#insert key ${InsertKey},
	#delete key ${DeleteKey},
	#next key ${NextKey},
	#previous key ${Previous},
	help file "${ModuleName}.iem",
	help key ${Helpkey}

	WHENEVER ERROR CALL ${ErrorMngmtFunction}

	LET ${ModuleVarPrefix}program="p_${ModuleName}_${ParentTable}"
	CALL init_base("${DatabaseName}",${ModuleVarPrefix}program)
	# opens the database and opens program log file

	CALL main_${ModuleName}_${ParentTable}()

END MAIN

#######################################################
# definition variable sccs
#######################################################
FUNCTION mc_${ModuleName}_sccs()
	DEFINE sccs_var CHAR(70)
	LET sccs_var="%W% %D%"
END FUNCTION


FUNCTION main_${ModuleName}_${ParentTable} ()

	OPEN WINDOW ${MainFormName} at xpos,yposition
	WITH FORM "per/${MainFormName}" attributes(border)

	CALL init_cursor_${ModuleName}_${ParentTable} () # initialize all cursors on master table
	<Script: if ( $ChildTable ne "" ) { 
		$Line = sprintf "CALL init_cursor_${ModuleName}_${DetailTable}\(\)\n";# initialize allcursors on ch table \n";
		$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
		$Line = sprintf "# initialize allcursors on child table\n";
		$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
	}:Script>

	CALL menu_${ModuleName}_${ParentTable}()      
	# Corps  du module

	CALL close_form_${ParentTable}()
	# Ferme la forme, procedures de fin de program 

END FUNCTION

###################################################################
#    OPEN_FORM_${ParentTable} : OPEN MAIN FORM
###################################################################
FUNCTION open_form_${ModuleName}_${ParentTable} ()

	DEFINE nblig,nbcol,xpos,yposition SMALLINT

	LET nblig=${ScreenHeight}
	LET nbcol=${ScreenWidth}
	LET xpos=${xposition}
	LET yposition=${yposition}

	OPEN WINDOW ${MainFormName} at xpos,yposition
	WITH FORM "${MainFormName}" attributes(border)

	# ${MstInpFormRec} is the record for this main form
	INITIALIZE ${MstInpFormRec}.* TO NULL
	INITIALIZE ${MstTableRec}.* TO NULL
	INITIALIZE ${MstSavFormRec}.* TO NULL

	DISPLAY BY NAME ${MstInpFormRec}.*

<Script: if ( $ParentLookupTables > 0 ) { 
	$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
	$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
	$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
	$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) } 
:Script>

END FUNCTION

######################################################################
#    menu_${ModuleName}_${ParentTable}
#    function containing the top level menu
#    input arguments: none
#    output arguments: none
######################################################################

FUNCTION menu_${ModuleName}_${ParentTable} ()
	DEFINE nbsel_${ParentTable} INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE action smallint
	DEFINE xnumber smallint
	DEFINE arr_elem_num smallint

	LET nbsel_${ParentTable} = 0
	MENU "${ParentTable}"
	COMMAND "${Query}" "${QueryCom} ${ParentTable}"
		HELP 1000
		MESSAGE ""
		INITIALIZE ${MstInpFormRec}.* TO NULL
		DISPLAY BY NAME ${MstInpFormRec}.*

		<Script: if ( $ParentLookupTables > 0 ) { 
			$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
		} :Script>

		CALL ${Query}_${ParentTable}() RETURNING nbsel_${ParentTable}
		
		IF nbsel_${ParentTable} >0 THEN 
			DISPLAY BY NAME ${MstInpFormRec}.*
			<Script: if ( $ParentLookupTables > 0 ) { 
				$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n" ;
				$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) ;
			} :Script>
			<Script: if ( $ChildTable ne "" ) { 
				$Line=sprintf   "LET arr_elem_num = disp_arr_$det_clnt_module (${PrmryKeyPrefix}_${ParentTable}.*)\n"; 
				$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) ;
			} :Script>
			IF nbsel_${ParentTable} < 2 THEN
				HIDE OPTION "${Previous}"
				HIDE OPTION "${Next}"
			ELSE
				SHOW OPTION "${Previous}"
				SHOW OPTION "${Next}"
			END IF
		ELSE 
			ERROR "${NorowsSelected}"
			NEXT OPTION "${Query}"
		END IF

	COMMAND "${Next}" "${NextCom} ${ParentTable}"
		HELP 2000
		MESSAGE ""
		INITIALIZE ${MstInpFormRec}.* TO NULL
		DISPLAY BY NAME ${MstInpFormRec}.*
		<Script: if ( $ParentLookupTables > 0 ) { 
			$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
		} :Script>

		IF nbsel_${ParentTable} > 1 THEN
			LET sql_stmt_status = sql_nxtprev_${ParentTable}(1)
			CASE 




			WHEN sql_stmt_status = 1
				DISPLAY BY NAME ${MstInpFormRec}.*
				<Script: if ( $ParentLookupTables > 0 ) { 
					$Line=sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n"; 
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
				} :Script>
				<Script: if ( defined($ChildTable) ) { 
					$Line=sprintf "CALL disp_arr_${det_clnt_module} (${PrmryKeyPrefix}_${ParentTable}.*)\n" ;
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
				} :Script>
			WHEN sql_stmt_status = 0 
				ERROR "${Lastrow} ${ParentTable}"
			WHEN sql_stmt_status = -1 
				ERROR "${Unreachable} ",sqlca.sqlcode

			END CASE
		ELSE
			ERROR " ${SelectFirst}  ${ParentTable} "
			NEXT OPTION "${Query}"
		END IF

	COMMAND "${Previous}" "${PreviousCom} ${ParentTable}"
		HELP 3000
		MESSAGE ""
		INITIALIZE ${MstInpFormRec}.* TO NULL
		DISPLAY BY NAME ${MstInpFormRec}.*
		<Script: if ( $ParentLookupTables > 0 ) { 
			$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
		}:Script>

		IF nbsel_${ParentTable} > 1 THEN
			LET sql_stmt_status = sql_nxtprev_${ParentTable}(-1)
			CASE 



 
			WHEN sql_stmt_status = 1


				DISPLAY BY NAME ${MstInpFormRec}.*
				<Script: if ( $ParentLookupTables > 0 ) { 
					$Line=sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n"; 
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
				} :Script>
				<Script: if ( defined($ChildTable) ) { 
					$Line=sprintf "CALL disp_arr_${det_clnt_module} (${PrmryKeyPrefix}_${ParentTable}.*)\n" ;

					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
				} :Script>
			WHEN sql_stmt_status = 0 
				ERROR "${FirstRow} ${ParentTable}"
			WHEN sql_stmt_status = -1 
				ERROR "${Unreachable} ",sqlca.sqlcode

			END CASE
		ELSE
			ERROR " ${SelectFirst}  ${ParentTable} "
			NEXT OPTION "${Query}"
		END IF

		<Script: if ( defined($ChildTable) ) { 
			$Line=sprintf "COMMAND KEY (\"tab\") \"Array ${DetailTable} ${Presstab}\"\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
			$Line=sprintf "\tCALL edit_arr_${DetailTable} (${PrmryKeyPrefix}_${ParentTable}.*)"; 
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
		} :Script>

   COMMAND "${Update}" "${UpdateCom} ${ParentTable}"
		HELP  4000
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF status_pk_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${Next}"
			ELSE
				LET sql_stmt_status = ${Update}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*)
			END IF
		ELSE
			ERROR " ${SelectFirst} ${ParentTable} "
			NEXT OPTION "${Query}"
		END IF

   COMMAND "${Delete}" "${DeleteCom} ${ParentTable}"
		HELP 5000
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF status_pk_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${Next}"
			END IF
			WHILE TRUE
				CALL confirm_operation(5,10,"${Delete}") RETURNING action
				CASE 
				WHEN action = 0 OR action = 1 
					EXIT WHILE  # degage abandon
				WHEN action = 2   
					CALL ${Delete}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*)
					RETURNING sql_stmt_status
					EXIT WHILE
				END CASE
			END WHILE
		ELSE
			ERROR "${SelectFirst} ${ParentTable} "
			NEXT OPTION "${Query}"
		END IF

   COMMAND "${Insert}" "${InsertCom} ${ParentTable}"
		HELP 3000
		MESSAGE ""
		CALL ${Insert}_${ParentTable}()
		MESSAGE ""

   COMMAND "${Quit}" "${QuitCom}"
		HELP 9000
		MESSAGE ""
		EXIT MENU
   END MENU

END FUNCTION

######################################################################
#    close_form_${ParentTable} : CLOSE MAIN FORM
######################################################################
FUNCTION close_form_${ParentTable}()
	CLOSE WINDOW ${MainFormName}
END FUNCTION

#######################################################################
#    ${Query}_${ParentTable} : SELECTION D'UN ${ParentTable}
#######################################################################
FUNCTION ${Query}_${ParentTable}()
	DEFINE ${RecordPrefix}${ParentTable},where_clause CHAR(1000)
	DEFINE xnumber SMALLINT
	DEFINE sql_stmt_status SMALLINT
	DEFINE reply CHAR(8)
	LET xnumber = 0
	MESSAGE "${InputCriteria}"
	# initialize record and display blank
	INITIALIZE ${MstInpFormRec}.* TO NULL
	DISPLAY BY NAME ${MstInpFormRec}.*
	<Script: if ( $ParentLookupTables > 0 ) { 
		$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
		$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
		$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
	}:Script>

	CONSTRUCT BY NAME where_clause ON <Script: print_form_fields ($SRCHANDLE,$MainFormName,".*","all","false",$ParentTable,"\t\t")  :Script>
	
		<Script: if (defined($do_build_help) ) {  
			$Line=sprintf "ON KEY (\"$Helpkey\")\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) ;
			$Line=sprin tf "\tCALL help_${ParentTable}()\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE,0,0) ;
		 }:Script>

	## Check whether criteria have been entered
	AFTER CONSTRUCT 
		IF NOT field_touched(${ParentTable}.*) AND NOT int_flag THEN
			PROMPT "${SelectAllRows} " FOR CHAR reply
			CASE 
			WHEN reply MATCHES "[Oo]"
				EXIT CONSTRUCT 
			OTHERWISE                  # Saisie d'un critere de selection
				ERROR "${Oneatleast}"
				CONTINUE CONSTRUCT
			END CASE
		END IF
	END CONSTRUCT

	IF int_flag = TRUE THEN
		MESSAGE "${CancelCom}"
		LET int_flag=0
	ELSE
		LET sql_stmt_status = prepare_cnstr_${ParentTable}(where_clause)
		CASE
		WHEN sql_stmt_status = 0
			LET xnumber = open_qbe_${ParentTable}()
		OTHERWISE
			LET xnumber = -1
		END CASE	                                                                    	#@G00312
	END IF
	RETURN xnumber
END FUNCTION




####################################################################
## ${Insert}_${ParentTable}: add a new ${ParentTable} row
####################################################################
FUNCTION ${Insert}_${ParentTable}()

	DEFINE sql_stmt_status SMALLINT
	DEFINE fgl_stmt_status SMALLINT





	DEFINE rows_count SMALLINT
	DEFINE lookup_status INTEGER
	DEFINE nbre_${ParentTable} ,action SMALLINT
	INITIALIZE ${PrmryKeyPrefix}_${ParentTable}.* TO NULL
	INITIALIZE ${MstTableRec}.* TO NULL
	INITIALIZE ${MstInpFormRec}.* TO NULL
	INITIALIZE ${MstSavFormRec}.* TO NULL
	INITIALIZE ${MstLkUpRec}.* TO NULL
	WHILE true
		LET int_flag = false



		<Script:if ( $DoTransactions eq 'true' ) {
			$OutLineNum=ffg_print($SRCHANDLE,"BEGIN WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		}:Script>







		INPUT BY NAME <Script: print_form_fields ($SRCHANDLE,$MainFormName,".*","all","false",${MstInpFormRec},"\t\t")  :Script>
		<Script: print_input_events($SRCHANDLE,$MainFormName,${ParentTable},"pkey,fkey","master","       " ):Script>
		<Script: if ($DoPickListWindows eq 'true' && $ParentLookupTables > 0 ) { 
			bld_picklist_calls($ParentTable) ;
		}:Script>

		<Script: if (defined($do_build_help) ) {  

			$Line=sprintf "ON KEY (\"$Helpkey\")  # Call online help\n" ;
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$Line=sprintf "\tCALL help_${ParentTable}()\n";

			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		} :Script>
		END INPUT
		IF int_flag = TRUE THEN
			# Resign from input
			LET int_flag=false

			LET  ${MstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY BY NAME ${MstInpFormRec}.*
			MESSAGE "${CancelCom} $InterruptKey"
			<Script:if ( $DoTransactions eq 'true' ) {
				$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			}:Script>
			EXIT WHILE
		END IF 












		CALL confirm_operation(3,10,"${Insert}") RETURNING action		#demander la conduite à tenir
		CASE action
		WHEN 1            # I want to edit the input, remains displayed 'as is'
			CONTINUE WHILE   
			


		WHEN 2            # Do commit the transaction
			CALL ${SetTableRecordFct}${ModuleName}_${ParentTable}("I",${MstInpFormRec}.*)


			RETURNING fgl_stmt_status,${MstTableRec}.*
			CALL sql_${Insert}_${ParentTable}() returning sql_stmt_status
			CASE 
			WHEN sql_stmt_status = 0

				MESSAGE "${Insert} ${Successful}"
				<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"COMMIT WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			WHEN sql_stmt_status < 0

				ERROR "${Insert} ${Failed}",sqlca.sqlcode
				<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			END CASE
			EXIT WHILE

		WHEN 0
			EXIT WHILE
		END CASE

	END WHILE
	RETURN sql_stmt_status
END FUNCTION




#######################################################################
#    ${Update}_${ParentTable} : UPDATE A ${ParentTable} RECORD
#######################################################################
FUNCTION ${Update}_${ParentTable}(pky)
	DEFINE action SMALLINT  
	DEFINE sql_stmt_status SMALLINT
	DEFINE fgl_stmt_status SMALLINT







	DEFINE lookup_status INTEGER
	DEFINE nb_modified_rows INTEGER
	DEFINE rows_count INTEGER
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD

	## check if record can be accessed
	WHILE true
		LET int_flag = false

		# Save Screen Record values before altering
		LET ${MstSavFormRec}.* = ${MstInpFormRec}.* 
		<Script:if ( $DoTransactions eq 'true' ) {
			$OutLineNum=ffg_print($SRCHANDLE,"BEGIN WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		}:Script>
		INPUT BY NAME <Script: print_form_fields ($SRCHANDLE,$MainFormName,".*","attr","false",${MstInpFormRec},"         ")  :Script>

		WITHOUT DEFAULTS
		<Script: print_input_events($SRCHANDLE,$MainFormName,${ParentTable},"fkey","master","       " ) :Script>

		<Script: if ($DoPickListWindows eq 'true' && $ParentLookupTables > 0 ) { 
			bld_picklist_calls($ParentTable) ;
		}:Script>
					
		<Script: if (defined($do_build_help) ) {  



			$Line=sprintf "ON KEY (\"$Helpkey\")\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) ;
			$Line=sprintf "\tCALL help_${ParentTable}()\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE,0,0) ;
		}:Script>
		END INPUT
		IF int_flag = TRUE THEN

			LET int_flag=false
			# Restore previous value
			LET ${MstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY BY NAME ${MstInpFormRec}.*
			MESSAGE "$CancelCom $InterruptKey"
			<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			}:Script>
			EXIT WHILE
		END IF 





		CALL confirm_operation(4,10,"${Update}") RETURNING action


		CASE 
		WHEN action = 0 
			# Resign, restore previous values
			LET ${MstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY BY NAME ${MstInpFormRec}.*
			EXIT WHILE   # Cancel operation

		WHEN action = 1 
			# Redo
			CONTINUE WHILE

		WHEN action = 2   
			# confirm update
			CALL ${SetTableRecordFct}${ModuleName}_${ParentTable}("U",${MstInpFormRec}.*)
			RETURNING fgl_stmt_status,${MstTableRec}.*
			CALL sql_${Update}_${ParentTable}(pky.*) RETURNING sql_stmt_status,nb_modified_rows
			CASE 
			WHEN sql_stmt_status = 0

				MESSAGE "${Update} ${Successful} (",nb_modified_rows," )"
				<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"COMMIT WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			WHEN sql_stmt_status < 0

				ERROR "${Update} ${Failed}",sqlca.sqlcode
				<Script:if ( $DoTransactions eq 'true' ) {
						$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			END CASE
			EXIT WHILE



		END CASE

	END WHILE
	RETURN sql_stmt_status
END FUNCTION


##############################################################
FUNCTION ${Delete}_${ParentTable}(pky)
##############################################################
	DEFINE action SMALLINT
	DEFINE sql_stmt_status SMALLINT
	DEFINE nb_deleted_rows INTEGER
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD

	WHILE TRUE
		CALL confirm_operation(5,10,"${Delete}") RETURNING action
		<Script:if ( $DoTransactions eq 'true' ) {
			$OutLineNum=ffg_print($SRCHANDLE,"BEGIN WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
		}:Script>
		CASE 
		WHEN action = 0 OR action = 1 
			EXIT WHILE  # degage abandon
		WHEN action = 2   
			CALL sql_${Delete}_${ParentTable}(pky.*) RETURNING sql_stmt_status,nb_deleted_rows
			CASE 
			WHEN sql_stmt_status = 0
				MESSAGE "${Delete} ${Successful} (",nb_deleted_rows,")"
				<Script:if ( $DoTransactions eq 'true' ) {
					$OutLineNum=ffg_print($SRCHANDLE,"COMMIT WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
				INITIALIZE ${MstInpFormRec}.* TO NULL
				DISPLAY BY NAME ${MstInpFormRec}.*
				<Script: if ( $ParentLookupTables > 0 ) {
					$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
					$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) } 
				:Script>
			WHEN sql_stmt_status < 0
				ERROR "${Delete} ${Failed}",sqlca.sqlcode
				<Script:if ( $DoTransactions eq 'true' ) {
						$OutLineNum=ffg_print($SRCHANDLE,"ROLLBACK WORK\n",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
				}:Script>
			END CASE
			EXIT WHILE
		END CASE
	END WHILE
	RETURN sql_stmt_status
END FUNCTION

########################################################################
#    init_cursor_${ModuleName}_${ParentTable} : DECLARATION AND INIT of cursors
########################################################################
FUNCTION init_cursor_${ModuleName}_${ParentTable} ()
	DEFINE req_text char(1500)

	# PREPARE cursor for full master table row contents, access by primary key
	LET req_text=
	"SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},"all","","","flat","",$endline,1); :Script>",
	" FROM ${ParentTable} ",
	"WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},"pkey","?","","    ") ;:Script>"

	PREPARE sel_mrw_${CursorSufx} FROM req_text
	DECLARE crs_row_${CursorSufx} CURSOR FOR sel_mrw_${CursorSufx}

	# PREPARE cursor for row test / check if locked
	let req_text= "SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},"pkey","","","flat","",$endline,1); :Script>", 
	" FROM ${ParentTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},"pkey","?","","    ") ;:Script>"

	PREPARE sel_${PrmryKeyPrefix}_${CursorSufx} FROM req_text
	DECLARE crs_${PrmryKeyPrefix}_${CursorSufx} CURSOR FOR sel_${PrmryKeyPrefix}_${CursorSufx}

	# PREPARE INSERT statement
	LET req_text =
	"INSERT INTO ${ParentTable} (<Script:print_table_columns($SRCHANDLE,${ParentTable},"all","","","flat","",1); :Script>)",
	" VALUES ( <Script:print_table_columns($SRCHANDLE,${ParentTable},"all","placeholders","","flat","",1); :Script>)" 
	PREPARE pr_ins_${CursorSufx} FROM req_text

	# PREPARE UPDATE statement
	let req_text=
	"UPDATE ${ParentTable} ",
	"SET ( <Script:print_table_columns($SRCHANDLE,${ParentTable},"attr","","","flat","",1); :Script>)",
	" = ( <Script:print_table_columns ($SRCHANDLE,${ParentTable},"attr","placeholders","","flat","",1); :Script>)",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},"pkey","?","","    ") ;:Script>" 
	PREPARE pr_upd_${CursorSufx} FROM req_text

	# PREPARE DELETE statement
	let req_text= "DELETE FROM ${ParentTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},"pkey","?","","    ") ;:Script>" 

	PREPARE pr_del_${CursorSufx} FROM req_text

END FUNCTION

#########################################################
FUNCTION prepare_cnstr_${ParentTable}(qry_stmt)
#########################################################
# this function prepares the CONSTRUCT BY NAME statement
# inbound param: query test
# outbound param  ?
	DEFINE qry_stmt char(500)
	DEFINE ${RecordPrefix}${ParentTable} char( 1000)
	DEFINE rows_count integer
	DEFINE lsql_stmt_status integer

	# define primary_key record
	DEFINE l_pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD

	LET ${RecordPrefix}${ParentTable} = 
		 "SELECT count(*) FROM ${ParentTable}",
		 " WHERE ",qry_stmt CLIPPED 

	PREPARE ${RecordPrefix}nbr_${CursorSufx} FROM ${RecordPrefix}${ParentTable}
	DECLARE crs_nbr_${CursorSufx} CURSOR for ${RecordPrefix}nbr_${CursorSufx}





	LET ${RecordPrefix}${ParentTable} = "SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},"pkey","record","","flat","    "); :Script>",
	" FROM ${ParentTable} ",
	"WHERE ",qry_stmt clipped
	PREPARE rech_${CursorSufx} FROM ${RecordPrefix}${ParentTable}






	# crs_scrl_${CursorSufx} : the first cursor selects all the primary keys (not all the table columns)
	# numeros de ${ParentTable} (SCROLL CURSOR)
	DECLARE crs_scrl_${CursorSufx} SCROLL CURSOR <Script: if ( $DoTransactions eq 'true' ) { $OutLineNum=ffg_print($SRCHANDLE,"WITH HOLD",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE,1); }:Script> FOR rech_${CursorSufx}







	RETURN rows_count
END FUNCTION



#######################################################################
FUNCTION open_qbe_${ParentTable}()
	DEFINE rows_count integer
	DEFINE lsql_stmt_status integer


	# define primary_key record
	DEFINE l_pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD
	
	# Open the cursor that counts the rows for this QBE
	WHENEVER ERROR CONTINUE
	OPEN crs_nbr_${CursorSufx}
	FETCH crs_nbr_${CursorSufx} INTO rows_count
	WHENEVER ERROR CALL ${ErrorMngmtFunction}

	# if FETCH fails, count = 0, the, get back to query
	CASE
	WHEN sqlca.sqlcode
		RETURN -1
	WHEN rows_count = 0
		RETURN rows_count
	OTHERWISE
		# continue
	END CASE
	
	WHENEVER SQLERROR CONTINUE
	# Open the SCROLL CURSOR (only primary_key) and read the whole row
	OPEN crs_scrl_${CursorSufx}
	FETCH FIRST crs_scrl_${CursorSufx} into l_pky.*
	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE



	WHEN sqlca.sqlcode=0
		CALL sql_fetch_mrw_${ParentTable} (l_pky.*)
		RETURNING lsql_stmt_status
	WHEN sqlca.sqlcode=100
		LET rows_count = -1
		close crs_scrl_${CursorSufx}
	WHEN sqlca.sqlcode < 0
		LET rows_count = -2
	END CASE
	RETURN rows_count
END FUNCTION

#######################################################################
# sql_nxtprev_${ParentTable} : FETCH NEXT OR PREVIOUS RECORD
#######################################################################
FUNCTION sql_nxtprev_${ParentTable}(offset)
	DEFINE offset SMALLINT
	define lsql_stmt_status integer
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD

	WHENEVER ERROR CONTINUE
	FETCH RELATIVE offset crs_scrl_${CursorSufx} INTO ${PrmryKeyPrefix}_${ParentTable}.*
	WHENEVER ERROR CALL ${ErrorMngmtFunction}

	CASE 
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status = 1
		CALL sql_fetch_mrw_${ParentTable} (${PrmryKeyPrefix}_${ParentTable}.*)
		RETURNING lsql_stmt_status   
	WHEN sqlca.sqlcode = 100 
		LET lsql_stmt_status = 0
	WHEN sqlca.sqlcode < 0 
		LET lsql_stmt_status = -1	









	END CASE
	RETURN lsql_stmt_status
END FUNCTION

########################################################################
# sql_fetch_mrw_${ParentTable} : read a complete row, including lookups if relevant,
# accessing by primary key
# inbound parameter : primary key
# outbound parameter: sql_stmt_status and row contents
########################################################################
FUNCTION sql_fetch_mrw_${ParentTable}(${PrmryKeyPrefix}_${ParentTable})
	DEFINE sql_stmt_status,fgl_stmt_status,lookup_status smallint
	DEFINE ${PrmryKeyPrefix}_${ParentTable} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD

	# read the table, access on primary key
	WHENEVER ERROR CONTINUE
	OPEN crs_row_${CursorSufx} 
	USING ${PrmryKeyPrefix}_${ParentTable}.*

	FETCH crs_row_${CursorSufx}  INTO ${MstTableRec}.*

	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
   	WHEN sqlca.sqlcode = 0
		LET sql_stmt_status = 1
		CALL ${SetFormRecordFct}${ModuleName}_${MainFormName}(${MstTableRec}.*)
		RETURNING fgl_stmt_status,${MstInpFormRec}.*
		<Script: if ($ParentLookupTables > 0 ) {
			bld_lookup_calls ($ParentTable);
		}:Script>
	WHEN  sqlca.sqlcode = 100 
		LET sql_stmt_status = 0
	WHEN  sqlca.sqlcode < 0 
		LET sql_stmt_status = -1








	END CASE
   RETURN sql_stmt_status
END FUNCTION

########################################################################

## INSERT in table ${ParentTable} 
########################################################################
FUNCTION sql_${Insert}_${ParentTable}()
	DEFINE lsql_stmt_status INTEGER



	DEFINE lookup_status INTEGER
	DEFINE nb_deleted_rows INTEGER
	DEFINE rows_count SMALLINT

	WHENEVER ERROR CONTINUE

	EXECUTE pr_ins_${CursorSufx} 
	USING <Script:print_table_columns($SRCHANDLE,${ParentTable},"all","",${MstTableRec},"","    ",""):Script> # 


	WHENEVER ERROR CALL ${ErrorMngmtFunction}





	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status = 0
	WHEN sqlca.sqlcode < 0
		CALL display_error("${Insert} ${ParentTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
	END CASE
	RETURN lsql_stmt_status
END FUNCTION

########################################################################

## Sql${Update}_${ParentTable} :update current ${ParentTable} record
########################################################################
FUNCTION sql_${Update}_${ParentTable}(pky)
	DEFINE lsql_stmt_status INTEGER

	DEFINE nb_modified_rows INTEGER
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD

	WHENEVER ERROR CONTINUE

	EXECUTE pr_upd_${CursorSufx} 
	USING <Script:print_table_columns($SRCHANDLE,${ParentTable},"attr","",${MstTableRec},"","    ",$endline,1):Script>,

	pky.*





	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status = 0

		LET nb_modified_rows = sqlca.sqlerrd[3]
	WHEN sqlca.sqlcode < 0
		CALL display_error("${Update} ${ParentTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
		LET nb_modified_rows = 0
	END CASE
	RETURN lsql_stmt_status,nb_modified_rows

END FUNCTION

########################################################################
## delete_${ParentTable} :delete Selected row in table ${ParentTable} 
########################################################################
FUNCTION sql_${Delete}_${ParentTable}(pky)
	DEFINE lsql_stmt_status smallint
	DEFINE nb_deleted_rows INTEGER
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD

	WHENEVER ERROR CONTINUE


	EXECUTE pr_del_${CursorSufx} USING pky.*

	WHENEVER ERROR CALL ${ErrorMngmtFunction}




	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status=0

		LET nb_deleted_rows = sqlca.sqlerrd[3]
	WHEN sqlca.sqlcode < 0 
		CALL display_error("${Delete} ${ParentTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
	END CASE
	
	RETURN lsql_stmt_status,nb_deleted_rows
END FUNCTION

################################################################################
#   ${CkPrimaryKeyFct}${ParentTable} : Check if primary key exists
################################################################################
FUNCTION ${CkPrimaryKeyFct}${ParentTable}(pky)  
# Check primary key
# inbound parameter : record of primary key
# outbound parameter:  status > 0  if exists, 0 if no record, < 0 if error
	DEFINE pky RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"pkey","record","pky","    "):Script>
	END RECORD
	DEFINE pk_status INTEGER

	WHENEVER ERROR CONTINUE
	OPEN crs_${PrmryKeyPrefix}_${CursorSufx} USING  pky.*
	FETCH crs_${PrmryKeyPrefix}_${CursorSufx} 
	WHENEVER ERROR CALL ${ErrorMngmtFunction}

	CASE sqlca.sqlcode
	WHEN 0 
		let pk_status = 1
	WHEN 100
	let pk_status = 0
	WHEN sqlca.sqlerrd[2] = 104
		let pk_status = -1		# record locked
	WHEN sqlca.sqlcode < 0
		let pk_status = sqlca.sqlcode
	END CASE

	RETURN pk_status
END FUNCTION

FUNCTION  ${SetFormRecordFct}${ModuleName}_${MainFormName}(tbl_contents)
	DEFINE fgl_status SMALLINT
	DEFINE frm_contents RECORD
		<Script:define_form_fields($SRCHANDLE,$MainFormName,".*","all","false","","\t\t")  :Script>
	END RECORD

	DEFINE tbl_contents RECORD
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD

	INITIALIZE frm_contents.* TO NULL
	<Script:set_form_record ($SRCHANDLE,${ParentTable},${MainFormName},"frm_contents",$MstTableRec) :Script>
	CASE
	WHEN status = 0
		LET fgl_status = 1
	WHEN status < 0
		LET fgl_status = status
	OTHERWISE
		LET fgl_status = status
	END CASE
	RETURN fgl_status,frm_contents.*
END FUNCTION

FUNCTION  ${SetTableRecordFct}${ModuleName}_${ParentTable}(mode,frm_contents)
	DEFINE mode CHAR(1)
	DEFINE fgl_status SMALLINT
	DEFINE frm_contents RECORD
		<Script:define_form_fields($SRCHANDLE,$MainFormName,".*","all","false","","\t\t")  :Script>
	END RECORD

	DEFINE tbl_contents RECORD
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD

	WHENEVER ERROR CONTINUE
	INITIALIZE tbl_contents.* TO NULL
	<Script:set_table_record ($SRCHANDLE,${ParentTable},${MainFormName},"tbl_contents",$MstInpFormRec) :Script>

	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN status = 0
		LET fgl_status = 1
	WHEN status < 0
		LET fgl_status = status
	OTHERWISE
		LET fgl_status = status
	END CASE
	RETURN fgl_status,tbl_contents.*
END FUNCTION

<Script: if ($ParentLookupTables > 0 ) {
	bld_lookup_queries ( $ParentTable );
}:Script>

FUNCTION ${ErrorMngmtFunction}()
	DEFINE context RECORD
		logname       CHAR(8),
		terminal      CHAR(8),
		text_err      CHAR(80)
	END RECORD
	DEFINE fgl_err integer
	DEFINE isam_err integer

	LET fgl_err = sqlca.sqlcode
	LET isam_err = sqlca.sqlerrd[2]

END FUNCTION


FUNCTION confirm_operation(xpos,ypos,msg)
	DEFINE xpos,ypos SMALLINT  #can be removed
	DEFINE msg char(40)
	DEFINE reply CHAR(8)
	define action smallint
	define prpmsg char(60)


	LET reply = fgl_winbutton("",msg,"${Yes}","${Yes}|${No}|${Cancel}","question",0) 

	#OPEN window w_confirm at xpos,ypos with 1 rows, 50 columns
	#attributes (border)
	#let prpmsg = msg clipped, ": ${ConfMsg} ( ${Yes}/${No}/${Cancel} )"
	#prompt prpmsg clipped for char reply
	CASE
	WHEN reply = "${Yes}"
		LET action= 2
	WHEN reply = "${No}"
		LET action= 1
	WHEN reply = "${Cancel}"
		LET action= 0
	OTHERWISE
		LET action= 1
	END CASE
	#close window w_confirm
	RETURN action
END FUNCTION

FUNCTION display_error(mesg,the_status)
	DEFINE mesg char(30)
	DEFINE the_status INTEGER
	ERROR mesg,the_status
END FUNCTION

FUNCTION init_base(dbname,progname)
	DEFINE progname CHAR(8)
	DEFINE dbname CHAR(8)
	DEFINE query char(100)
	DEFINE logdir char(64)
	DEFINE logfile char(64)
	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	LET logdir=fgl_getenv("LOGFILE")
	IF length(logdir) = 0 THEN
		LET logdir="."
	END IF
	LET logfile=logdir clipped,"/",progname clipped,".log"
	CALL STARTLOG (logfile)
	LET query = "database ",dbname clipped
	PREPARE openbase FROM query
	EXECUTE openbase
	WHENEVER ERROR CONTINUE
	IF sqlca.sqlcode < 0 THEN
		ERROR "${DbNotAvailable}"
		exit program
	END IF
	WHENEVER ERROR CALL ${ErrorMngmtFunction}
END FUNCTION

<Script: if ( $ParentLookupTables > 0 && $DoPickListWindows eq "true" ) { 
	bld_picklist_windows($ModuleName) ;
} :Script>

<Script: if ($DoHelp eq 'true') {
	build_fct_Help(${MainFormName},${ParentTable});
   build_doc_Help(${MainFormName},$mstr_clnt_module)
}:Script>