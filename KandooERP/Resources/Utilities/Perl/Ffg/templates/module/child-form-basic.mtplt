<Script:our $ChildSRArray=${SRArrayPrefix} . ${ChildTable}  :Script>noprint
<Script:our $ChildPkyArray= ${PkyArrayPrefix} . ${ChildTable} :Script>noprint
<Script:our $ChildFkyArray= ${FkyArrayPrefix} . ${ParentTable} :Script>noprint
<Script:our $ChildActArray=${ActArrayPrefix} . ${ChildTable}  :Script>noprint
<Script:our $ChlTableRec=${TblPrfx} . ${ChildTable} :Script>noprint
<Script:our $ChlSavFormRec=${SRSavPrfx} . ${ChildSRArray} :Script>noprint
# module  generated by Kandoo Ffg(c) 
# Generated on ${GenerationTS}
# template ${TemplateFile} 
DATABASE ${DatabaseName}
DATABASE ${DatabaseName}
GLOBALS
	DEFINE ${GlobalVarPrefix}${ParentTable} RECORD LIKE ${ParentTable}.*
END GLOBALS

# Define data types with MODULE scope, they will be used to define local variables and records
DEFINE ${TypeDataPrefix}${PrmryKeyPrefix}_${ChildTable} TYPE AS RECORD			# primary key type of child table $ChildTable
		<Script:define_PK_columns ($SRCHANDLE,${ChildTable},"pky",$DefineStyle):Script>
END RECORD

DEFINE ${TypeDataPrefix}fky_${ParentTable} TYPE AS RECORD			# foreign key type from $ChildTable to $ParentTable
	<Script: define_join_columns ($SRCHANDLE,${ChildTable},${ParentTable},$DefineStyle):Script> 
END RECORD
	
DEFINE ${TypeDataPrefix}SR_${ChildTable} TYPE AS RECORD				# Screen Record type for the main array
	<Script:define_form_fields($SRCHANDLE,$MainFormName,".*","child",".*","","all","","\t\t")  :Script>
END RECORD

DEFINE ${TypeDataPrefix}table_record_${ChildTable} TYPE AS RECORD	# Child table Record for $ChildTable
	<Script: define_table_columns ($SRCHANDLE,${ChildTable},"","","all","record","","    "):Script>
END RECORD

# The array have MODULE scope
DEFINE ${ChildActArray} DYNAMIC ARRAY OF CHAR(1)		# Array storing the action to be done for each element ('=' -> Do nothing, '+' -> Add row, '#' modify row, '-' -> delete row)

DEFINE ${ChildPkyArray} DYNAMIC ARRAY OF ${TypeDataPrefix}${PrmryKeyPrefix}_${ChildTable}		# Array storing the primary key value of each element

DEFINE fky_${ParentTable} DYNAMIC ARRAY OF ${TypeDataPrefix}fky_${ParentTable}		# Array storing the foreign key value pointing to parent table

DEFINE ${ChildSRArray} DYNAMIC ARRAY OF ${TypeDataPrefix}SR_${ChildTable}			# Array storing the actual data

DEFINE ${ChlTableRec} ${TypeDataPrefix}table_record_${ChildTable}							# image record for each element

FUNCTION ${SqlPrepareQueriesFct}_${ModuleName}_child ()
# this function initializes all cursors and prepared statements for the ${ChildTable} and lookups

DEFINE sql_stmt_text STRING 
	# Prepare the cursor to display the ${ChildTable} array
	# using foreign key pointing to ${ParentTable}
	
	LET sql_stmt_text = "SELECT '=',",
	"<Script:print_table_columns($SRCHANDLE,${ChildTable},"","","","pkey","",${ChildTable},"flat","    "); :Script>,",
	<Script:print_form_fields ($SRCHANDLE,$FormName,".*","child",".*","","","TblName","",'quoteskip') ;:Script>
	<Script:bld_scr${RecordPrefix}join($SRCHANDLE,$FormName,$ChildScreenRecord,$ParentTable,$ChildTable,".*", ".*",".*","TblName","","quoteskip",""); :Script>
	" AND <Script: bld_where_clause($SRCHANDLE,${ChildTable},"fkey:${ParentTable}","?","","    ") ;:Script>",
	" ORDER BY <Script:print_table_columns($SRCHANDLE,${ChildTable},"","","","pkey","",${ChildTable},"flat","    "); :Script>"
	PREPARE ${PrepStmtPrefix}child_${ChildTable} FROM sql_stmt_text
	DECLARE ${CursorPrefix}child_${ChildTable} CURSOR FOR ${PrepStmtPrefix}child_${ChildTable}

	# PREPARE INSERT statement
/# use print_table_columns with "child" in the 3 parameter will only take the screen record fields for this table -> you insert only the screen record values
/# setting this option to "" will use the full table record -> you insert all the table values
/# define the record accordingly in the ${SqlInsertFct}_${ChildTable} function and calling functions
	LET sql_stmt_text =
	"INSERT INTO ${ChildTable} (<Script:print_table_columns($SRCHANDLE,${ChildTable},"","","","pkey","","","flat","",""):Script>,",
	"<Script:print_table_columns($SRCHANDLE,${ChildTable},"child","","","attr","","","flat","",""):Script> )",
	" VALUES ( <Script:print_table_columns($SRCHANDLE,${ChildTable},"","","","pkey","placeholders","","flat","",1); :Script>,
	<Script:print_table_columns($SRCHANDLE,${ChildTable},"child","","","attr","placeholders","","flat","",""):Script> )" 
	PREPARE ${PrepStmtPrefix}ins_${ChildTable} FROM sql_stmt_text

	# PREPARE UPDATE statement
/# use print_table_columns with "child" in the 3 parameter will only take the screen record fields for this table -> you update only the screen record values
/# setting this option to "" will use the full table record -> you update all the table values
/# define the record accordingly in the ${SqlUpdateFct}_${ChildTable} function and calling functions
	let sql_stmt_text=
	"UPDATE ${ChildTable} ",
	"SET ( <Script:print_table_columns($SRCHANDLE,${ChildTable},"child","","false","attr","","","flat","",""); :Script>)",
	" = ( <Script:print_table_columns ($SRCHANDLE,${ChildTable},"child","","false","attr","placeholders","","flat","",""); :Script>)",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ChildTable},"pkey","?","","    ") ;:Script>" 
	PREPARE ${PrepStmtPrefix}upd_${ChildTable} FROM sql_stmt_text

	# PREPARE DELETE statement
	let sql_stmt_text= "DELETE FROM ${ChildTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ChildTable},"pkey","?","","    ") ;:Script>" 
	PREPARE ${PrepStmtPrefix}del_${ChildTable} FROM sql_stmt_text
	
END FUNCTION



FUNCTION ${DeclareArrayCursorFct}_${ChildSRArray}(fky)
## This function opens the main cursor for the table ${ChildTable}

	DEFINE lsql_ok integer
	DEFINE fky ${TypeDataPrefix}fky_${ParentTable}				# foreign key from $ChildTable to $ParentTable


	RETURN lsql_ok
END FUNCTION	#${DeclareArrayCursorFct}_${ChildSRArray}

FUNCTION ${SqlInsertFct}_${ChildTable}(lr_${ChildTable})
## INSERT in table ${ChildTable} 
/# we take the full table record as inbound parameter, but insert can be done only on fields of screen record
	DEFINE lr_${ChildTable} ${TypeDataPrefix}table_record_${ChildTable}
	DEFINE lsql_stmt_status INTEGER
	DEFINE lookup_status INTEGER
	DEFINE nb_deleted_rows INTEGER

	WHENEVER SQLERROR CONTINUE
	EXECUTE ${PrepStmtPrefix}ins_${ChildTable}
	USING <Script:print_table_columns($SRCHANDLE,${ChildTable},"","","","pkey","","lr_${ChildTable}","flat","",""):Script>,
	<Script:print_table_columns($SRCHANDLE,${ChildTable},"child","","","attr","","lr_${ChildTable}","flat","",""):Script>
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status = 0
	WHEN sqlca.sqlcode < 0
		CALL display_error("${SqlInsertFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
	END CASE
	RETURN lsql_stmt_status
END FUNCTION	#${SqlInsertFct}_${ChildTable}

FUNCTION ${SqlUpdateFct}_${ChildTable}(pky,lr_${ChildTable})
## ${SqlUpdateFct}_${ChildTable} :update current ${ChildTable} record
	DEFINE lr_${ChildTable} ${TypeDataPrefix}table_record_${ChildTable}
	DEFINE pky ${TypeDataPrefix}${PrmryKeyPrefix}_${ChildTable}
	DEFINE lsql_stmt_status INTEGER
	DEFINE nb_modified_rows INTEGER

	WHENEVER SQLERROR CONTINUE
	EXECUTE ${PrepStmtPrefix}upd_${ChildTable} 
	USING <Script:print_table_columns($SRCHANDLE,${ChildTable},"child","","false","attr","","lr_${ChildTable}","","    ",$endline,1):Script>,
	pky.*

	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status = 0
		LET nb_modified_rows = sqlca.sqlerrd[3]
	WHEN sqlca.sqlcode < 0
		CALL display_error("${SqlUpdateFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
		LET nb_modified_rows = 0
	END CASE
	RETURN lsql_stmt_status,nb_modified_rows
END FUNCTION	#${SqlUpdateFct}_${ChildTable}

FUNCTION ${SqlDeleteFct}_${ChildTable}(pky)
## delete_${ChildTable} :delete Selected row in table ${ChildTable} 
	DEFINE lsql_stmt_status smallint
	DEFINE nb_deleted_rows INTEGER
	DEFINE pky ${TypeDataPrefix}${PrmryKeyPrefix}_${ChildTable}

	WHENEVER SQLERROR CONTINUE
	EXECUTE ${PrepStmtPrefix}del_${ChildTable} USING pky.*

	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN sqlca.sqlcode = 0
		LET lsql_stmt_status=0
		LET nb_deleted_rows = sqlca.sqlerrd[3]
	WHEN sqlca.sqlcode < 0 
		CALL display_error("${SqlDeleteFct} ${ChildTable}:${Failed} ",sqlca.sqlcode)
		LET lsql_stmt_status = -1
	END CASE
	
	RETURN lsql_stmt_status,nb_deleted_rows
END FUNCTION	#${SqlDeleteFct}_${ChildTable}

################################################################################
FUNCTION ${SqlCheckPrimaryKeyFct}_${ChildTable}(pky)  
#"# This function Checks if primary key exists
## inbound parameter : record of primary key
## outbound parameter:  status > 0  if exists, 0 if no record, < 0 if error
################################################################################
	DEFINE pky ${TypeDataPrefix}${PrmryKeyPrefix}_${ChildTable}
	DEFINE pk_status INTEGER

	WHENEVER SQLERROR CONTINUE
	OPEN crs_${PrmryKeyPrefix}_${CursorSufx} USING  pky.*
	FETCH crs_${PrmryKeyPrefix}_${CursorSufx} 
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	CASE sqlca.sqlcode
	WHEN 0 
		let pk_status = 1
	WHEN 100
	let pk_status = 0
	WHEN sqlca.sqlerrd[2] = 104
		let pk_status = -1		# record locked
	WHEN sqlca.sqlcode < 0
		let pk_status = sqlca.sqlcode
	END CASE
	RETURN pk_status
END FUNCTION	#${SqlCheckPrimaryKeyFct}_${ChildTable}

<Script: if ($ChildLookupTables > 0 ) {
	#bld_lookup_queries ( $ChildTable );
}:Script>

#######################################################################
FUNCTION ${InitializeArrayFct}_${ChildTable}()
#######################################################################
	# initializes arrays
	CALL ${ChildActArray}.clear()
	CALL ${ChildSRArray}.clear()
	CALL ${ChildPkyArray}.clear()
END FUNCTION

######################################################################################################################################################
FUNCTION ${PopulateArrayFct}${ChildTable} (fky_${ParentTable})
# this function opens the child array foreach cursor with its foreign key, and executes the foreach
# inbound: foreign key
# outbound: fetched rows number or error code
######################################################################################################################################################
	DEFINE elements_number,choice,xpos,ypos INTEGER
	DEFINE ${ArrCurrVar},${ScrLineVar} INTEGER
	DEFINE sql_ok INTEGER
	DEFINE ${QbeStmtVariable} STRING
	DEFINE doforeach,exitdisplay BOOLEAN
	DEFINE where_clause STRING
	DEFINE fky_${ParentTable} ${TypeDataPrefix}fky_${ParentTable}

	DEFINE sql_stmt_status INTEGER
	
	# opening array cursor and fetch data only when reading the parent row
	WHENEVER SQLERROR CONTINUE
	OPEN ${CursorPrefix}child_${ChildTable} USING fky_${ParentTable}.*
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	CASE 
	WHEN sqlca.sqlcode = 100   
		RETURN 0
	WHEN sqlca.sqlcode < 0 
		RETURN sqlca.sqlcode
	END CASE

	LET elements_number = 1
	FOREACH ${CursorPrefix}child_${ChildTable} INTO ${ChildActArray}[elements_number],${ChildPkyArray}[elements_number].*,${ChildSRArray}[elements_number].*
		LET elements_number = elements_number + 1
	END FOREACH

	#INITIALIZE ${ChildSRArray}[elements_number].* TO NULL
	#CALL ${ChildActArray}.append()
	#CALL ${ChildPkyArray}.append()
	#INITIALIZE ${ChildPkyArray}[elements_number].* TO NULL
	#INITIALIZE ${ChildActArray}[elements_number] TO NULL

	RETURN elements_number-1
END FUNCTION	# ${PopulateArrayFct}${ChildTable}


FUNCTION ${DisplayArrayFct}${ChildTable} (exitdisplay)
# This function displays the array data (${ChildSRArray})
# inbound: exitdisplay: if true, the array is displayed but no navigation possible in the array, true allows to navigate in the array
DEFINE exitdisplay BOOLEAN
	DISPLAY ARRAY ${ChildSRArray}
	TO ${ChildScreenRecord}.*
	BEFORE DISPLAY
		IF exitdisplay = true THEN
			EXIT DISPLAY
		END IF
	END DISPLAY
END FUNCTION	# ${DisplayArrayFct}${ChildTable}

###########################################################################################################
FUNCTION ${EditArrayFct}${ChildTable} (fky_${ParentTable})
# This function calls the INPUT array function (${InputArrayFct}_${ChildTable}) to edit the array data
# then, accordingly, the SQL statement functions (${ArrayBulkUpdFct})
# it is generally called from another module
###########################################################################################################
	DEFINE ${ScrLineVar} INTEGER
	DEFINE ${ArrCurrVar} INTEGER
	DEFINE bulk_update_status SMALLINT
	DEFINE nbr_edited_rows INTEGER
	DEFINE next_action SMALLINT
	DEFINE i smallint
	DEFINE fky_${ParentTable} ${TypeDataPrefix}fky_${ParentTable}

	BEGIN WORK
	
	WHILE TRUE
		CALL ${InputArrayFct}_${ChildTable} (fky_${ParentTable}.*) RETURNING nbr_edited_rows,next_action
		IF nbr_edited_rows > 0 THEN
			CASE 
			WHEN  next_action = 2
				LET bulk_update_status = ${ArrayBulkUpdFct}${ChildTable} (fky_${ParentTable})
				IF bulk_update_status > 0 THEN
					ROLLBACK WORK
					ERROR "${InputArrayFct} ${Failed}"
				ELSE
					ERROR "${InputArrayFct} ${Successful}"
					COMMIT WORK
					EXIT WHILE
				END IF
			WHEN next_action = 1
				# No
				ERROR "Please INPUT ARRAY AGAIN"
			WHEN next_action = 0
				# Cancel
				MESSAGE "Cancelled, exit INPUT ARRAY"
				EXIT WHILE
			END CASE
		ELSE
			# Nothing
			MESSAGE "Nothing has been changed"
			EXIT WHILE
		END IF
	END WHILE

END FUNCTION	# ${EditArrayFct}${ChildTable}

####################################################################################################################
FUNCTION ${InputArrayFct}_${ChildTable} (fky_${ParentTable})
## this function operates INPUT ARRAY for the table ${ChildTable}
# it handles 2 arrays:
# 1) the Input Data Array (${ChildSRArray}) will contain the data input by the user
# 2) the primary key array (${PrmryKeyPrefix}_${ParentTable}) contains the status for each element: 
#    NULL=>no data, 0=>elements not touched, 1=>element to INSERT, 2=>element to UPDATE, -1=>element to DELETE
#    and also contains the primary key values of each element
###################################################################################################################
	DEFINE arrcnt INTEGER
	DEFINE ${ScrLineVar} INTEGER
	DEFINE ${ArrCurrVar} INTEGER
	DEFINE last_element INTEGER
	DEFINE lookup_status INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE nbr_edited_rows INTEGER
	DEFINE next_action smallint
	DEFINE ins_key smallint
	DEFINE fky_${ParentTable} ${TypeDataPrefix}fky_${ParentTable}
	DEFINE ${ChlSavFormRec} ${TypeDataPrefix}${PrmryKeyPrefix}_${ChildTable}

	DEFINE sql_ok SMALLINT
	LET nbr_edited_rows = 0

	LET int_flag = FALSE
	LET ins_key = FALSE
	INPUT ARRAY ${ChildSRArray} WITHOUT DEFAULTS
	FROM ${ChildScreenRecord}.*
	ATTRIBUTES(unbuffered, append row = true, auto append = true,delete row = false)
	BEFORE INPUT
		CALL fgl_dialog_setkeylabel("CANCEL","")
		CALL fgl_dialog_setkeylabel("ACCEPT","")
		
	ON KEY (INTERRUPT)
		# Cancel from input
		LET int_flag=false
		LET ${ArrCurrVar} = arr_curr()
		LET ${ScrLineVar} = scr_line ()
		LET  ${ChildSRArray}[${ArrCurrVar}].* = ${ChlSavFormRec}.*
		DISPLAY ${ChildSRArray}[${ArrCurrVar}].* TO ${ChildScreenRecord}[${ScrLineVar}].*
		MESSAGE "${CancelCom} ${CancelKey}"
		ROLLBACK WORK
		EXIT INPUT

	BEFORE INSERT
		# insert a row in ${PrmryKeyPrefix}_array
		LET ${ArrCurrVar} = arr_curr()
		LET ${ScrLineVar} = scr_line ()
		CALL ${ChildPkyArray}.insert(${ArrCurrVar})
		INITIALIZE ${ChildPkyArray}[${ArrCurrVar}].* TO NULL
		CALL ${ChildActArray}.insert(${ArrCurrVar})
		LET ${ChildActArray}[${ArrCurrVar}] = "I"

	BEFORE ROW
		LET ${ScrLineVar} = scr_line()
		LET ${ArrCurrVar} = arr_curr()
		LET ${ChlSavFormRec}.* = ${ChildSRArray}[${ArrCurrVar}].*

	<Script: 
		print_input_events($SRCHANDLE,$MainFormName,${ChildTable},"child","pkey|fkey",$ChildSRArray,"       ","fky_${ParentTable}" );
	:Script>

	<Script: if ($DoPickListWindows eq 'true' && $ChildLookupTables > 0 ) { 
		bld_picklist_calls($ChildTable) ;
	}:Script>

	AFTER DELETE
		IF ${ChildActArray}[${ArrCurrVar}] IS NOT NULL THEN
			LET last_element = ${ChildPkyArray}.getsize()
			# The deleted element becomes the last element of status_array and flagged -1
			# The pky is also copied to the last element
			LET ${ChildPkyArray}[last_element].* = ${ChildPkyArray}[${ArrCurrVar}].*
			LET ${ChildActArray}[${ArrCurrVar}] = "D"  # to be Deleted
			LET nbr_edited_rows = nbr_edited_rows + 1
		END IF

	AFTER ROW
		IF field_touched (${ChildScreenRecord}[${ScrLineVar}].*) THEN
			LET nbr_edited_rows = nbr_edited_rows + 1
			CASE
			WHEN ${ChildActArray}[${ArrCurrVar}] = "="		# existing
				LET ${ChildActArray}[${ArrCurrVar}] = "U"	# to be modified
				<Script: set_pk_values($SRCHANDLE,$MainFormName,$ChildScreenRecord,$ChildSRArray,$ChildPkyArray,$ParentTable,$ChildTable,"update") :Script>

			WHEN ${ChildActArray}[${ArrCurrVar}] IS NULL	# new
				LET ${ChildActArray}[${ArrCurrVar}] = "I"	# to be inserted
				<Script: set_pk_values($SRCHANDLE,$MainFormName,$ChildScreenRecord,$ChildSRArray,$ChildPkyArray,$ParentTable,$ChildTable,"insert") :Script>
				<Script: bld_ck_pk_value($ChildTable,$ChildPkyArray .'[' . ${ArrCurrVar} . ']') :Script>
			END CASE
			
		END IF

	AFTER INPUT
		IF int_flag THEN
			LET int_flag = FALSE
			ERROR " ${Cancel} ${ChildTable}"
			LET nbr_edited_rows = 0
			LET next_action = 0
		ELSE
			LET next_action = confirm_operation(5,10,"${InputArrayFct} ") 
			IF next_action = 1 THEN
				CONTINUE INPUT
			END IF
		END IF
END INPUT
RETURN nbr_edited_rows,next_action
END FUNCTION	# ${InputArrayFct}_${ChildTable}

######################################################################################################
FUNCTION ${SetFormRecordFct}_${MainFormName}_${ChildScreenRecord}(tbl_contents)
# This function assigns the values from the table ${ChildScreenRecord} to the form record frm_contents
######################################################################################################
	DEFINE fgl_status SMALLINT
	DEFINE frm_contents ${TypeDataPrefix}SR_${ChildTable}
	DEFINE tbl_contents ${TypeDataPrefix}table_record_${ChildTable}

	INITIALIZE frm_contents.* TO NULL
	<Script:set_form_record ($SRCHANDLE,$ChildTable,$FormName,"frm_contents",$ChlTableRec,$ChildScreenRecord) :Script>
	CASE
	WHEN status = 0
		LET fgl_status = 1
	WHEN status < 0
		LET fgl_status = status
	OTHERWISE
		LET fgl_status = status
	END CASE
	RETURN fgl_status,frm_contents.*
END FUNCTION	# ${SetFormRecordFct}_${MainFormName}_${ChildScreenRecord}

######################################################################################################
FUNCTION ${SetTableRecordFct}_${MainFormName}_${ChildTable}(sql_stmt_type,fky,pky,element_contents)
# This function assigns the values from the array element(element_contents) to the table record (tbl_contents)
# It distinguishes the primary key (pky) of the table ${ChildTable}and the foreign key (fky) point to the parent table (${ParentTable})
######################################################################################################
	DEFINE sql_stmt_type CHAR(1)			-- "I" => INSERT   "U" => UPDATE
	DEFINE fgl_status SMALLINT
	DEFINE element_contents ${TypeDataPrefix}SR_${ChildTable}
	DEFINE tbl_contents ${TypeDataPrefix}table_record_${ChildTable}
	DEFINE fky ${TypeDataPrefix}fky_${ParentTable}
	DEFINE pky ${TypeDataPrefix}${PrmryKeyPrefix}_${ChildTable}

	#WHENEVER SQLERROR CONTINUE
	INITIALIZE tbl_contents.* TO NULL
	CASE sql_stmt_type
	WHEN "I"		-- set table record to insert row
		<Script:set_table_record ($SRCHANDLE,$ChildTable,$FormName,"child","element_contents","tbl_contents","I",$ChildScreenRecord) :Script>
	
	WHEN "U"		-- set table record to update row
		<Script:set_table_record ($SRCHANDLE,$ChildTable,$FormName,"child","element_contents","tbl_contents","U",$ChildScreenRecord) :Script>
	END CASE
	
	WHENEVER ERROR CALL ${ErrorMngmtFunction}
	CASE
	WHEN status = 0
		LET fgl_status = 1
	WHEN status < 0
		LET fgl_status = status
	OTHERWISE
		LET fgl_status = status
	END CASE
	RETURN fgl_status,tbl_contents.*
END FUNCTION	# ${SetTableRecordFct}_${MainFormName}_${ChildTable}

#############################################################################################################
FUNCTION ${ArrayBulkUpdFct}${ChildTable} (parent_fky)
## This functions browses the action array ${ChildActArray}},
# copies the element values to table values (${ChildTable})
# and executes the request SQL operation requested for each element
#############################################################################################################
	DEFINE idx,arr_size INTEGER
	DEFINE updarr_status,fgl_status,global_status INTEGER
	DEFINE parent_fky ${TypeDataPrefix}fky_${ParentTable}
	DEFINE elements_contents ${TypeDataPrefix}SR_${ChildTable}
	DEFINE l_${ChildTable} ${TypeDataPrefix}table_record_${ChildTable}

	LET global_status = 0
	LET arr_size = ${ChildPkyArray}.getsize()
	FOR idx = 1 TO arr_size
		CASE
		WHEN ${ChildActArray}[idx] = "="
			CONTINUE FOR
		WHEN ${ChildActArray}[idx] MATCHES "[+#]"		# Insert,delete or update
			CALL ${SetTableRecordFct}_${MainFormName}_${ChildTable} (${ChildActArray}[idx],parent_fky.*,${ChildPkyArray}[idx].*,${ChildSRArray}[idx].*)
			RETURNING fgl_status,l_${ChildTable}.*
		END CASE
		LET updarr_status = ${SqlArrayUpdateOneElemFct}_${ChildTable}(idx,l_${ChildTable}.*)
		IF updarr_status < 0 THEN
			ERROR "Error on element # ",idx
			LET global_status = global_status + 1
		END IF
	END FOR
	RETURN global_status
END FUNCTION 	# ${ArrayBulkUpdFct}${ChildTable}


###############################################################################
FUNCTION ${SqlArrayUpdateOneElemFct}_${ChildTable}(idx,lr_${ChildTable})
## This function executes the SQL statement for each element
## accord the to status array value of this element
###############################################################################
DEFINE st SMALLINT
DEFINE arrcnt SMALLINT
DEFINE idx SMALLINT 
DEFINE statut SMALLINT
DEFINE lr_${ChildTable} ${TypeDataPrefix}table_record_${ChildTable}

LET st = 0
	CASE ${ChildActArray}[idx] 
	WHEN "U"	# must be updated
		LET statut = ${SqlUpdateFct}_${ChildTable}(${ChildPkyArray}[idx].*,lr_${ChildTable}.*)
	WHEN "I"	# must be inserted
		LET statut = ${SqlInsertFct}_${ChildTable}(lr_${ChildTable}.*)
	WHEN "D"	# must be deleted
		LET statut = ${SqlDeleteFct}_${ChildTable}(${ChildPkyArray}[idx].*)
	END CASE
return statut
END FUNCTION		# ${SqlArrayUpdateOneElemFct}_${ChildTable}

FUNCTION ${QBEArrayFct}${ChildTable}() 
	## ${FrmConstructDatasetFct}_${ChildTable}: Query By Example on table ${ChildTable}
	## Input selection criteria,
	## prepare the query,
	## open the data set
	DEFINE where_clause,temp_where_clause STRING 
	DEFINE connection_string STRING 
	DEFINE xnumber,sql_stmt_status INTEGER  
	DEFINE reply CHAR(5) 
	DEFINE match util.match_results 

	LET xnumber = 0 
	MESSAGE "Please input query criteria" 
	# initialize record and display blank
	CLEAR FORM 

	CONSTRUCT BY NAME where_clause 
	ON <Script: print_form_fields ($SRCHANDLE,$FormName,${ChildTable},"child",".*","false",".*","TblName","\t\t","","","reset"):Script> 

		## Check whether criteria have been entered
		AFTER CONSTRUCT 
			IF NOT field_touched(${ChildScreenRecord}.*) AND NOT int_flag THEN 
				LET reply = fgl_winbutton("","Select all rows, are you sure?","Yes","Yes|No","question",0) 
				CASE 
					WHEN reply matches "Yes" 
						EXIT CONSTRUCT 
					OTHERWISE # saisie d'un critere de selection 
						ERROR "Please input a least one criteria" 
						CONTINUE CONSTRUCT 
				END CASE 
			END IF 
	END CONSTRUCT 

	IF int_flag = true THEN 
		MESSAGE "Quit with quit key" 
		LET int_flag=0 
	ELSE 
	END IF 
	RETURN where_clause 
END FUNCTION # ${FrmConstructDatasetFct}_${ChildTable}

FUNCTION ${SqlOpenQBEArrCrsFct}_${ChildTable} (where_clause)
DEFINE where_clause STRING
DEFINE sql_stmt_text STRING
	# Prepare the cursor to display the ${ChildTable} array from the qbe on child table 
	# using foreign key pointing to dbschema_properties

	LET sql_stmt_text = "SELECT '=',",
	"<Script:print_table_columns($SRCHANDLE,${ParentTable},"","","","pkey","",${ParentTable},"flat","    "); :Script>,",
	<Script:print_form_fields ($SRCHANDLE,$FormName,".*","child",".*",".*",".*","TblName","",'quoteskip') ;:Script>
	<Script:bld_scr${RecordPrefix}join($SRCHANDLE,$FormName,$ChildScreenRecord,$ParentTable,$ChildTable,".*", ".*",".*","TblName","","quoteskip",""); :Script>
	" AND ",where_clause ,
	" ORDER BY <Script:print_table_columns($SRCHANDLE,${ChildTable},"","","","pkey","",${ChildTable},"flat","    "); :Script>"
	PREPARE ${PrepStmtPrefix}child_qbe_${ChildTable} FROM sql_stmt_text
	DECLARE ${CursorPrefix}child_qbe_${ChildTable} CURSOR FOR ${PrepStmtPrefix}child_qbe_${ChildTable}

END FUNCTION	# ${SqlOpenQBEArrCrsFct}_${ChildTable}

FUNCTION ${DisplayQBEArrCrsFct}_${ChildTable} (where_clause,open_foreach_cursor,exit_display) 
# This function displays the array data (scr_arraydbschema_fix) based on the foreign key
# browse: False means that the array is displayed without possibility of browsing inside (just show array and skip to next parent row)
######################################################################################################################################################
	DEFINE elements_number,choice,xpos,ypos INTEGER 
	DEFINE arrcurr,srcline INTEGER 
	DEFINE sql_ok INTEGER 
	DEFINE qbe_stmt STRING 
	DEFINE open_foreach_cursor,exit_display boolean 
	DEFINE where_clause STRING 
	DEFINE fky RECORD 
		fix_dbsname LIKE dbschema_fix.fix_dbsname # nchar(15) 
		#@G00214
	END RECORD 
	DEFINE pick_${ChildSRArray} DYNAMIC ARRAY OF ${TypeDataPrefix}SR_${ChildTable}			# Array storing the actual data
	DEFINE ${ChildFkyArray} DYNAMIC ARRAY OF ${TypeDataPrefix}fky_${ParentTable}		# Array storing the foreign key value of each element
	DEFINE sql_stmt_status,record_found INTEGER 
	DEFINE script_file,log_file STRING 
	DEFINE script_contents,log_contents STRING 
	IF open_foreach_cursor = true THEN 
		CALL ${ChildActArray}.clear()
		CALL pick_${ChildSRArray}.clear()
		CALL ${ChildFkyArray}.clear()
		# opening array cursor and fetch data only when reading the parent row 
		LET elements_number = 1 
		FOREACH ${CursorPrefix}child_qbe_${ChildTable} INTO ${ChildActArray}[elements_number],${ChildFkyArray}[elements_number].*, pick_${ChildSRArray}[elements_number].*
			LET elements_number = elements_number + 1 
		END FOREACH 
		IF elements_number > 1 THEN 
			CALL pick_${ChildSRArray}.deleteelement(elements_number) 
		END IF 
	END IF 

	DISPLAY ARRAY pick_${ChildSRArray} 
	TO ${ChildScreenRecord}.* 
		BEFORE DISPLAY 

		BEFORE ROW 
			IF exit_display= TRUE THEN 
				EXIT DISPLAY 
			END IF
			LET elements_number = arr_curr() 
			# display matching parent record
			CALL fetch_and_display_dbschema_properties (${ChildFkyArray}[elements_number].*)
			
			IF exit_display= TRUE THEN 
				EXIT DISPLAY 
			END IF

		ON ACTION ("doubleclick","Select ${ChildTable}") 

	END DISPLAY 

	RETURN elements_number-1 
END FUNCTION

<Script: if ($ChildLookupTables > 0 ) {
	bld_lookup_functions (${MainFormName},$ChildTable,"child" );
}:Script>
