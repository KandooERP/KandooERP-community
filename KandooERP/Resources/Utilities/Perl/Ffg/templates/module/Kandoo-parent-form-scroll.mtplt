<Script:our $FormShortName=$FormName; $FormShortName=~ s/^f_//; :Script>noprint
<Script:our $MstTableRec=${TblPrfx}${RecordPrefix}${ParentTable} :Script>noprint}
<Script:our $MstInpFormRec=${FrmPrfx}${RecordPrefix}${FormShortName} :Script>noprint
<Script:our $MstSavFormRec=sav_${RecordPrefix}${FormShortName} :Script>noprint
<Script:our $MstLkUpRec=${SRLUpPrfx} . ${ModuleName} :Script> noprint
<Script:our $GlobalReferenceRecord=${GlobalVarPrefix} . "kandoouser" :Script> noprint
<Script:our $ListTable=${ParentTable} :Script> noprint
<Script:our $BMLetter=substr(${ModuleName},1,1) :Script> noprint
<Script:our $BMCode=substr(${ModuleName},1,2) :Script> noprint
@GlobalDef
@ModuleDef
<AddRqrmnt:lib::lib_tool:AddRqrmnt> 
<AddRqrmnt:lib::lib_tool_db:AddRqrmnt> 
<AddRqrmnt:lib::lib_tool_windecoration:AddRqrmnt> 
<AddRqrmnt:lib::lib_tool_${BMLetter}_${BMCode}:AddRqrmnt> 

# module  generated by KandooERP Ffg(c)
# Generated on ${GenerationTS}
# Main template ${MainModuleTemplate} 
GLOBALS 
<Script: $QxWidgetsCount=define_Widgets ($SRCHANDLE,$MainFormName,".*",".*") :Script> 


	DEFINE ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} TYPE AS RECORD 		# This is the TYPE for form image record
		<Script:define_form_fields($SRCHANDLE,$MainFormName,".*","parent",".*","true|false","all","","\t\t")  :Script>
	END RECORD
	
	DEFINE ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} TYPE AS RECORD 			# This is the TYPE for table image record
		<Script:define_table_columns ($SRCHANDLE,${ParentTable},"","","all","record",$MstTableRec,"    "):Script>
	END RECORD
	
	DEFINE ${TypeDataPrefix}pky_${ParentTable} TYPE AS RECORD 
		<Script:define_PK_columns ($SRCHANDLE,${ParentTable},"pky",$DefineStyle):Script>
	END RECORD
	
	DEFINE ${ModuleVarPrefix}program CHAR(30)

<Script: if ( $ParentLookupTables > 0 ) { 
	$IndentLevel=1;
	define_lookup_fields ($MainFormName,"parent",$Prefix,$Tabul,$WriteMode,$isRecord) ;
}:Script>
	DEFINE g_${ParentTable} RECORD LIKE ${ParentTable}.*

MAIN
@Define
@Init 
	DEFER INTERRUPT
	
	-- WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	CALL setModuleId("ProgramName")			# put program name here (1 letter 2 or 3 digits)
	CALL ui_init(0)		#Initial UI Init

	DEFER QUIT
	DEFER INTERRUPT

	CALL main_${ModuleName}_${ParentTable}()

END MAIN

##########################################################################
FUNCTION mc_${ModuleName}_sccs()
## definition variable sccs
	DEFINE sccs_var CHAR(70)
LET sccs_var="%W% %D%"
END FUNCTION
##########################################################################
FUNCTION main_${ModuleName}_${ParentTable} ()
## this module's main function called by MAIN

	CALL security(getModuleId()) #authenticate
	CALL init_${BMLetter}_${BMCode}()      #init utility module	# put Business module letter + 2 letters

	CALL ${SqlPrepareQueriesFct}_parent_${ModuleName} () # initialize all cursors on master table
	<Script: if ( $ChildTable ne "" ) { 
		print "CALL ${SqlPrepareQueriesFct}_${ModuleName}_child\()      # initialize allcursors on Child table";
	}:Script>

	OPEN WINDOW ${MainFormName} WITH FORM "${MainFormName}"
	<Script: if ( $QxWidgetsCount > 0 ) { 
		print "CALL winDecoration("${MainFormName}()")";
	}  :Script>

	CALL menu_${ModuleName}_parent()      

	CLOSE WINDOW ${MainFormName}

END FUNCTION

######################################################################
FUNCTION menu_${ModuleName}_parent ()
## menu_${ModuleName}_parent
## the top level menu 
## input arguments: none
## output arguments: none
	DEFINE nbsel_${ParentTable} INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE record_num INTEGER
	DEFINE action smallint
	DEFINE xnumber smallint
	DEFINE arr_elem_num smallint
	DEFINE l_prykey_${ParentTable} ${TypeDataPrefix}_pky_${ParentTable} 					# Primary key record
	DEFINE ${LocalMstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record
	DEFINE ${LocalMstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	DEFINE where_clause STRING
	DEFINE record_found INTEGER
	DEFINE lookup_status INTEGER

	LET nbsel_${ParentTable} = 0
	MENU "${ParentTable}"
	BEFORE MENU
		<Script:
		printNoLF "HIDE OPTION \"${NextOption}\",\"${PreviousOption}\",\"${EditOption}\",\"${SuppressOption}\"";
		if ( defined($ChildTable) ) { 
			 printNoLF ",\"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
			 print "\n";
		} :Script>
		
	COMMAND "${QueryOption}" "${QueryCom} ${ParentTable}"
		MESSAGE ""
		INITIALIZE ${LocalMstInpFormRec}.* TO NULL
		CLEAR FORM
		DISPLAY BY NAME ${LocalMstInpFormRec}.*
		HIDE OPTION "${NextOption}","${PreviousOption}"

		# Build the QBE where clause
		CALL ${FrmConstructDatasetFct}_parent_${ModuleName}() RETURNING where_clause   

		# Call the function that counts matching rows and opens the scroll cursor on primary key
		CALL ${SqlDeclarePkyScrCrsFct}_parent_${ModuleName}(where_clause)
		RETURNING nbsel_${ParentTable},sql_stmt_status
		
		IF nbsel_${ParentTable} > 0 THEN 
			CALL ${SqlNextPrevFct}_parent_${ModuleName}(1) RETURNING record_found,
			l_prykey_${ParentTable}.*

			CASE
			WHEN record_found = 1
				LET record_num = 1
				CALL ${SqlFetchFullRowFct}_parent_${ModuleName} (l_prykey_${ParentTable}.*)
				RETURNING record_found,${LocalMstInpFormRec}.*

				${FrmDisplayRecordFct}_parent_${ModuleName}_${MainFormName}(${LocalMstInpFormRec}.*)

				<Script: if ( defined($ChildTable) ) { 
					print "CALL ${InitializeArrayFct}_${ChildTable}()";
					print "LET arr_elem_num = ${FillArrayFromFgnKeyFct}$ChildTable (l_prykey_${ParentTable}.*)"; 				
					print "SHOW OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
				} :Script>
			WHEN record_found = -1 
				ERROR "${Unreachable} ",sqlca.sqlcode
			END CASE
			IF nbsel_${ParentTable} > 1 THEN
			   SHOW OPTION "${NextOption}"
			   NEXT OPTION "${NextOption}"
			END IF
			SHOW OPTION "${EditOption}","${SuppressOption}"
		ELSE 
			ERROR "${NorowsSelected}"
			NEXT OPTION "${QueryOption}"
		END IF

	COMMAND "${NextOption}" "${NextCom} ${ParentTable}"
		MESSAGE ""
		CLEAR FORM
		INITIALIZE ${LocalMstInpFormRec}.* TO NULL

		IF record_num <= nbsel_${ParentTable} THEN
			CALL ${SqlNextPrevFct}_parent_${ModuleName}(1) RETURNING record_found,
			l_prykey_${ParentTable}.*

			CASE 
			WHEN record_found = 0 
				ERROR "${Lastrow} ${ParentTable}"
			WHEN record_found = -1 
				ERROR "${Unreachable} ",sqlca.sqlcode
			WHEN record_found = 1
				LET record_num = record_num + 1
				CALL ${SqlFetchFullRowFct}_parent_${ModuleName} (l_prykey_${ParentTable}.*)
				RETURNING record_found,${LocalMstInpFormRec}.*
				${FrmDisplayRecordFct}_parent_${ModuleName}_${MainFormName}(${LocalMstInpFormRec}.*)
				<Script: if ( defined($ChildTable) ) { 
					print "CALL ${InitializeArrayFct}_${ChildTable}()";
					print "LET arr_elem_num = ${FillArrayFromFgnKeyFct}$ChildTable (l_prykey_${ParentTable}.*)";
					print "IF arr_elem_num > 0 THEN";
					print "\tCALL ${DisplayArrayFct}${ChildTable}(True)";
					print "END IF";
					$line="SHOW OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
					print $line;
				} :Script>

				IF record_num >= nbsel_${ParentTable} THEN
				   HIDE OPTION "${NextOption}"
				END IF
                IF record_num > 1 THEN
                	SHOW OPTION "${PreviousOption}"
                ELSE
                	HIDE OPTION "${PreviousOption}"
				END IF
			END CASE
		ELSE
			ERROR " ${SelectFirst}  ${ParentTable} "
			NEXT OPTION "${QueryOption}" 
		END IF

	COMMAND "${PreviousOption}" "${PreviousCom} ${ParentTable}"
		MESSAGE ""
		CLEAR FORM
		INITIALIZE ${LocalMstInpFormRec}.* TO NULL

		IF record_num >= 1  THEN
			CALL ${SqlNextPrevFct}_parent_${ModuleName}(-1) RETURNING record_found,
			l_prykey_${ParentTable}.*
			CASE 
			WHEN record_found = 0
				ERROR "${FirstRow} ${ParentTable}"
			WHEN record_found < -1
				ERROR "${Unreachable} ",sqlca.sqlcode
			WHEN record_found = 1
				LET record_num = record_num - 1
				CALL ${SqlFetchFullRowFct}_parent_${ModuleName} (l_prykey_${ParentTable}.*)
				RETURNING record_found,${LocalMstInpFormRec}.*
				
				${FrmDisplayRecordFct}_parent_${ModuleName}_${MainFormName}(${LocalMstInpFormRec}.*)
				<Script: if ( defined($ChildTable) ) { 
					print "CALL ${InitializeArrayFct}_${ChildTable}()";
					print "LET arr_elem_num = ${FillArrayFromFgnKeyFct}$ChildTable (l_prykey_${ParentTable}.*)";
					print "IF arr_elem_num > 0 THEN";
					print "\tCALL ${DisplayArrayFct}${ChildTable}(True)";
					print "END IF";
					print "SHOW OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
				} :Script>

				IF record_num = 1  THEN
				   HIDE OPTION "${PreviousOption}"
				END IF
                IF record_num < nbsel_${ParentTable} THEN
                	SHOW OPTION "${NextOption}"
                ELSE
                	HIDE OPTION "${NextOption}"
				END IF
			END CASE
		ELSE
			ERROR " ${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

	COMMAND "${AddOption}" "${InsertCom} ${ParentTable}"
		MESSAGE ""
		CALL ${FrmInputRecordFct}_parent_${ModuleName}(MODE_CLASSIC_ADD,l_prykey_${ParentTable}.*,${LocalMstInpFormRec}.*) 
		RETURNING sql_stmt_status,l_prykey_${ParentTable}.*
		MESSAGE ""
		<Script: if ( defined($ChildTable) ) {
			print "SHOW OPTION \"${EditArrayMessage}${ChildTable}\"";
			print "CALL ${InitializeArrayFct}_${ChildTable}()";
#			print "CALL ${FillArrayFromFgnKeyFct}${ChildTable} (l_prykey_${ParentTable}.*)" ;
		} :Script>

	COMMAND "${EditOption}" "${UpdateCom} ${ParentTable}"
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF ${SqlCheckPrimaryKeyFct}_${ParentTable}(l_prykey_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${NextOption}"
			ELSE
				CALL ${FrmInputRecordFct}_parent_${ModuleName}(MODE_CLASSIC_EDIT,l_prykey_${ParentTable}.*,${LocalMstInpFormRec}.*) 
				RETURNING sql_stmt_status,l_prykey_${ParentTable}.*
			END IF
		ELSE
			ERROR " ${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

   COMMAND "${SuppressOption}" "${DeleteCom} ${ParentTable}"
		<Script: if ($DoHelp eq 'true') {
			print "		HELP 6000";
		} :Script>
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF ${SqlCheckPrimaryKeyFct}_${ParentTable}(l_prykey_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${NextOption}"
			END IF
			WHILE TRUE
				CALL confirm_operation(5,10,"${SuppressOption}") RETURNING action
				CASE 
				WHEN action = 0 OR action = 1 
					EXIT WHILE  # degage abandon
				WHEN action = 2   
					CALL ${FrmSuppressRecordFct}_parent_${ModuleName}(l_prykey_${ParentTable}.*)
					RETURNING sql_stmt_status
					EXIT WHILE
				END CASE
			END WHILE
		ELSE
			ERROR "${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

	<Script: if ( defined($ChildTable) ) { 
	print "COMMAND KEY (${ViewArrayKey}) \"${ViewArrayMessage}${ChildTable}\"";
	print "\tCALL ${DisplayArrayFct}${ChildTable} (l_prykey_${ParentTable}.*,False)"; 
	
	print "COMMAND KEY (${EditArrayKey}) \"${EditArrayMessage}${ChildTable}\"";
	print "\tCALL ${EditArrayFct}${ChildScreenRecord} (l_prykey_${ParentTable}.*)";
	} :Script>
	
	COMMAND "${Quit}" "${QuitCom}"
		MESSAGE ""
		EXIT MENU
	END MENU
END FUNCTION		# menu_${ModuleName}_parent ()

#######################################################################
FUNCTION ${FrmConstructDatasetFct}_parent_${ModuleName}()
## ${FrmConstructDatasetFct}_parent_${ModuleName}_${MainFormName} : Query By Example on table ${ParentTable}
## Input selection criteria,
## prepare the query,
## open the data set
	DEFINE qbe_statement,where_clause STRING
	DEFINE xnumber,sql_stmt_status INTEGER
	DEFINE l_pky ${TypeDataPrefix}pky_${ParentTable} 

	DEFINE ${LocalMstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record

	DEFINE reply CHAR(5)
	LET xnumber = 0
	MESSAGE "${InputCriteria}"
	# initialize record and display blank
	CLEAR FORM
	INITIALIZE ${LocalMstInpFormRec}.* TO NULL
	DISPLAY BY NAME ${LocalMstInpFormRec}.* 

	CONSTRUCT BY NAME where_clause ON <Script: print_form_fields ($SRCHANDLE,$MainFormName,$ParentTable,"parent",".*","false",".*","TblName","\t\t","","","reset"):Script>

	## Check whether criteria have been entered
	AFTER CONSTRUCT 
		IF NOT field_touched(${ParentTable}.*) AND NOT int_flag THEN
			LET reply = fgl_winbutton("","${SelectAllRows}","${Yes}","${Yes}|${No}","question",0)
			CASE 
			WHEN reply MATCHES "${Yes}"
				EXIT CONSTRUCT 
			OTHERWISE                  # Saisie d'un critere de selection
				ERROR "${Oneatleast}"
				CONTINUE CONSTRUCT
			END CASE
		END IF
	END CONSTRUCT

	IF int_flag = TRUE THEN
		LET where_clause = NULL
		MESSAGE "${CancelCom}"
		LET int_flag=0
	END IF
	RETURN where_clause
END FUNCTION		## ${FrmConstructDatasetFct}_parent_${ModuleName}

#######################################################################
# ${FrmDisplayRecordFct}_parent_${ModuleName}_${MainFormName} : displays the form record after reading and displays lookup records if any
# inbound: Form record.*
FUNCTION ${FrmDisplayRecordFct}_${ModuleName}(${InboundMstInpFormRec})
	DEFINE ${InboundMstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 
/#		<Script:define_form_fields($SRCHANDLE,$MainFormName,${ParentTable},"parent","parent","false","all","","\t\t")  :Script>
/#	END RECORD

	<Script: if ( $ParentLookupTables > 0 ) { 
		$IndentLevel=1;
		print "DEFINE lookup_status INTEGER";
		define_lookup_fields ($MainFormName,"parent",$Prefix,$Tabul,$WriteMode,$isRecord) ;
	}:Script>

	DISPLAY BY NAME <Script:print_form_fields ($SRCHANDLE,$MainFormName,$ParentTable,"parent",".*","false|true",".*",${InboundMstInpFormRec},"\t\t\t","","","reset"):Script>
	<Script: if ( $ParentLookupTables > 0 ) {
			bld_lookup_calls ($FormName,"parent",$ParentTable,$MstInpFormRec);
			printNoLF "DISPLAY " ;
			print_form_fields ($SRCHANDLE,$MainFormName,".*","parent","lookup",".*",".*",${SRLUpPrfx}."TblName","",'skip') ;
			printNoLF "\nTO ";
			print_form_fields ($SRCHANDLE,$MainFormName,".*","parent","lookup",".*",".*","TblName","",'skip') ;
	}:Script>

END FUNCTION		# ${FrmDisplayRecordFct}_parent_${ModuleName}_${MainFormName}

#######################################################################
# ${FrmInputRecord}_${ModuleName}_${MainFormName} : Edit a ${ParentTable} RECORD
# inbound: p_mode : determines whether Add or Edit record (ADD/EDIT)
#          p_pky: table primary key
#          ${InboundMstInpFormRec} : contents of the form record
FUNCTION ${FrmInputRecord}_${ModuleName}(p_mode,p_pky,${InboundMstInpFormRec})
	DEFINE action SMALLINT  
	DEFINE sql_stmt_status,dummy SMALLINT
	DEFINE p_mode NCHAR(5)
	DEFINE p_pky ${TypeDataPrefix}pky_${ParentTable}									#Primary key record 
	DEFINE ${InboundMstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record
	DEFINE ${MstSavFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record to save the data
	DEFINE ${LocalMstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	<Script: if ( $ParentLookupTables > 0 ) {
		print "DEFINE lookup_status INTEGER"
	}:Script>
	DEFINE rows_count SMALLINT

	## check if record can be accessed
	WHILE true
		LET int_flag = false
		IF p_mode = CLASSIC_MODE_EDIT THEN
			# Save Screen Record values before altering
			LET ${MstSavFormRec}.* = ${InboundMstInpFormRec}.* 
			BEGIN WORK
			EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS"
			WHENEVER SQLERROR CONTINUE
			CALL crs_upd_${ParentTable}.Open(p_pky.*)
			CALL crs_upd_${ParentTable}.FetchNext(dummy)
			IF sqlca.sqlcode = -244 THEN
				ERROR "THIS ROW IS BEING MODIFIED"
				ROLLBACK WORK
				EXIT WHILE
			END IF
		END IF

		INPUT BY NAME <Script: print_form_fields ($SRCHANDLE,$MainFormName,$ParentTable,"parent",".*","false",".*",${InboundMstInpFormRec},"\t\t\t","","","reset"):Script>
		WITHOUT DEFAULTS
			BEFORE INPUT
			IF p_mode = CLASSIC_MODE_EDIT THEN 	# IF we edit the record, we do not modify the primary key fields
				CALL DIALOG.SetFieldActive("inv_start_num", FALSE)
			ELSE
				CALL DIALOG.SetFieldActive("inv_start_num", TRUE)
			END IF

			<Script: if ( $ParentLookupTables > 0 ) {
				print_input_events($SRCHANDLE,$MainFormName,${ParentTable},"parent","fkey",${InboundMstInpFormRec},"       ",${GlobalAlternateRecord} );
			}:Script>

			<Script: if ($DoPickListWindows eq 'true' && $ParentLookupTables > 0 ) { 
				bld_picklist_calls($ParentTable) ;
			}:Script>
						
		END INPUT

		IF int_flag = TRUE THEN
			LET int_flag=false
			# Restore previous value
			LET ${InboundMstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY ${InboundMstInpFormRec}.*  TO ${ParentTable}.*
			<Script: if ( $ParentLookupTables > 0 ) {
				bld_lookup_calls ($FormName,"parent",$ParentTable,$MstInpFormRec);
				printNoLF "DISPLAY " ;
				print_form_fields ($SRCHANDLE,$MainFormName,".*","parent","lookup",".*",".*",${SRLUpPrfx}."TblName","\t","skip","") ;
				printNoLF "\nTO " ;
				print_form_fields ($SRCHANDLE,$MainFormName,".*","parent","lookup",".*",".*","TblName","\t","skip","") ;
			}:Script>
			
			EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
			ROLLBACK WORK
			MESSAGE "$CancelCom ${CancelKey}"
			EXIT WHILE
		END IF 

		CALL confirm_operation(4,10,"${EditOption}") RETURNING action

		CASE 
		WHEN action = 0
			# Redo, leave values as modified
			CONTINUE WHILE
		WHEN action = 1 
			# Resign, restore original values
			LET ${InboundMstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY ${InboundMstInpFormRec}.*  TO ${ParentTable}.*
			EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
			ROLLBACK WORK
			EXIT WHILE   # Cancel operation

		WHEN action = 2   
			# confirm update
			CALL ${SetTableRecordFct}_parent_${MainFormName}_${ParentTable}("U",${InboundMstInpFormRec}.*)
			RETURNING ${LocalMstTableRec}.*
			
			# Perform the prepared update statement
			LET sql_stmt_status = ${SqlUpdateFct}_parent_${ModuleName}(p_pky.*,${LocalMstTableRec}.*) 
			CASE 
			WHEN sql_stmt_status = 0
				MESSAGE "${EditOption} ${ParentTable} ${Successful}"
				EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
				COMMIT WORK

			WHEN sql_stmt_status < 0
				CALL display_error("${EditOption} ${ParentTable}:${Failed} ")
				EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
				ROLLBACK WORK

			END CASE
			EXIT WHILE
		END CASE
	END WHILE
	RETURN sql_stmt_status
END FUNCTION		## ${FrmInputRecord}_${ModuleName}(p_pky)

####################################################################
## ${FrmAddRecordFct}_${ModuleName}_${MainFormName}: add a new ${ParentTable} row
FUNCTION ${FrmAddRecordFct}_${ModuleName}()
	DEFINE sql_stmt_status SMALLINT
	DEFINE rows_count SMALLINT
	DEFINE l_nbrows_${ParentTable} ,action SMALLINT

	DEFINE ${LocalMstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record
	DEFINE ${LocalMstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	<Script: if ( $ParentLookupTables > 0 ) { 
		$IndentLevel=1;
		print "DEFINE lookup_status INTEGER";
		define_lookup_fields ($MainFormName,"parent",$Prefix,$Tabul,$WriteMode,$isRecord) ;
	}:Script>

	CLEAR FORM
	INITIALIZE ${LocalMstInpFormRec}.* TO NULL

	WHILE true
		LET int_flag = false
		INPUT BY NAME <Script: print_form_fields ($SRCHANDLE,$MainFormName,$ParentTable,"parent",".*","false",".*", ${LocalMstInpFormRec} ,"\t\t\t","","","reset"):Script>
		WITHOUT DEFAULTS
		<Script: 
		print_input_events($SRCHANDLE,$MainFormName,${ParentTable},"parent","pkey|fkey", ${LocalMstInpFormRec} ,"       ",${GlobalAlternateRecord} )
		:Script>

		<Script: if ($DoPickListWindows eq 'true' && $ParentLookupTables > 0 ) { 
			bld_picklist_calls($ParentTable) ;
		}:Script>
		END INPUT
		IF int_flag = TRUE THEN
			# Resign from input
			LET int_flag=false
			DISPLAY ${LocalMstInpFormRec} .*  TO ${ParentTable}.*
			MESSAGE "${CancelCom} ${CancelKey}"
			EXIT WHILE
		END IF 

		CALL confirm_operation(3,10,"${AddOption}") RETURNING action
		CASE action
		WHEN 0            # I want to edit the input, remains displayed 'as is'
			CONTINUE WHILE   # leave display as is
			
		WHEN 2            # transaction is committed
			BEGIN WORK
			CALL ${SetTableRecordFct}_parent_${MainFormName}_${ParentTable}('+', ${LocalMstInpFormRec} .*)
			RETURNING ${LocalMstTableRec}.*
			CALL ${SqlInsertFct}_parent_${ModuleName}(${LocalMstTableRec}.*) 
			returning sql_stmt_status,
			<Script:print_table_columns($SRCHANDLE,${ParentTable},"","","","pkey","",$MstTableRec,"flat","",""); :Script>

			CASE 
			WHEN sql_stmt_status = 0
				MESSAGE "${AddOption} ${ParentTable} ${Successful}"
				COMMIT WORK

			WHEN sql_stmt_status < 0
				CALL display_error("${AddOption} ${ParentTable}:${Failed} ")
				ROLLBACK WORK

			END CASE
			EXIT WHILE

		WHEN 0
			ROLLBACK WORK
			EXIT WHILE
		END CASE
	END WHILE
	# ${LocalMstTableRec}
	RETURN sql_stmt_status,<Script:print_table_columns($SRCHANDLE,${ParentTable},"","","","pkey","",$MstTableRec,"flat","",""); :Script>
END FUNCTION		## ${FrmAddRecordFct}_${ModuleName}_${MainFormName}


#######################################################################
# ${FrmEditRecordFct}_${ModuleName}_${MainFormName} : Edit a ${ParentTable} RECORD
# inbound: table primary key
FUNCTION ${FrmEditRecordFct}_${ModuleName}(p_prykey,${MstInpFormRec})
	DEFINE action SMALLINT  
	DEFINE sql_stmt_status,dummy SMALLINT

	DEFINE ${MstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record
	DEFINE ${MstSavFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record to save the data
	DEFINE ${LocalMstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record
	DEFINE p_prykey ${TypeDataPrefix}pky_${ParentTable}									#Primary key record 
	<Script: if ( $ParentLookupTables > 0 ) {
		print "DEFINE lookup_status INTEGER"
	}:Script>
	DEFINE rows_count SMALLINT

	## check if record can be accessed
	WHILE true
		LET int_flag = false
		# Save Screen Record values before altering
		LET ${MstSavFormRec}.* = ${MstInpFormRec}.* 
		BEGIN WORK
		EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS"
		WHENEVER SQLERROR CONTINUE
		CALL crs_upd_${ParentTable}.Open(p_prykey.*)
		CALL crs_upd_${ParentTable}.FetchNext(dummy)
		IF sqlca.sqlcode = -244 THEN
			ERROR "THIS ROW IS BEING MODIFIED"
			ROLLBACK WORK
			EXIT WHILE
		END IF

		INPUT BY NAME <Script: print_form_fields ($SRCHANDLE,$MainFormName,$ParentTable,"parent",".*","false","attr",${MstInpFormRec},"         ","","","reset")  :Script>
		WITHOUT DEFAULTS
		<Script: if ( $ParentLookupTables > 0 ) {
			print_input_events($SRCHANDLE,$MainFormName,${ParentTable},"parent","fkey",${MstInpFormRec},"       ",${GlobalAlternateRecord} );
		}:Script>

		<Script: if ($DoPickListWindows eq 'true' && $ParentLookupTables > 0 ) { 
			bld_picklist_calls($ParentTable) ;
		}:Script>
					
		END INPUT
		IF int_flag = TRUE THEN
			LET int_flag=false
			# Restore previous value
			LET ${MstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY ${MstInpFormRec}.*  TO ${ParentTable}.*
			<Script: if ( $ParentLookupTables > 0 ) {
				bld_lookup_calls ($FormName,"parent",$ParentTable,$MstInpFormRec);
				printNoLF "DISPLAY " ;
				print_form_fields ($SRCHANDLE,$MainFormName,".*","parent","lookup",".*",".*",${SRLUpPrfx}."TblName","\t","skip","") ;
				printNoLF "\nTO " ;
				print_form_fields ($SRCHANDLE,$MainFormName,".*","parent","lookup",".*",".*","TblName","\t","skip","") ;
			}:Script>
			
			EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
			ROLLBACK WORK
			MESSAGE "$CancelCom ${CancelKey}"
			EXIT WHILE
		END IF 

		CALL confirm_operation(4,10,"${EditOption}") RETURNING action

		CASE 
		WHEN action = 0
			# Redo, leave values as modified
			CONTINUE WHILE
		WHEN action = 1 
			# Resign, restore original values
			LET ${MstInpFormRec}.* = ${MstSavFormRec}.*
			DISPLAY ${MstInpFormRec}.*  TO ${ParentTable}.*
			EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
			ROLLBACK WORK
			EXIT WHILE   # Cancel operation

		WHEN action = 2   
			# confirm update
			CALL ${SetTableRecordFct}_parent_${MainFormName}_${ParentTable}("U",${MstInpFormRec}.*)
			RETURNING ${LocalMstTableRec}.*
			
			# Perform the prepared update statement
			LET sql_stmt_status = ${SqlUpdateFct}_parent_${ModuleName}(p_prykey.*,${LocalMstTableRec}.*) 
			CASE 
			WHEN sql_stmt_status = 0
				MESSAGE "${EditOption} ${ParentTable} ${Successful}"
				EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
				COMMIT WORK

			WHEN sql_stmt_status < 0
				CALL display_error("${EditOption} ${ParentTable}:${Failed} ")
				EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ"
				ROLLBACK WORK

			END CASE
			EXIT WHILE
		END CASE
	END WHILE
	RETURN sql_stmt_status
END FUNCTION		## ${FrmEditRecordFct}_${ModuleName}(p_prykey)


#######################################################################
# DELETE A ${ParentTable} row
# inbound: table primary key
FUNCTION ${FrmSuppressRecordFct}_parent_${ModuleName}(p_prykey)
	DEFINE action SMALLINT
	DEFINE dummy SMALLINT
	DEFINE sql_stmt_status SMALLINT
	DEFINE p_prykey 	${TypeDataPrefix}pky_${ParentTable}					#Primary key record  

	WHILE TRUE
		CALL confirm_operation(5,10,"${SuppressOption}") RETURNING action
		BEGIN WORK
		EXECUTE IMMEDIATE "SET ISOLATION TO COMMITTED READ RETAIN UPDATE LOCKS"
		WHENEVER SQLERROR CONTINUE
		CALL crs_upd_${ParentTable}.Open(p_prykey.*)
		CALL crs_upd_${ParentTable}.FetchNext(dummy)
		IF sqlca.sqlcode = -244 THEN
			ERROR "THIS ROW IS BEING MODIFIED"
			ROLLBACK WORK
			EXIT WHILE
		END IF

		CASE 
		WHEN action = 0 OR action = 1 
			# can the delete operation
			EXIT WHILE  
		WHEN action = 2
			# Validate the delete operation
			CALL ${SqlDeleteFct}_parent_${ModuleName}(p_prykey.*) RETURNING sql_stmt_status
			CASE 
			WHEN sql_stmt_status = 0
				MESSAGE "${SuppressOption} ${ParentTable} ${Successful}"
				COMMIT WORK

			WHEN sql_stmt_status < 0
				CALL display_error("${SuppressOption} ${ParentTable}:${Failed} ")
				ROLLBACK WORK

			END CASE
			EXIT WHILE
		END CASE
	END WHILE
	RETURN sql_stmt_status
END FUNCTION		## ${FrmSuppressRecordFct}_parent_${ModuleName}(p_prykey)

#########################################################################
#  Build, prepare, declare and initialize main queries and cursors
FUNCTION ${SqlPrepareQueriesFct}_parent_${ModuleName} ()
	DEFINE sql_stmt_text STRING

	# Declare cursor for full master table row contents, access by primary key
	LET sql_stmt_text=
	"SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},"","","","all","","","flat","",""):Script>",
	" FROM ${ParentTable} ",
	"WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>"
	CALL crs_row_${ParentTable}.Declare(sql_stmt_text)
	
	# Declare cursor for row test / check if locked
	let sql_stmt_text= "SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},"","","",${KeyMode},"","","flat","",""); :Script>",
	" FROM ${ParentTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>"
	CALL crs_pky_${ParentTable}.Declare(sql_stmt_text)
	
	# Declare cursor for SELECT FOR UPDATE
	let sql_stmt_text= "SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},"","","",${KeyMode},"","","flat","",""); :Script>",
	" FROM ${ParentTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>",
	" FOR UPDATE"
	CALL crs_upd_${ParentTable}.Declare(sql_stmt_text,1,0)

	# PREPARE INSERT statement
	LET sql_stmt_text =
	"INSERT INTO ${ParentTable} (<Script:print_table_columns($SRCHANDLE,${ParentTable},"","","exclnoentry","all","","","flat","",""):Script>)",
	" VALUES ( <Script:print_table_columns($SRCHANDLE,${ParentTable},"","","","all","placeholders","","flat","",1); :Script>)" 
	CALL pr_ins_${ParentTable}.Prepare(sql_stmt_text)

	# PREPARE UPDATE statement
	let sql_stmt_text=
	"UPDATE ${ParentTable} ",
	"SET ( <Script:print_table_columns($SRCHANDLE,${ParentTable},"","","false","attr","","","flat","",""); :Script>)",
	" = ( <Script:print_table_columns ($SRCHANDLE,${ParentTable},"","","false","attr","placeholders","","flat","",""); :Script>)",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>" 
	CALL pr_upd_${ParentTable}.Prepare(sql_stmt_text)

	# PREPARE DELETE statement
	let sql_stmt_text= "DELETE FROM ${ParentTable} ",
	" WHERE <Script: bld_where_clause($SRCHANDLE,${ParentTable},${KeyMode},"?","","    ") ;:Script>" 
	CALL pr_del_${ParentTable}.Prepare(sql_stmt_text)

END FUNCTION		## ${SqlPrepareQueriesFct}_parent_${ModuleName}

#########################################################
FUNCTION ${SqlDeclarePkyScrCrsFct}_parent_${ModuleName}(where_clause)
## Build the query generated by CONSTRUCT BY NAME,
## Declare and open the cursor
## inbound param: query predicate
## outbound parameter: query status
	DEFINE where_clause STRING
	DEFINE qbe_statement STRING
	DEFINE rows_count integer
	DEFINE lsql_stmt_status integer

	# define primary_key record
	DEFINE l_pky ${TypeDataPrefix}pky_${ParentTable}					#Primary key record   

	LET qbe_statement = 
		"SELECT count(*) FROM ${ParentTable}",
		" WHERE ",where_clause CLIPPED

	CALL crs_cnt_${ParentTable}.Declare(qbe_statement)
	CALL crs_cnt_${ParentTable}.Open()
	SET ISOLATION TO DIRTY READ
	WHENEVER SQLERROR CONTINUE
	
	CALL crs_cnt_${ParentTable}.FetchNext(rows_count)
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	SET ISOLATION TO COMMITTED READ

	# if FETCH fails, count = 0, the, get back to query
	IF sqlca.sqlcode OR rows_count = 0 THEN
		let rows_count =0
	END IF
	CALL crs_cnt_${ParentTable}.Free()

	# display the selected columns

	LET qbe_statement = "SELECT <Script:print_table_columns($SRCHANDLE,${ParentTable},"","","",${KeyMode},"record","","flat","    "); :Script>",
	" FROM ${ParentTable} ",
	"WHERE ",where_clause clipped,
	" ORDER BY <Script:print_table_columns($SRCHANDLE,${ParentTable},"","","",${KeyMode},"","","","flat","",$endline,1); :Script>"

	# crs_scrl_pky_${ParentTable} : the first cursor selects all the primary keys (not all the table columns)
	CALL crs_scrl_pky_${ParentTable}.Declare(qbe_statement,1,1)   # SCROLL CURSOR WITH HOLD

	WHENEVER SQLERROR CONTINUE
	CALL crs_scrl_pky_${ParentTable}.Open()
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	RETURN rows_count,sqlca.sqlcode
END FUNCTION		## ${SqlDeclarePkyScrCrsFct}_parent_${ModuleName}

#######################################################################
FUNCTION ${SqlNextPrevFct}_parent_${ModuleName}(offset)
## ${SqlNextPrevFct}_parent_${ModuleName} : FETCH NEXT OR PREVIOUS RECORD
	DEFINE offset SMALLINT
	define lsql_stmt_status,record_found integer
	DEFINE pky ${TypeDataPrefix}l_prykey_${ParentTable}					#Primary key record   

	DEFINE ${MstInpFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,${ParentTable},"parent","parent","false","all","","\t\t")  :Script>
	END RECORD

	WHENEVER SQLERROR CONTINUE
	FETCH RELATIVE offset CALL crs_scrl_pky_${ParentTable}.FetchRelative(offset,l_prykey.*)
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	CASE 
		WHEN sqlca.sqlcode = 100 
			LET record_found = 0
		
		WHEN sqlca.sqlcode < 0 
			LET record_found = -1
		OTHERWISE
			LET lsql_stmt_status = 1
			LET record_found = 1
	END CASE
	RETURN record_found,l_prykey.*
END FUNCTION		## ${SqlNextPrevFct}_parent_${ModuleName}

#########################################################################################
FUNCTION ${SqlFetchFullRowFct}_parent_${ModuleName}(p_prykey_${ParentTable})
# ${SqlFetchFullRowFct}_parent_${ModuleName} : read a complete row accessing by primary key
# inbound parameter : primary key
# outbound parameter: sql_stmt_status and row contents
	DEFINE sql_stmt_status smallint
	DEFINE p_prykey_${ParentTable} ${TypeDataPrefix}pky_${ParentTable}					#Primary key record   
	DEFINE ${LocalMstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record
	DEFINE ${MstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName}	# Form image record

	<Script: if ( $ParentLookupTables > 0 ) { 
		$IndentLevel=1;
		print "DEFINE lookup_status INTEGER" ;
		define_lookup_fields ($MainFormName,"parent",$Prefix,$Tabul,$WriteMode,$isRecord) ;
	}:Script>

	# read the table, access on primary key
WHENEVER SQLERROR CONTINUE
	CALL crs_row_${ParentTable}.Open(pky_${ParentTable}.*)
	CALL crs_row_${ParentTable}.FetchNext(${LocalMstTableRec}.*)

WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	CASE
		WHEN  sqlca.sqlcode = 100 
			LET sql_stmt_status = 0
		WHEN  sqlca.sqlcode < 0 
				LET sql_stmt_status = -1
		OTHERWISE
			LET sql_stmt_status = 1
			CALL ${SetFormRecordFct}_parent_${ParentTable}_${MainFormName}(${LocalMstTableRec}.*)
			RETURNING ${MstInpFormRec}.*
	END CASE
	RETURN sql_stmt_status,${MstInpFormRec}.*
END FUNCTION		## ${SqlFetchFullRowFct}_parent_${ModuleName}

########################################################################
FUNCTION ${SqlInsertFct}_parent_${ModuleName}(p_${MstTableRec})
## INSERT in table ${ParentTable} 
	DEFINE lsql_stmt_status integer
	DEFINE rows_count SMALLINT
	DEFINE p_prykey ${TypeDataPrefix}pky_${ParentTable}					#Primary key record
	DEFINE p_${MstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	WHENEVER SQLERROR CONTINUE
	CALL pr_ins_${ParentTable}.Execute(<Script:print_table_columns($SRCHANDLE,${ParentTable},"","","","all","",p_${MstTableRec},"","    ",""):Script>)
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	IF sqlca.sqlcode < 0 THEN   
		LET lsql_stmt_status = -1
	ELSE 
		LET lsql_stmt_status = 0
		<Script:catch_last_serial_value($SRCHANDLE,${ParentTable},p_${MstTableRec}):Script>
		
	END IF
	RETURN lsql_stmt_status,p_prykey.*
END FUNCTION		## ${SqlInsertFct}_parent_${ModuleName}

########################################################################
FUNCTION ${SqlUpdateFct}_parent_${ModuleName}(p_prykey,p_${MstTableRec})
## ${SqlUpdateFct}_parent_${ModuleName} :update ${ParentTable} record
	DEFINE lsql_stmt_status integer
	DEFINE p_prykey ${TypeDataPrefix}pky_${ParentTable}					#Primary key record   
	DEFINE p_${MstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	WHENEVER SQLERROR CONTINUE
	CALL pr_upd_${ParentTable}.Execute(<Script:print_table_columns($SRCHANDLE,${ParentTable},"","","false","attr","",p_${MstTableRec},"","    ",$endline,1):Script>,p_prykey.*)

WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	IF sqlca.sqlcode < 0 THEN   
		LET lsql_stmt_status = -1
	ELSE 
		LET lsql_stmt_status = 0
	END IF
	RETURN lsql_stmt_status
END FUNCTION		## ${SqlUpdateFct}_parent_${ModuleName}

##############################################################################################
FUNCTION ${SqlDeleteFct}_parent_${ModuleName}(p_prykey)
## ${SqlDeleteFct}_parent_${ModuleName} :delete current row in table ${ParentTable} 
	DEFINE lsql_stmt_status smallint
	DEFINE p_prykey ${TypeDataPrefix}pky_${ParentTable}					#Primary key record   

	WHENEVER SQLERROR CONTINUE
	CALL pr_del_${ParentTable}.Execute(p_prykey.*)

WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	IF sqlca.sqlcode < 0 THEN   
		LET lsql_stmt_status = -1
	ELSE
		LET lsql_stmt_status=0
	END IF
	RETURN lsql_stmt_status
END FUNCTION		## ${SqlDeleteFct}_parent_${ModuleName}

################################################################################
FUNCTION ${SqlCheckPrimaryKeyFct}_${ParentTable}(p_prykey)  
##   ${SqlCheckPrimaryKeyFct}_${ParentTable} : Check if primary key exists
## inbound parameter : record of primary key
## outbound parameter:  status > 0  if exists, 0 if no record, < 0 if error
	DEFINE p_prykey ${TypeDataPrefix}pky_${ParentTable}					#Primary key record   
	DEFINE pk_status INTEGER

	WHENEVER SQLERROR CONTINUE
	CALL crs_pky_${ParentTable}.Open(p_prykey.*)
	CALL crs_pky_${ParentTable}.FetchNext() 
	WHENEVER SQLERROR CALL ${ErrorMngmtFunction}

	CASE sqlca.sqlcode
		WHEN 0 
			let pk_status = 1
		WHEN 100
			let pk_status = 0
		WHEN sqlca.sqlerrd[2] = 104
			let pk_status = -1		# record locked
		WHEN sqlca.sqlcode < 0
			let pk_status = sqlca.sqlcode
	END CASE

	RETURN pk_status
END FUNCTION		## ${SqlCheckPrimaryKeyFct}_${ParentTable}

################################################################################################
FUNCTION ${SetFormRecordFct}_parent_${ParentTable}_${MainFormName}(tbl_contents)
## ${SetFormRecordFct}_parent_${ParentTable}_${MainFormName}_${MainFormName}: assigns table values to form fields values
	DEFINE frm_contents ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 		# Form image record
	DEFINE tbl_contents ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	INITIALIZE frm_contents.* TO NULL
	<Script:
	set_form_record ($SRCHANDLE,${ParentTable},${MainFormName},"frm_contents","tbl_contents") 
	:Script>
	RETURN frm_contents.*
END FUNCTION		## ${SetFormRecordFct}${ModuleName}_${MainFormName}

################################################################################################
FUNCTION ${SetTableRecordFct}_parent_${MainFormName}_${ParentTable}(sql_stmt_type,frm_contents)
## ${SetTableRecordFct}_parent_${MainFormName}_${ParentTable}: assigns form fields value to table values
	DEFINE sql_stmt_type CHAR(1)					# + => Insert, # => Update
	DEFINE l_prykey ${TypeDataPrefix}pky_${ParentTable}					#Primary key record   
	DEFINE frm_contents ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 		# Form image record
	DEFINE tbl_contents ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	INITIALIZE tbl_contents.* TO NULL
	CASE sql_stmt_type
		WHEN "I"			# Prepare record for INSERT
			<Script:set_table_record ($SRCHANDLE,${ParentTable},${MainFormName},"parent","frm_contents","tbl_contents","I") :Script>
		WHEN "U"			# Prepare record for UPDATE
			<Script:set_table_record ($SRCHANDLE,${ParentTable},${MainFormName},"parent","frm_contents","tbl_contents","U") :Script>
	END CASE

	RETURN tbl_contents.*
END FUNCTION		## ${SetTableRecordFct}${MainFormName}_${ParentTable}

<Script: if ($ParentLookupTables > 0 ) {
	bld_lookup_functions ( ${MainFormName},$ParentTable,"parent" );
}:Script>

<Script: if ( $QxWidgetsCount > 0 ) { 
	bld_populate_widgets_calls_function($SRCHANDLE,$MainFormName,".*",".*") ;
	bld_populate_widgets_functions($SRCHANDLE,$MainFormName,".*",".*") ;
}  :Script>

<Script: if ( $ParentLookupTables > 0 && $DoPickListWindows eq "true" ) { 
	bld_picklist_windows($ModuleName) ;
} :Script>