<Script:our $FormShortName=$FormName; $FormShortName=~ s/^f_//; :Script>noprint
<Script:our $MstTableRec=${TblPrfx}${RecordPrefix}${ParentTable} :Script>noprint}
<Script:our $MstInpFormRec=${FrmPrfx}${RecordPrefix}${FormShortName} :Script>noprint
<Script:our $MstInpFormRecAsParam=p_${FrmPrfx}${RecordPrefix}${FormShortName} :Script>noprint
<Script:our $MstSavFormRec=sav_${RecordPrefix}${FormShortName} :Script>noprint
<Script:our $MstLkUpRec=${SRLUpPrfx} . ${ModuleName} :Script> noprint
<Script:our $ListTable=${ParentTable} :Script> noprint
@GlobalDef
@ModuleDef
<AddRqrmnt:lib::lib_security:AddRqrmnt> 
<AddRqrmnt:lib::lib_tool:AddRqrmnt> 

# module  generated by KandooERP Ffg(c)
# Generated on ${GenerationTS}
# Main template ${MainModuleTemplate} 

DATABASE ${DatabaseName}

GLOBALS
	DEFINE ${GlobalReferenceRecord} RECORD LIKE ${GlobalReferenceTable}.*
END GLOBALS

<Script: $QxWidgetsCount=define_Widgets ($SRCHANDLE,$MainFormName,".*",".*") :Script> 
	DEFINE ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} TYPE AS RECORD 		# This is the TYPE for form image record
		<Script:define_form_fields($SRCHANDLE,$MainFormName,".*","parent","parent","false","false","","\t\t")  :Script>
	END RECORD
	
	DEFINE ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} TYPE AS RECORD 			# This is the TYPE for table image record
		<Script:define_table_columns ($SRCHANDLE,${ParentTable},"","","all","record",$MstTableRec,"    "):Script>
	END RECORD
	
	DEFINE ${TypeDataPrefix}${PrmryKeyPrefix}_${ParentTable} TYPE AS RECORD 
		<Script:define_PK_columns ($SRCHANDLE,${ParentTable},"pky",$DefineStyle):Script>
	END RECORD
	
	DEFINE ${TypeDataPrefix}formonly TYPE AS RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"formonly","parent","parent","true","false","","\t\t")  :Script>
	END RECORD

	DEFINE ${ModuleVarPrefix}program CHAR(30)

	<Script: if ( $ParentLookupTables > 0 ) { 
	$IndentLevel=1;
	define_lookup_fields ($MainFormName,"parent","astype",$Tabul,$WriteMode,$isRecord) ;
	}:Script>

MAIN
@Define
@Init 
	DEFER INTERRUPT
	
	-- WHENEVER SQLERROR CALL ${ErrorMngmtFunction}
	--CALL setModuleId("ProgramName")			# put program name here (1 letter 2 or 3 digits)
	--CALL ui_init(0)		#Initial UI Init

	DEFER QUIT
	DEFER INTERRUPT

	--CALL security(getModuleId()) #authenticate
	--CALL init_u_ut() #init utility module	# put Business module letter + 2 letters

	SELECT * INTO ${GlobalReferenceRecord}.* FROM company
	WHERE cmpy_code = "KA"

	CALL main_${ProgramName}()

END MAIN

##########################################################################
FUNCTION mc_${ModuleName}_sccs()
## definition variable sccs
	DEFINE sccs_var CHAR(70)
LET sccs_var="%W% %D%"
END FUNCTION
##########################################################################
FUNCTION main_${ProgramName} ()
## this module's main function called by MAIN
	DEFINE ${PrmryKeyPrefix}_${ParentTable} ${TypeDataPrefix}${PrmryKeyPrefix}_${ParentTable}
	DEFINE ${WhereClauseVariable} STRING
	DEFINE ${ElementIsPicked} SMALLINT
	DEFINE idx SMALLINT

	CALL ${SqlPrepareQueriesFct}_${ModuleName}_parent () # initialize all cursors on master table
	<Script: if ( $ChildTable ne "" ) { 
		print "CALL ${SqlPrepareQueriesFct}_${ModuleName}_child\(\)    # initialize allcursors on Child table";
	}:Script>

	OPEN WINDOW ${PLWPrefix}${ListTable}
	WITH FORM "${ListFormName}" ATTRIBUTES(border)

	MENU "${ParentTable}"

	COMMAND "List Current ${ParentTable}" 
		LET ${WhereClauseVariable} = "1 = 1"
		CALL ${ListRecordsFct}_${ModuleName}(${WhereClauseVariable})
		RETURNING ${ElementIsPicked},idx,${PrmryKeyPrefix}_${ParentTable}.*
		CALL menu_${ProgramName} (${ElementIsPicked},idx,${PrmryKeyPrefix}_${ParentTable}.*)

	COMMAND "${QueryOption}" "${QueryCom} ${ParentTable} in a list window"
		CALL ${FrmFctPrefix}_${QueryOption}_${ModuleName}_${ListFormName}()
		RETURNING ${WhereClauseVariable} 
		CALL ${ListRecordsFct}_${ModuleName}(${WhereClauseVariable})
		RETURNING ${ElementIsPicked},idx,${PrmryKeyPrefix}_${ParentTable}.*
		CALL menu_${ProgramName} (${ElementIsPicked},idx,${PrmryKeyPrefix}_${ParentTable}.*)

	
	ON ACTION "${Quit}"
		EXIT MENU
	END MENU

END FUNCTION

#################################################################################
FUNCTION menu_${ProgramName} (p_picked,p_matching_rows,p_${PrmryKeyPrefix}_${ParentTable})
## menu_${ProgramName}
## the top level menu 
## input arguments: none
## output arguments: none
	DEFINE nbsel_${ParentTable} INTEGER
	DEFINE ${SqlStmtStatus} INTEGER
	DEFINE record_num INTEGER
	DEFINE p_matching_rows INTEGER
	DEFINE arr_elem_num INTEGER
	DEFINE p_picked SMALLINT
	DEFINE action SMALLINT
	DEFINE xnumber SMALLINT
	DEFINE p_${PrmryKeyPrefix}_${ParentTable} ${TypeDataPrefix}${PrmryKeyPrefix}_${ParentTable} 					# Primary key record
	DEFINE ${MstInpFormRec} ${TypeDataPrefix}frm_${RecordPrefix}${FormShortName} 	# Form image record
	DEFINE ${MstTableRec} ${TypeDataPrefix}tbl_${RecordPrefix}${ParentTable} 		# Table image record

	DEFINE ${WhereClauseVariable} STRING
	DEFINE record_found INTEGER
	DEFINE lookup_status INTEGER

	OPEN WINDOW ${MainFormName} WITH FORM "${MainFormName}"
	<Script: if ( $QxWidgetsCount > 0 ) { 
		$line=sprintf "CALL %s_%s()\n",${InitWidgetsFct},$ModuleName;
		$OutLineNum=ffg_print($SRCHANDLE,$line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$TmpltLineNum,$SIGNHANDLE); 
	}  :Script>
	
	CASE
		WHEN p_picked = 1
			LET record_num = 1
			CALL ${SqlFetchFullRowFct}_${ParentTable}_${ModuleName} (p_${PrmryKeyPrefix}_${ParentTable}.*)
			RETURNING record_found,${MstInpFormRec}.*

			CALL ${FrmDisplayRecordFct}_${ModuleName}_${MainFormName}(${MstInpFormRec}.*)

			<Script: if ( defined($ChildTable) ) { 
				print "CALL ${InitializeArrayFct}_${ChildTable}()";
				print "LET arr_elem_num = ${PopulateArrayFct}$ChildTable (p_${PrmryKeyPrefix}_${ParentTable}.*)";
				print "IF arr_elem_num > 0 THEN";
				print "\tCALL ${DisplayArrayFct}${ChildTable}(true)";
				print "END IF";
				print "SHOW OPTION \"${ViewArrayMessage}${ChildTable}\",\"${EditArrayMessage}${ChildTable}\"";
			} :Script>
		WHEN p_picked = -1
			ERROR "${Unreachable} ",sqlca.sqlcode
		WHEN p_picked = 0
			ERROR "${NorowsSelected}"
	END CASE

	MENU "${ParentTable}"
	BEFORE MENU

	COMMAND "${AddOption}" "${InsertCom} ${ParentTable}"
		<Script: if ($DoHelp eq 'true') {
			print "		HELP 4000";
		} :Script>
		MESSAGE ""
		CALL ${FrmAddRecordFct}_${ModuleName}_${MainFormName}() RETURNING ${SqlStmtStatus},p_${PrmryKeyPrefix}_${ParentTable}.*
		MESSAGE ""

	COMMAND "${EditOption}" "${UpdateCom} ${ParentTable}"
		<Script: if ($DoHelp eq 'true') {
			print "		HELP 5000";
		} :Script>
		MESSAGE ""
		IF p_picked THEN
			IF ${SqlCheckPrimaryKeyFct}_${ParentTable}(p_${PrmryKeyPrefix}_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${NextOption}"
			ELSE
				CALL ${FrmEditRecordFct}_${ModuleName}_${MainFormName}(p_${PrmryKeyPrefix}_${ParentTable}.*,${MstInpFormRec}.*)
				RETURNING ${SqlStmtStatus}
			END IF
		ELSE
			ERROR " ${SelectFirst} ${ParentTable} "
		END IF

   COMMAND "${SuppressOption}" "${DeleteCom} ${ParentTable}"
		<Script: if ($DoHelp eq 'true') {
			print "		HELP 6000";
		} :Script>
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF ${SqlCheckPrimaryKeyFct}_${ParentTable}(p_${PrmryKeyPrefix}_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
			END IF
			WHILE TRUE
				CALL confirm_operation(5,10,"${SuppressOption}") RETURNING action
				CASE 
				WHEN action = 0 OR action = 1 
					EXIT WHILE  # degage abandon
				WHEN action = 2   
					CALL ${FrmSuppressRecordFct}_${ModuleName}_${MainFormName}(p_${PrmryKeyPrefix}_${ParentTable}.*)
					RETURNING ${SqlStmtStatus}
					EXIT WHILE
				END CASE
			END WHILE
		ELSE
			ERROR "${SelectFirst} ${ParentTable} "
		END IF

	<Script: if ( defined($ChildTable) ) { 
	print "ON ACTION (${ViewArrayKey}) ";
	print "\tCALL ${DisplayArrayFct}${ChildTable} (False)"; 
	print "";
	print "ON ACTION (${EditArrayKey}) ";
	print "\tCALL ${EditArrayFct}${ChildTable} (p_${PrmryKeyPrefix}_${ParentTable}.*)"; 
	} :Script>

	COMMAND "Return" "Return to List"
		<Script: if ($DoHelp eq 'true') {
			print "		HELP 9000";
		} :Script>
		MESSAGE ""
		EXIT MENU
	END MENU
	CLOSE WINDOW ${MainFormName}
END FUNCTION

<:Include parent-common-functions.mtplt :Include>