<Script:our $CursorSufx="m".${ParentTable} :Script>noprint
<Script:our $MstTableRec=${TblPrfx} . ${ModuleName} :Script>noprint}
<Script:our $MstInpFormRec=${SRInpPrfx} . ${ModuleName} :Script>noprint
<Script:our $MstSavFormRec=${SRSavPrfx} . ${ModuleName} :Script>noprint
<Script:our $MstLkUpRec=${SRLUpPrfx} . ${ModuleName} :Script> noprint
@GlobalDef
@ModuleDef
<AddRqrmnt:fgl::common/generic_functions.4gl:AddRqrmnt> 
# module  generated by Querix Ffg(c) 
# Generated on ${GenerationTS}
# template ${TemplateFile}  

<Script: $QxWidgetsCount=define_Widgets ($SRCHANDLE,$MainFormName,".*",".*") :Script> 
DATABASE ${DatabaseName}
	DEFINE ${ModuleVarPrefix}program CHAR(30)

	DEFINE ${MstTableRec} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},"all","record",$MstTableRec,"    "):Script>
	END RECORD 

	DEFINE ${MstInpFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent",".*","all","false","","\t\t")  :Script>
	END RECORD

	DEFINE ${MstSavFormRec} RECORD 
		<Script:define_form_fields($SRCHANDLE,$MainFormName,"parent",".*","all","false","","\t\t")  :Script>
	END RECORD

<Script: if ( $ParentLookupTables > 0 ) { 
	$IndentLevel=1;
	$OutLineNum=ffg_print($SRCHANDLE,"DEFINE ${MstLkUpRec} RECORD",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
	$IndentLevel++;
	define_form_fields($SRCHANDLE,$MainFormName,".*",".*","all","true","","\t\t");  
	$OutLineNum=ffg_print($SRCHANDLE,"\n\tEND RECORD",$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 	
}:Script>

MAIN
@Define
@Init 
	DEFER INTERRUPT
	OPTIONS
	help file "${ModuleName}.iem",
	help key ${Helpkey}

	# WHENEVER ERROR CALL ${ErrorMngmtFunction}
	# CALL ui_init(0) 
	LET ${ModuleVarPrefix}program="p_${ModuleName}_${ParentTable}"

	CALL main_${ModuleName}_${ParentTable}()

END MAIN

#######################################################
# definition variable sccs
FUNCTION mc_${ModuleName}_sccs()
	DEFINE sccs_var CHAR(70)
LET sccs_var="%W% %D%"
END FUNCTION

FUNCTION main_${ModuleName}_${ParentTable} ()
	DEFINE ${PrmryKeyPrefix}_${ParentTable} RECORD
		<Script:define_table_variables ($SRCHANDLE,$ParentTable,"pkey","record","pky","    "):Script>
	END RECORD
	CALL init_program("${DatabaseName}",${ModuleVarPrefix}program)
	CALL ${PrepareQueriesFct}_${ModuleName}_${ParentTable} () # initialize all cursors on master table
	CALL menu_${ModuleName}_${ParentTable} ()
	
	CALL ${ParentTblPickListFct}_${ParentTable} ()
	RETURNING ${PrmryKeyPrefix}_${ParentTable}
	
	OPEN WINDOW ${MainFormName} WITH FORM "${MainFormName}" attributes(border)
	<Script: if ( $QxWidgetsCount > 0 ) { 
		$line=sprintf "CALL %s_%s()\n",${InitWidgetsFct},$ModuleName;
		$OutLineNum=ffg_print($SRCHANDLE,$line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
		}  :Script>


	

	CALL menu_${ModuleName}_${ParentTable}()      

	CLOSE WINDOW ${MainFormName}

END FUNCTION

######################################################################
# menu_${ModuleName}_${ParentTable}
# the top level menu 
# input arguments: none
# output arguments: none
FUNCTION menu_${ModuleName}_${ParentTable} ()
	DEFINE nbsel_${ParentTable} INTEGER
	DEFINE sql_stmt_status INTEGER
	DEFINE record_num INTEGER
	DEFINE action smallint
	DEFINE xnumber smallint
	DEFINE arr_elem_num smallint
	DEFINE ${PrmryKeyPrefix}_${ParentTable} RECORD 
		<Script:define_table_variables ($SRCHANDLE,${ParentTable},${KeyMode},"record","pky","    "):Script>
	END RECORD

	LET nbsel_${ParentTable} = 0
	MENU "${ParentTable}"
	BEFORE MENU
		HIDE OPTION "${NextOption}","${PreviousOption}"
	COMMAND "${QueryOption}" "${QueryCom} ${ParentTable}"
		HELP 1000
		MESSAGE ""
		INITIALIZE ${MstInpFormRec}.* TO NULL
		DISPLAY BY NAME ${MstInpFormRec}.*
		HIDE OPTION "${NextOption}","${PreviousOption}"

		<Script: if ( $ParentLookupTables > 0 ) { 
			$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
		} :Script>

		CALL ${QueryOption}_${ParentTable}() RETURNING nbsel_${ParentTable}
		IF nbsel_${ParentTable} <>0 THEN 
			CALL ${SqlNextPrevFct}_${ParentTable}(1) RETURNING sql_stmt_status,${PrmryKeyPrefix}_${ParentTable}.*
			LET record_num = 1
			DISPLAY BY NAME ${MstInpFormRec}.*
			IF nbsel_${ParentTable} > 1 THEN
			   SHOW OPTION "${NextOption}"
			   NEXT OPTION "${NextOption}"
			END IF
			<Script: if ( $ParentLookupTables > 0 ) { 
				$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n" ;
				$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) ;
			} :Script>
		ELSE 
			ERROR "${NorowsSelected}"
			NEXT OPTION "${QueryOption}"
		END IF

	COMMAND "${NextOption}" "${NextCom} ${ParentTable}"
		HELP 2000
		MESSAGE ""
		INITIALIZE ${MstInpFormRec}.* TO NULL
		DISPLAY BY NAME ${MstInpFormRec}.*
		<Script: if ( $ParentLookupTables > 0 ) { 
			$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
		} :Script>

		IF record_num < nbsel_${ParentTable} THEN
			CALL ${SqlNextPrevFct}_${ParentTable}(1) RETURNING sql_stmt_status,${PrmryKeyPrefix}_${ParentTable}.*
			CASE 
			WHEN sql_stmt_status = 0 
				ERROR "${Lastrow} ${ParentTable}"
			WHEN sql_stmt_status = -1 
				ERROR "${Unreachable} ",sqlca.sqlcode
			WHEN sql_stmt_status = 1
				LET record_num = record_num + 1
				DISPLAY BY NAME ${MstInpFormRec}.*
				IF record_num >= nbsel_${ParentTable} THEN
				   HIDE OPTION "${NextOption}"
				END IF
                IF record_num > 1 THEN
                	SHOW OPTION "${PreviousOption}"
                ELSE
                	HIDE OPTION "${PreviousOption}"
				END IF
				<Script: if ( $ParentLookupTables > 0 ) { 
					$Line=sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n"; 
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE); 
				} :Script>
			END CASE
		ELSE
			ERROR " ${SelectFirst}  ${ParentTable} "
			NEXT OPTION "${QueryOption}" 
		END IF

	COMMAND "${PreviousOption}" "${PreviousCom} ${ParentTable}"
		HELP 3000
		MESSAGE ""
		INITIALIZE ${MstInpFormRec}.* TO NULL
		DISPLAY BY NAME ${MstInpFormRec}.*
		<Script: if ( $ParentLookupTables > 0 ) { 
			$Line = sprintf "INITIALIZE ${MstLkUpRec}.* TO NULL\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE);
			$Line = sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n";
			$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
		}:Script>

		IF record_num > 1  THEN
			CALL ${SqlNextPrevFct}_${ParentTable}(-1) RETURNING sql_stmt_status,${PrmryKeyPrefix}_${ParentTable}.*
			CASE 
			WHEN sql_stmt_status = 0
				ERROR "${FirstRow} ${ParentTable}"
			WHEN sql_stmt_status < -1
				ERROR "${Unreachable} ",sqlca.sqlcode
			WHEN sql_stmt_status = 1
				LET record_num = record_num - 1
				CALL ${SetFormRecordFct}${ModuleName}_${MainFormName}(${MstTableRec}.*)
				RETURNING ${MstInpFormRec}.*
				DISPLAY BY NAME ${MstInpFormRec}.*
				IF record_num = 1  THEN
				   HIDE OPTION "${PreviousOption}"
				END IF
                IF record_num < nbsel_${ParentTable} THEN
                	SHOW OPTION "${NextOption}"
                ELSE
                	HIDE OPTION "${NextOption}"
				END IF
				<Script: if ( $ParentLookupTables > 0 ) { 
					$Line=sprintf "DISPLAY BY NAME ${MstLkUpRec}.*\n"; 
					$OutLineNum=ffg_print($SRCHANDLE,$Line,$OutLineNum,$FctName,"AdHoc",$TemplateFile,$InLineNum,$SIGNHANDLE) 
				}:Script>
			END CASE
		ELSE
			ERROR " ${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

	COMMAND "${AddOption}" "${InsertCom} ${ParentTable}"
		HELP 3000
		MESSAGE ""
		CALL ${AddOption}_${ParentTable}() RETURNING sql_stmt_status,${PrmryKeyPrefix}_${ParentTable}.*
		MESSAGE ""

	COMMAND "${ModifyOption}" "${UpdateCom} ${ParentTable}"
		HELP 4000
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF ${CkPrimaryKeyFct}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${NextOption}"
			ELSE
				LET sql_stmt_status = ${ModifyOption}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*)
			END IF
		ELSE
			ERROR " ${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

   COMMAND "${RemoveOption}" "${DeleteCom} ${ParentTable}"
		HELP 5000
		MESSAGE ""
		IF nbsel_${ParentTable} THEN
			IF ${CkPrimaryKeyFct}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*) < 0 THEN
				ERROR "${Islock} "
				NEXT OPTION "${NextOption}"
			END IF
			WHILE TRUE
				CALL confirm_operation(5,10,"${RemoveOption}") RETURNING action
				CASE 
				WHEN action = 0 OR action = 1 
					EXIT WHILE  # degage abandon
				WHEN action = 2   
					CALL ${RemoveOption}_${ParentTable}(${PrmryKeyPrefix}_${ParentTable}.*)
					RETURNING sql_stmt_status
					EXIT WHILE
				END CASE
			END WHILE
		ELSE
			ERROR "${SelectFirst} ${ParentTable} "
			NEXT OPTION "${QueryOption}"
		END IF

	COMMAND "${Quit}" "${QuitCom}"
		HELP 9000
		MESSAGE ""
		EXIT MENU
	END MENU
END FUNCTION

FUNCTION ${ParentTblPickListFct}_${ParentTable}()
	DEFINE idx,choice,xpos,ypos INTEGER
	DEFINE ${ArrCurrVar},scrline INTEGER
	DEFINE ${PLWPrefix}${PrmryKeyPrefix}_array DYNAMIC ARRAY OF RECORD
		<Script:define_table_variables ($SRCHANDLE,$ParentTable,"pkey","record","pky","    "):Script>
	END RECORD
	DEFINE ${PLWPrefix}attr_array DYNAMIC ARRAY OF RECORD
		<Script: define_scr${RecordPrefix}fields($SRCHANDLE,$FormName,$PickListScreenRecord,".*","all",".*","","\t\t") :Script>
	END RECORD

	OPEN WINDOW ${MainFormName} WITH FORM "${MainFormName}"
	
	options 
		accept key ${PLWAcceptKey},
		form line ${PLWLine}

	MESSAGE "${PLMessage}:${PLWAcceptKey}" 
	SET ISOLATION TO DIRTY READ

	DECLARE crs_pl_${ParentTable} CURSOR FOR
	SELECT <Script:print_scr${RecordPrefix}fields($SRCHANDLE,$FormName,$PickListScreenRecord,$ParentTable, ".*",".*",$MstPrefix,"","skip",""):Script>,
		<Script:print_table_columns($SRCHANDLE,${ParentTable},"pkey","","","flat"):Script>
	FROM ${ParentTable}
	ORDER BY 1

	LET idx=1
	FOREACH crs_pl_${ParentTable} INTO ${PLWPrefix}attr_array[idx].*,${PLWPrefix}${PrmryKeyPrefix}_array[idx].*
	   LET idx=idx + 1
	   IF idx > 100 THEN
		  EXIT FOREACH
	   END IF
	END FOREACH

	LET idx=idx - 1
	CALL set_count(idx)

	DISPLAY ARRAY ${PLWPrefix}attr_array
	TO ${PickListScreenRecord}.*

	AFTER DISPLAY
	   IF int_flag THEN
		  LET int_flag = false
			 CONTINUE DISPLAY
	   END IF
	END DISPLAY
	CLOSE WINDOW ${PLWPrefix}${ParentTable}
	SET ISOLATION TO COMMITTED READ
	options accept key ESCAPE
	RETURN <Script:print_table_columns($SRCHANDLE,${ParentTable},"pkey","","${PLWPrefix}${PrmryKeyPrefix}_array[${ArrCurrVar}]","flat"); :Script>
END FUNCTION
